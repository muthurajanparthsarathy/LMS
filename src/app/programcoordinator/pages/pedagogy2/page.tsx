"use client"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import type React from "react"
import { useState, useRef, useEffect, useMemo, Fragment, JSX } from "react"
import { motion, AnimatePresence } from "framer-motion";
import { Breadcrumb, BreadcrumbItem, BreadcrumbLink, BreadcrumbList, BreadcrumbPage, BreadcrumbSeparator } from "@/components/ui/breadcrumb"
import {
    CheckCircle2,
    Merge,
    Split,
    HelpCircle,
    X,
    Plus,
    Pencil,
    Trash,
    AlertTriangle,
    ChevronDown,
    ZoomIn,
    ZoomOut,
    Move,
    Eye,
    FileText,
    SearchIcon,
    Check,
    Sliders,
    MoreVertical,
    Printer,
    BookOpen,
    User,
    Users,
    Presentation,
    FolderOpen,
    Info,
    MoreHorizontal,
    AlertCircle,
    CheckCircle,
    Layers,
    ChevronDownIcon,
    ChevronRightIcon,
    ChevronRight,
    ChevronUpCircle,
    ChevronUpIcon,
    Settings,
    Copy,
    RotateCcw,
    Loader2,
    CheckSquare,
    User2,
    Trash2,
    SquarePen,
    File,
} from "lucide-react"

import ExcelJS from 'exceljs'
import { saveAs } from 'file-saver';
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Checkbox } from "@/components/ui/checkbox"
import DashboardLayoutProgramcoordinator from "../../components/layout"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { courseStructureApi } from "@/apiServices/createCourseStucture"
import { moduleApi } from "@/apiServices/pedagogyAndModuleAdd/addmodule"
import { Label } from "@/components/ui/label"
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from "@/components/ui/dialog"
import { subModuleApi } from "@/apiServices/pedagogyAndModuleAdd/addsubmodule"
import { topicApi } from "@/apiServices/pedagogyAndModuleAdd/addtopic"
import { subTopicApi } from "@/apiServices/pedagogyAndModuleAdd/addsubtopic"
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query"
import { pedagogyViewApi } from "@/apiServices/pedagogyAndModuleAdd/pedagogy"
import { levelViewApi } from "@/apiServices/levelsView";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";
import PrintComponent, { PrintComponentRef } from "@/components/ui/PrintComponent";
import DropdownSection from "@/components/ui/dropdownSection";
import { toast, Toaster } from 'sonner';

interface Modules {
    _id: string
    id: string
    name?: string
    topics?: Topic[]
    title: string;
    description?: string;
    duration?: number;
    level?: string;
    courses: string[];

    index?: number;

}


type MergeRange = { startRow: number; endRow: number };

interface SubModuleCreateData {
    title: string;
    description?: string;
    level: string;
    moduleId: string;
    // courses: string;
    index?: number;
    duration?: number;
}

interface PreviewTableProps {
    tableRows: any[];
    courseHours: CourseHours;
    mergedCells: { [key: string]: MergedCell[] };
    selectedCourse: Course | null;
    activityTypes: {
        iDo: string[];
        weDo: string[];
        youDo: string[];
        all: string[];
    };
    selectedPedagogyTypes: ("iDo" | "weDo" | "youDo" | "all")[];
    moduleSpans: { [key: string]: number };
    subModuleSpans: { [key: string]: number };
    topicSpans: { [key: string]: number };
    exportSelections: {
        summaryIncludeTotalHours?: JSX.Element;
        hoursOption?: string;
        includeTotalHours?: React.JSX.Element;
        printPedagogy: any;
        showSummary: any;
        hierarchy: {
            module: boolean;
            subModule: boolean;
            topic: boolean;
            subTopic: boolean;
            level: boolean;
        };
        pedagogy: {
            iDo: boolean | string[];
            weDo: boolean | string[];
            youDo: boolean | string[];
        };
    };
    onExport: () => void;
    setExportSelections: React.Dispatch<React.SetStateAction<ExportSelections>>;
    isPrinting?: boolean;
}


interface ModuleFormData {
    title: string;
    description?: string;
    level: string;
    duration?: number;
    index?: number;
}

// Add this to your existing interfaces
interface Topic {
    _id: string;
    title: string;
    description?: string;
    level: string;
    moduleId: string;
    subModuleId: string;
    index?: number;
    duration?: number;
    courses: string;
}

interface TopicCreateData {
    title: string;
    description?: string;
    level: string;
    moduleId: string;
    subModuleId: string;
    courses: string;
    duration?: number;
}

// Add these to your existing interfaces
interface SubTopic {
    _id: string;
    title: string;
    description?: string;
    level: string;
    topicId: string;
    courses: string;
    index?: number;
    duration?: number;

}

interface SubTopicCreateData {
    title: string;
    description?: string;
    level: string;
    topicId: string;
    courses: string;
    duration?: number;
}

interface ExportSelections {
    includeTotalHours: any;
    hoursOption: string;
    printPedagogy: any;
    hierarchy: {
        module: boolean;
        subModule: boolean;
        topic: boolean;
        subTopic: boolean;
        level: boolean;
    };
    pedagogy: {
        iDo: boolean | string[];
        weDo: boolean | string[];
        youDo: boolean | string[];
    };
    showSummary: boolean;
}

interface CourseHours {
    [moduleId: string]: {
        [topicId: string]: {
            [subtopicId: string]: {
                "iDo": {
                    [activityName: string]: number;
                }
                "weDo": {
                    [activityName: string]: number;
                }
                "youDo": {
                    [activityName: string]: number;
                }
            }
        }
    }
}

interface MergedCell {
    startRow: number;
    endRow: number;
    value: number;
    type: "iDo" | "weDo" | "youDo";
    activity: string;
    rowIds: string[];
    hierarchyIds: {
        modules: string[];
        subModules: string[];
        topics: string[];
        subTopics: string[];
    };
}

interface Course {
    title: any;
    category: string;
    courseCode: string;
    clientName: string | undefined;
    serviceType: string | undefined;
    serviceModal: string | undefined;
    courseLevel: string;
    _id: string
    courseName: string
    courseHierarchy: string[]
    I_Do: string[]
    We_Do: string[]
    You_Do: string[]
}

interface MergedLevel {
    value: string;
    rowIds: string[];
    hierarchyIds: {
        modules: string[];
        subModules: string[];
        topics: string[];
        subTopics: string[];
    };
    startRow: number;
    endRow: number;
}
type ActivityType = "iDo" | "weDo" | "youDo";
type PedagogyType = "iDo" | "weDo" | "youDo";

interface HierarchyMerges {
    module: Record<string, MergeRange>;
    subModule: Record<string, MergeRange>;
    topic: Record<string, MergeRange>;
}

function DraggableZoomControls({
    zoomLevel,
    onZoomIn,
    onZoomOut,
    onResetZoom,

}: {
    zoomLevel: number
    onZoomIn: () => void
    onZoomOut: () => void
    onResetZoom: () => void

}) {
    const [position, setPosition] = useState({ x: 1000, y: 40 })
    const [isDragging, setIsDragging] = useState(false)
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 })
    const dragRef = useRef<HTMLDivElement>(null)

    const handleMouseDown = (e: React.MouseEvent) => {
        e.preventDefault()
        setIsDragging(true)
        setDragStart({
            x: e.clientX - position.x,
            y: e.clientY - position.y,
        })
    }

    useEffect(() => {
        const handleMouseMove = (e: MouseEvent) => {
            if (!isDragging) return

            const newX = e.clientX - dragStart.x
            const newY = e.clientY - dragStart.y

            // Constrain to viewport bounds
            const maxX = window.innerWidth - 200
            const maxY = window.innerHeight - 60

            setPosition({
                x: Math.max(0, Math.min(newX, maxX)),
                y: Math.max(0, Math.min(newY, maxY)),
            })
        }

        const handleMouseUp = () => {
            setIsDragging(false)
        }

        if (isDragging) {
            document.addEventListener("mousemove", handleMouseMove)
            document.addEventListener("mouseup", handleMouseUp)

            return () => {
                document.removeEventListener("mousemove", handleMouseMove)
                document.removeEventListener("mouseup", handleMouseUp)
            }
        }
    }, [isDragging, dragStart, position])

    return (
        <div
            ref={dragRef}
            className={`fixed z-50 bg-white rounded-lg shadow-lg border p-1 flex items-center gap-1 select-none ${isDragging ? "cursor-grabbing" : "cursor-grab"
                }`}
            style={{
                left: `${position.x}px`,
                top: `${position.y}px`,
            }}
            onMouseDown={handleMouseDown}
        >
            <div className="flex items-center gap-1 px-1">
                <Move className="w-3 h-3 text-gray-400" />
                <Button
                    variant="outline"
                    size="sm"
                    onClick={(e) => {
                        e.stopPropagation()
                        onZoomOut()
                    }}
                    className="h-6 w-6 p-0 text-xs"
                    title="Zoom Out Table"
                    disabled={zoomLevel <= 0.5}
                >
                    <ZoomOut className="w-2.5 h-2.5" />
                </Button>

                <Button
                    variant="outline"
                    size="sm"
                    onClick={(e) => {
                        e.stopPropagation()
                        onResetZoom()
                    }}
                    className="h-6 px-2 text-xs min-w-[40px]"
                    title="Reset Table Zoom"
                >
                    {Math.round(zoomLevel * 100)}%
                </Button>

                <Button
                    variant="outline"
                    size="sm"
                    onClick={(e) => {
                        e.stopPropagation()
                        onZoomIn()
                    }}
                    className="h-6 w-6 p-0 text-xs"
                    title="Zoom In Table"
                    disabled={zoomLevel >= 2}
                >
                    <ZoomIn className="w-2.5 h-2.5" />
                </Button>
            </div>
        </div>
    )
}

const popupVariants = {
    hidden: {
        opacity: 0,
        y: 20,
        transition: { duration: 0.1 }
    },
    visible: {
        opacity: 1,
        y: 0,
        transition: { duration: 0.3, ease: "easeOut" }
    },
    exit: {
        opacity: 0,
        y: -20,
        transition: { duration: 0.1 }
    }
} as const

const popAnimation = {
    initial: { scale: 1 },
    animate: {
        scale: [1, 2, 1],
        transition: {
            duration: 1,
            ease: "easeInOut"
        }
    },
    exit: { scale: 1 }
} as any

export default function PedagogyManagement() {
    const fullscreenContainerRef = useRef<HTMLDivElement>(null)
    const [token, setToken] = useState<string | null>(null)
    const [selectedCourse, setSelectedCourse] = useState<Course | null>(null)
    const {
        data: courses = [],
        isLoading: isCoursesLoading,
        error: coursesError
    } = useQuery(courseStructureApi.getAll());
    const queryClient = useQueryClient();
    // Add to your state declarations
    const [contentHeight, setContentHeight] = useState(0);
    const scaledContentRef = useRef<HTMLDivElement | null>(null);
    const [showUnmergeDialog, setShowUnmergeDialog] = useState(false);
    const [movableCell, setMovableCell] = useState<{
        type: 'module' | 'submodule' | 'topic' | 'subtopic';
        id: string;
    } | null>(null);
    const [pendingUnmerge, setPendingUnmerge] = useState<{
        type: "iDo" | "weDo" | "youDo" | "all";
        activity: string;
        mergeIndex: number;
        hierarchyIds?: any;
    } | null>(null);
    const [showDeleteCellDialog, setShowDeleteCellDialog] = useState(false);
    const [cellToDelete, setCellToDelete] = useState<{
        moduleId: string;
        topicId: string;
        subtopicId: string;
        subModuleId: string;
        type: "iDo" | "weDo" | "youDo";
        activity: string;
    } | null>(null);
    const [mergeEditError, setMergeEditError] = useState("");
    const [selectedSubModuleForTopic, setSelectedSubModuleForTopic] = useState<{
        id: string | any;
        moduleId: string;
        name: string;
    } | null>(null);
    const [topicFormData, setTopicFormData] = useState<Omit<TopicCreateData, 'moduleId' | 'subModuleId' | 'courses'>>({
        title: '',
        description: '',
        level: '',
        duration: 0
    });
    const printRef = useRef<PrintComponentRef>(null);
    const [isMergeSectionOpen, setIsMergeSectionOpen] = useState(false);
    const [editMode, setEditMode] = useState<{
        type: 'module' | 'submodule' | 'topic' | 'subtopic',
        data: any
    } | null>(null);
    const [actionsEnabled, setActionsEnabled] = useState(false)
    const [directActionsEnabled, setDirectActionsEnabled] = useState(false)
    const [isOpen, setIsOpen] = useState(false);
    const [duplicateChecked, setDuplicateChecked] = useState(false);
    const [undoRedoChecked, setUndoRedoChecked] = useState(false);
    const [showDeleteDialog, setShowDeleteDialog] = useState(false);
    const [itemToDelete, setItemToDelete] = useState<{
        type: 'module' | 'submodule' | 'topic' | 'subtopic',
        id: string
    } | null>(null);
    const [showDialog, setShowDialog] = useState(false);
    const [dialogType, setDialogType] = useState<'module' | 'submodule' | 'topic' | 'subtopic' | null>(null);
    const [editingMerge, setEditingMerge] = useState<{

        type: "iDo" | "weDo" | "youDo";

        activity: string;

        mergeIndex: number;

        value: number;
        hierarchyIds?: any;
    } | null>(null);
    const [mergedLevels, setMergedLevels] = useState<MergedLevel[]>([]);
    const [pendingLevelMerge, setPendingLevelMerge] = useState<{
        selectedRows: number[];
        hierarchyIds?: {
            modules: string[];
            subModules: string[];
            topics: string[];
            subTopics: string[];
        };
    } | null>(null);
    // Replace selectedRows state with selectedCells
    const [selectedCells, setSelectedCells] = useState<Set<string>>(new Set()); // Store as "rowIndex-type-activity"
    const [mergeLevelValue, setMergeLevelValue] = useState("");
    const [showMergeLevelDialog, setShowMergeLevelDialog] = useState(false);
    const [showPreviewDialog, setShowPreviewDialog] = useState(false);
    // Update the pedagogy views query to include modules dependency
    const [isSelectingCells, setIsSelectingCells] = useState(false);
    const [dragOverId, setDragOverId] = useState<string | null>(null);
    const {
        data: modules = [],
        isLoading: isModulesLoading,
        error: modulesError,
        refetch: refetchModules
    } = useQuery({
        ...moduleApi.getAll(),
        enabled: !!selectedCourse, // Only fetch when a course is selected
        select: (data) => {
            if (!selectedCourse) return [];
            // Filter modules to only include those that belong to the selected course
            return data.filter(module => module.courses.includes(selectedCourse._id));
        }
    });
    const createModuleMutation = useMutation(moduleApi.create());
    const updateModuleMutation = useMutation(moduleApi.update());
    const [showPedagogySection, setShowPedagogySection] = useState(false);
    const [selectedPedagogyActivities, setSelectedPedagogyActivities] = useState<{
        iDo: string[];
        weDo: string[];
        youDo: string[];
    }>({
        iDo: [],
        weDo: [],
        youDo: []
    });
    const [pedagogyHours, setPedagogyHours] = useState<{
        iDo: { [activity: string]: number };
        weDo: { [activity: string]: number };
        youDo: { [activity: string]: number };
    }>({
        iDo: {},
        weDo: {},
        youDo: {}
    });
    const [editingExistingLevelData, setEditingExistingLevelData] = useState<any>(null);
    const [showUnmergeLevelDialog, setShowUnmergeLevelDialog] = useState(false);
    const [pendingLevelUnmerge, setPendingLevelUnmerge] = useState<{
        mergeIndex: number;
        levelData?: any;
    } | null>(null);
    const pedagogyMutation = useMutation({
        mutationFn: (data: any) => {
            if (pedagogyViews?.length) {
                return pedagogyViewApi.update(pedagogyViews[0]._id).mutationFn(data);
            } else {
                return pedagogyViewApi.create().mutationFn({
                    courses: data.courses,
                    pedagogies: data.pedagogies
                });
            }
        },
        onSuccess: async () => {
            await queryClient.invalidateQueries({ queryKey: ['pedagogyViews'] });

            // Force a refetch of pedagogy views
            await queryClient.refetchQueries({
                queryKey: ['pedagogyViews', selectedCourse?._id, modules.length]
            });

            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 2000);
        }
    });
    const deletePedagogyMutation = useMutation({
        mutationFn: ({ activityType, itemId }: { activityType: string, itemId: string }) =>
            pedagogyViewApi.delete(activityType, itemId).mutationFn(),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['pedagogyViews'] });
            queryClient.invalidateQueries({ queryKey: ['courseStructure'] });
        }
    });
    const deleteDocumentMutation = useMutation({
        mutationFn: ({ model, id }: { model: 'Module1' | 'SubModule1' | 'Topic1' | 'SubTopic1' | 'PedagogyView1', id: any }) =>
            pedagogyViewApi.deleteDocument(model, id).mutationFn(),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['pedagogyViews'] });
        }
    });
    // Add to your component state
    const [draggingModuleId, setDraggingModuleId] = useState<string | null>(null);
    const [draggingSubModuleId, setDraggingSubModuleId] = useState<string | null>(null);
    const [draggingTopicId, setDraggingTopicId] = useState<string | null>(null);
    const [draggingSubtopicId, setDraggingSubtopicId] = useState<string | null>(null);
    const [selectedDuplicateCourse, setSelectedDuplicateCourse] = useState<Course | null>(null);

    const [selectedTopicForSubTopic, setSelectedTopicForSubTopic] = useState<{
        id: string | any;
        moduleId: string;
        subModuleId: string | any;
        name: string;
    } | null>(null);
    const [subTopicFormData, setSubTopicFormData] = useState<Omit<SubTopicCreateData, 'topicId' | 'courses'>>({
        title: '',
        description: '',
        level: 'Easy',
        duration: 0
    });
    const [moduleFormData, setModuleFormData] = useState<ModuleFormData>({
        title: '',
        description: '',
        level: 'Easy',
        duration: 0,
        index: 0
    });
    const [showDuplicatePopup, setShowDuplicatePopup] = useState(false);

    const [selectedModuleForSubModule, setSelectedModuleForSubModule] = useState<{ id: string, name: string } | null>(null);
    const [subModuleFormData, setSubModuleFormData] = useState<Omit<SubModuleCreateData, 'moduleId' | 'courseId'>>({
        title: '',
        description: '',
        level: 'Easy',
        duration: 0
    });
    const {
        data: subModules = [],
        isLoading: isSubModulesLoading,
        error: subModulesError,
        refetch: refetchSubModules
    } = useQuery({
        ...subModuleApi.getAll(),
        enabled: !!selectedCourse,
        select: (data) => {
            if (!selectedCourse) return [];
            return data.filter(subModule => subModule.courses.includes(selectedCourse._id));
        }
    });
    const createSubModuleMutation = useMutation(subModuleApi.create());
    const updateSubModuleMutation = useMutation(subModuleApi.update());
    const {
        data: topics = [],
        isLoading: isTopicsLoading,
        error: topicsError,
        refetch: refetchTopics
    } = useQuery({
        ...topicApi.getAll(),
        enabled: !!selectedCourse,
        select: (data) => {
            if (!selectedCourse) return [];
            return data.filter(topic => topic.courses.includes(selectedCourse._id));
        }
    });
    const {
        data: subTopics = [],
        isLoading: isSubTopicsLoading,
        error: subTopicsError,
        refetch: refetchSubTopics
    } = useQuery({
        ...subTopicApi.getAll(),
        enabled: !!selectedCourse,
        select: (data) => {
            if (!selectedCourse) return [];
            return data.filter(subTopic => subTopic.courses === selectedCourse._id);
        }
    });
    const hasModules = modules.length > 0;
    const hasTopics = topics.length > 0;
    // Check which hierarchy levels are configured for the course
    const hasModuleHierarchy = selectedCourse?.courseHierarchy.includes('Module') || false;
    const hasTopicHierarchy = selectedCourse?.courseHierarchy.includes('Topic') || false;
    const [mergeSelectionMode, setMergeSelectionMode] = useState<'level' | 'pedagogy' | null>(null);
    const [selectedMergeCells, setSelectedMergeCells] = useState<Set<string>>(new Set());
    const [expandedModules, setExpandedModules] = useState(new Set());
    const [expandedSubModules, setExpandedSubModules] = useState(new Set());
    const [expandedTopics, setExpandedTopics] = useState(new Set());

    // Check if we should show "Add First" messages
    const showAddModuleFirst = hasModuleHierarchy && !hasModules;
    const showAddTopicFirst = hasTopicHierarchy && !hasTopics && !hasModuleHierarchy;
    const shouldDisableControls = showAddModuleFirst || showAddTopicFirst;
    const [addOnlyPedagogyLevel, setAddOnlyPedagogyLevel] = useState(false);
    let nameOfMessage = "";
    if (showAddModuleFirst) {
        nameOfMessage = "Module";
    } else if (showAddTopicFirst) {
        nameOfMessage = "Topic";
    }
    const hasSubModule2 = () => {
        const hierarchyLevels = selectedCourse?.courseHierarchy.map(level => level.toLowerCase()) || [];
        return hierarchyLevels.includes("sub module");
    };
    // Update the getHeaderText function to return the full hierarchy
    const getHeaderText = () => {
        if (dialogType === "submodule") {
            return selectedModuleForSubModule ? `Module: ${selectedModuleForSubModule.name}` : "Module";
        }
        if (dialogType === "topic") {
            let text = "";
            if (selectedSubModuleForTopic) {
                const parentModule = modules.find(m => m._id === selectedSubModuleForTopic.moduleId);
                text = parentModule ? `Module: ${parentModule.title} → ` : "";
                text += `Submodule: ${selectedSubModuleForTopic.name}`;
            }
            return text || (hasSubModule2() ? "Submodule" : "Module");
        }
        if (dialogType === "subtopic") {
            let text = "";
            if (selectedTopicForSubTopic) {
                // Get module
                const parentModule = modules.find(m => m._id === selectedTopicForSubTopic.moduleId);
                if (parentModule) {
                    text += `Module: ${parentModule.title} → `;
                }

                // Get submodule if exists
                if (selectedTopicForSubTopic.subModuleId) {
                    const parentSubModule = subModules.find(sm => sm._id === selectedTopicForSubTopic.subModuleId);
                    if (parentSubModule) {
                        text += `Submodule: ${parentSubModule.title} → `;
                    }
                }

                // Get topic
                const parentTopic = topics.find(t => t._id === selectedTopicForSubTopic.id);
                if (parentTopic) {
                    text += `Topic: ${parentTopic.title}`;
                }
            }
            return text || "Topic";
        }
        return "";
    };

    const createSubTopicMutation = useMutation(subTopicApi.create());
    const updateSubTopicMutation = useMutation(subTopicApi.update());
    const {
        data: topicSubTopics = [],
        refetch: refetchTopicSubTopics
    } = useQuery({
        ...subTopicApi.getByTopicId(selectedTopicForSubTopic?.id || ''),
        enabled: !!selectedTopicForSubTopic?.id
    });
    const createTopicMutation = useMutation(topicApi.create());
    const updateTopicMutation = useMutation(topicApi.update());
    const [isCreatingModule, setIsCreatingModule] = useState(false);
    const [isCreatingSubModule, setIsCreatingSubModule] = useState(false);
    const [isCreatingTopic, setIsCreatingTopic] = useState(false);
    const [isCreatingSubTopic, setIsCreatingSubTopic] = useState(false);
    const [isConfirmDelete, setIsConfirmDelete] = useState(false);
    const [isConfirmMultiDelete, setIsConfirmMultiDelete] = useState(false);
    const [isLevelSave, setIsLevelSave] = useState(false);
    const [isLevelMergeSave, setIsLevelMergeSave] = useState(false);
    const [isLevelUnmergeConfirm, setIsLevelUnmergeConfirm] = useState(false);
    const [isPedagogyDeleteConfirm, setIsPedagogyDeleteConfirm] = useState(false);
    const [isUnmergeConfirm, setIsUnmergeConfirm] = useState(false);
    const [isMergeConfirm, setIsMergeConfirm] = useState(false);
    const [showLevelDeleteConfirmation, setShowLevelDeleteConfirmation] = useState(false);
    const [isLevelDelete, setIsLevelDelete] = useState(false);
    const [levelToDelete, setLevelToDelete] = useState<{ id: string; level?: string; hierarchy: any } | null>(null);
    const [courseStructure, setCourseStructure] = useState<Modules[]>([]);
    const [selected, setSelected] = useState(selectedCourse?._id || "")
    const [showSummaryDialog, setShowSummaryDialog] = useState(false);
    const [showFullPreviewDialog, setShowFullPreviewDialog] = useState(false);
    const [showMainFullPreviewDialog, setShowMainFullPreviewDialog] = useState(false);
    const [showSuccessMessage, setShowSuccessMessage] = useState(false)
    const [mergedCells, setMergedCells] = useState<{ [key: string]: MergedCell[] }>({})
    const [showInstructions, setShowInstructions] = useState(false)
    const [showMergeDialog, setShowMergeDialog] = useState(false)
    const [mergeHours, setMergeHours] = useState<string>("")
    const [pendingMerge, setPendingMerge] = useState<{
        type: "iDo" | "weDo" | "youDo"
        activity: string
        selectedRows: number[]
        hierarchyIds?: {
            modules: string[]
            subModules: string[]
            topics: string[]
            subTopics: string[]
        }
    } | null>(null);
    const [showLevelSection, setShowLevelSection] = useState(false);
    const [showMergeLevelSection, setShowMergeLevelSection] = useState(false);
    const [selectedLevel, setSelectedLevel] = useState('');
    const [selectedPedagogyTypes, setSelectedPedagogyTypes] = useState<("iDo" | "weDo" | "youDo" | "all")[]>([]);
    const [showErrorDialog, setShowErrorDialog] = useState(false);
    const [errorMessage, setErrorMessage] = useState("");
    const [showMultipleDeleteDialog, setShowMultipleDeleteDialog] = useState(false);
    const [deleteMode, setDeleteMode] = useState<{
        type: 'module' | 'submodule' | 'topic' | 'subtopic' | null;
        selectedItems: Set<string>;
    }>({
        type: null,
        selectedItems: new Set()
    });
    // Add to your state declarations
    const [hierarchicalDeleteMode, setHierarchicalDeleteMode] = useState<{
        parentType: 'module' | 'submodule' | 'topic';
        parentId: string;
        childType: 'submodule' | 'topic' | 'subtopic';
    } | null>(null);
    const [showDeleteConfirmation, setShowDeleteConfirmation] = useState(false);
    const showError = (message: string) => {
        setErrorMessage(message);
        setShowErrorDialog(true);
    };
    const [selectedDuplicateOptions, setSelectedDuplicateOptions] = useState<{
        hierarchy: ('Module' | 'SubModule' | 'Topic' | 'SubTopic')[];
    }>({
        hierarchy: [],
    });
    const [duplicateSelectionMode, setDuplicateSelectionMode] = useState<'all' | 'hierarchy'>('hierarchy');
    const duplicateCourseHierarchyMutation = useMutation({
        ...pedagogyViewApi.duplicateCourseHierarchy(),
        onSuccess: (data) => {
            console.log('Duplicate success:', data);
            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 3000);

            // Refresh data
            queryClient.invalidateQueries({ queryKey: ['modules'] });
            queryClient.invalidateQueries({ queryKey: ['subModules'] });
            queryClient.invalidateQueries({ queryKey: ['topics'] });
            queryClient.invalidateQueries({ queryKey: ['subTopics'] });
            queryClient.invalidateQueries({ queryKey: ['pedagogyViews'] });
            queryClient.invalidateQueries({ queryKey: ['levelViews'] });

            // Close popup and reset states
            setShowDuplicatePopup(false);
            setSelectedDuplicateCourse(null);
            setDuplicateChecked(false);
            setIsOpen(false);
            setSelectedDuplicateOptions({ hierarchy: [] });
        },
        onError: (error) => {
            console.error('Failed to duplicate course hierarchy:', error);
            showError("Failed to duplicate course structure");
            setDuplicateChecked(false);
            setIsOpen(false);
        }
    });
    const [selectedModuleToHighlight, setSelectedModuleToHighlight] = useState<string | null>(null);
    const [moduleSearchQuery, setModuleSearchQuery] = useState("");
    // Add these queries after your existing queries
    const {
        data: duplicateModules = [],
        isLoading: isDuplicateModulesLoading,
    } = useQuery({
        ...moduleApi.getAll(),
        enabled: !!selectedDuplicateCourse,
        select: (data) => {
            if (!selectedDuplicateCourse) return [];
            return data.filter(module => module.courses.includes(selectedDuplicateCourse._id));
        }
    });

    const {
        data: duplicateSubModules = [],
        isLoading: isDuplicateSubModulesLoading,
    } = useQuery({
        ...subModuleApi.getAll(),
        enabled: !!selectedDuplicateCourse,
        select: (data) => {
            if (!selectedDuplicateCourse) return [];
            return data.filter(subModule => subModule.courses.includes(selectedDuplicateCourse._id));
        }
    });

    const {
        data: duplicateTopics = [],
        isLoading: isDuplicateTopicsLoading,
    } = useQuery({
        ...topicApi.getAll(),
        enabled: !!selectedDuplicateCourse,
        select: (data) => {
            if (!selectedDuplicateCourse) return [];
            return data.filter(topic => topic.courses.includes(selectedDuplicateCourse._id));
        }
    });

    const {
        data: duplicateSubTopics = [],
        isLoading: isDuplicateSubTopicsLoading,
    } = useQuery({
        ...subTopicApi.getAll(),
        enabled: !!selectedDuplicateCourse,
        select: (data) => {
            if (!selectedDuplicateCourse) return [];
            return data.filter(subTopic => subTopic.courses === selectedDuplicateCourse._id);
        }
    });
    const [selectedLevelModulesForMerge, setSelectedLevelModulesForMerge] = useState<Set<string>>(new Set());
    const [selectedLevelSubModulesForMerge, setSelectedLevelSubModulesForMerge] = useState<Set<string>>(new Set());
    const [selectedLevelTopicsForMerge, setSelectedLevelTopicsForMerge] = useState<Set<string>>(new Set());
    const [selectedLevelSubTopicsForMerge, setSelectedLevelSubTopicsForMerge] = useState<Set<string>>(new Set());

    const [savedLevelMergeSelections, setSavedLevelMergeSelections] = useState<{
        modules: string[] | any[];
        subModules: string[] | any[];
        topics: string[] | any[];
        subTopics: string[] | any[];
    } | null>(null);

    const [savedPedagogyMergeSelections, setSavedPedagogyMergeSelections] = useState<{
        iDo: { [activity: string]: { modules: string[]; subModules: string[]; topics: string[]; subTopics: string[] } };
        weDo: { [activity: string]: { modules: string[]; subModules: string[]; topics: string[]; subTopics: string[] } };
        youDo: { [activity: string]: { modules: string[]; subModules: string[]; topics: string[]; subTopics: string[] } };
    }>({
        iDo: {},
        weDo: {},
        youDo: {}
    });

    const [selectedPedagogyModulesForMerge, setSelectedPedagogyModulesForMerge] = useState<{
        [activityType: string]: { [activity: string]: Set<string> };
    }>({});

    const [selectedPedagogySubModulesForMerge, setSelectedPedagogySubModulesForMerge] = useState<{
        [activityType: string]: { [activity: string]: Set<string> };
    }>({});

    const [selectedPedagogyTopicsForMerge, setSelectedPedagogyTopicsForMerge] = useState<{
        [activityType: string]: { [activity: string]: Set<string> };
    }>({});

    const [selectedPedagogySubTopicsForMerge, setSelectedPedagogySubTopicsForMerge] = useState<{
        [activityType: string]: { [activity: string]: Set<string> };
    }>({});

    const [showMergePedagogySection, setShowMergePedagogySection] = useState<{
        iDo: boolean;
        weDo: boolean;
        youDo: boolean;
    }>({ iDo: false, weDo: false, youDo: false });
    // Add to your existing state declarations
    const [enableModuleSelection, setEnableModuleSelection] = useState(false);
    const [selectedModulesForDuplication, setSelectedModulesForDuplication] = useState<Set<string>>(new Set());
    // Add current activity type being edited for merge
    const [currentMergeActivity, setCurrentMergeActivity] = useState<string>('');
    const [disableAddonlyMode, setDisableAddonlyMode] = useState(false);
    const [selectedCategory, setSelectedCategory] = useState<string>('all');
    const [showCoursePreview, setShowCoursePreview] = useState(false);
    const [previewCourse, setPreviewCourse] = useState<Course | null>(null);
    const [showDuplicateConfirmation, setShowDuplicateConfirmation] = useState(false);
    // Add these functions to clear merge selections
    const clearLevelMergeSelections = () => {
        setSavedLevelMergeSelections(null);
        setSelectedLevel('');
        setSelectedLevelModulesForMerge(new Set());
        setSelectedLevelSubModulesForMerge(new Set());
        setSelectedLevelTopicsForMerge(new Set());
        setSelectedLevelSubTopicsForMerge(new Set());
        setShowMergeLevelSection(false);
    };

    const clearPedagogyMergeSelections = (activityType?: "iDo" | "weDo" | "youDo", activity?: string) => {
        if (activityType && activity) {
            // Clear specific activity merge
            setSavedPedagogyMergeSelections(prev => ({
                ...prev,
                [activityType]: {
                    ...prev[activityType],
                    [activity]: undefined
                }
            }));

            setSelectedPedagogyModulesForMerge(prev => ({
                ...prev,
                [activityType]: {
                    ...prev[activityType],
                    [activity]: new Set()
                }
            }));

            setSelectedPedagogySubModulesForMerge(prev => ({
                ...prev,
                [activityType]: {
                    ...prev[activityType],
                    [activity]: new Set()
                }
            }));

            setSelectedPedagogyTopicsForMerge(prev => ({
                ...prev,
                [activityType]: {
                    ...prev[activityType],
                    [activity]: new Set()
                }
            }));

            setSelectedPedagogySubTopicsForMerge(prev => ({
                ...prev,
                [activityType]: {
                    ...prev[activityType],
                    [activity]: new Set()
                }
            }));

            setShowMergePedagogySection(prev => ({
                ...prev,
                [activityType]: false
            }));
        } else {
            // Clear all pedagogy merges
            setSavedPedagogyMergeSelections({ iDo: {}, weDo: {}, youDo: {} });
            setSelectedPedagogyModulesForMerge({});
            setSelectedPedagogySubModulesForMerge({});
            setSelectedPedagogyTopicsForMerge({});
            setSelectedPedagogySubTopicsForMerge({});
            setShowMergePedagogySection({ iDo: false, weDo: false, youDo: false });
        }

        setSelectedPedagogyActivities({
            iDo: [],
            weDo: [],
            youDo: []
        });
        // setPedagogyHours({
        //     iDo: {},
        //     weDo: {},
        //     youDo: {}
        // });
    };

    const [showPedagogyDialog, setShowPedagogyDialog] = useState(false);
    const [pedagogyFormData, setPedagogyFormData] = useState<{
        moduleId: string;
        topicId: string;
        subtopicId: string;
        subModuleId?: string;
        type: "iDo" | "weDo" | "youDo";
        activity: string;
        value: string;
        isEditing: boolean;
    } | null>(null);
    const [isNewLevel, setIsNewLevel] = useState(false);
    const [tableZoomLevel, setTableZoomLevel] = useState(.8)
    const [isMoveModeActive, setIsMoveModeActive] = useState(false);
    const [editingLevel, setEditingLevel] = useState<{
        id?: string | null;
        level: string;
        hierarchy: {
            module?: string[];
            subModule?: string[];
            topic?: string[];
            subTopic?: string[];
        };
    } | null>(null);
    const [showLevelDialog, setShowLevelDialog] = useState(false);
    const { data: pedagogyViews, isLoading: isPedagogyLoading } = useQuery({
        ...pedagogyViewApi.getAll(),
        queryKey: ['pedagogyViews', selectedCourse?._id, modules.length],
        select: (data) => {
            if (!selectedCourse) return [];
            return data.filter(view => view.courses === selectedCourse._id);
        },
        enabled: !!token && !!selectedCourse && modules.length > 0,
    });
    const { data: levelViews } = useQuery(levelViewApi.getAll());
    // Get the course-specific level view
    const courseLevelView = useMemo(() => {
        if (!selectedCourse || !levelViews) return null;
        return levelViews.find((view: { courses: string; }) => view.courses === selectedCourse._id);
    }, [selectedCourse, levelViews]);
    const levelViewId = courseLevelView?._id || null;
    const levelsData = courseLevelView?.levels || [];
    const levelViewMutation = useMutation({
        mutationFn: (data: {
            courses: string;
            levels: Array<{
                module?: string[];
                subModule?: string[];
                topic?: string[];
                subTopic?: string[];
                level: string;
            }>;
        }) => {
            if (levelViewId) {
                return levelViewApi.update(levelViewId).mutationFn(data);
            } else {
                return levelViewApi.create().mutationFn(data);
            }
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['levelViews'] });
            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 2000);
        }
    });
    // Delete level mutation
    const deleteLevelMutation = useMutation({
        mutationFn: (levelId: string) =>
            levelViewApi.delete(levelId).mutationFn(),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['levelViews'] });
            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 2000);
        }
    });

    // Add these sorting utility functions
    const sortByIndex = (a: { index?: number }, b: { index?: number }) => {
        const aIndex = a.index ?? 0;
        const bIndex = b.index ?? 0;
        return aIndex - bIndex;
    };

    // Memoized sorted arrays to prevent unnecessary re-renders
    const sortedModules = useMemo(() => [...modules].sort(sortByIndex), [modules]);
    const sortedSubModules = useMemo(() => [...subModules].sort(sortByIndex), [subModules]);
    const sortedTopics = useMemo(() => [...topics].sort(sortByIndex), [topics]);
    const sortedSubTopics = useMemo(() => [...subTopics].sort(sortByIndex), [subTopics]);

    useEffect(() => {
        if (selected && courses.length > 0) {
            const course = courses.find((c: { _id: string; }) => c._id === selected);
            if (course) {
                setSelectedCourse(course);
                setCourseHours({});
                setMergedCells({});

            }
        }
    }, [selected, courses]);
    // Reset control states when shouldDisableControls changes
    useEffect(() => {
        if (shouldDisableControls) {
            setActionsEnabled(false);
            setDirectActionsEnabled(false);
            setSelectedPedagogyTypes([]);
        }
    }, [shouldDisableControls]);
    useEffect(() => {
        if (courses.length > 0 && !selectedCourse) {
            const searchParams = new URLSearchParams(window.location.search);
            const courseId = searchParams.get('courseId');
            if (courseId) {
                const course = courses.find((c: { _id: string }) => c._id === courseId);
                if (course) {
                    setSelected(courseId);
                    setSelectedCourse(course);
                }
            }
        }
    }, [courses, selectedCourse]);

    useEffect(() => {
        if (!selectedCourse || !token) return;

        // Fetch all course-related data
        const fetchCourseData = async () => {
            try {
                // Fetch modules
                await fetchModulesForCourse();


            } catch (error) {
                console.error("Failed to fetch course data:", error);
            }
        };

        fetchCourseData();
    }, [selectedCourse, token]);

    useEffect(() => {
        // Course structure and pedagogy processing
        if (modules.length > 0 && selectedCourse) {
            const newStructure = modules.map(module => ({
                id: module._id,
                name: module.title,
                topics: [{
                    id: `${module._id}-default-topic`,
                    name: "Default Topic",
                    subtopics: subModules
                        .filter(sub => sub.moduleId === module._id)
                        .map(sub => ({
                            id: sub._id,
                            name: sub.title,
                            topics: topics
                                .filter(topic => topic.subModuleId === sub._id)
                                .map(topic => ({
                                    id: topic._id,
                                    name: topic.title
                                }))
                        }))
                }]
            }));

            setCourseStructure(newStructure as any);

            // Initialize or process pedagogy data
            if ((pedagogyViews?.length ?? 0) > 0) {
                const { newCourseHours, newMergedCells } = processPedagogyData(pedagogyViews as any);
                setCourseHours(newCourseHours);
                setMergedCells(newMergedCells);
            } else {
                setCourseHours(prev => Object.keys(prev).length === 0 ? initializeCourseHours(modules as any) : prev);
            }
        } else {
            setCourseStructure([]);
            setCourseHours({});
        }
    }, [selectedCourse, pedagogyViews]);

    useEffect(() => {
        // When pedagogyViews data changes, reprocess the pedagogy data
        if (pedagogyViews && modules.length > 0 && selectedCourse) {
            const { newCourseHours, newMergedCells } = processPedagogyData(pedagogyViews);
            setCourseHours(newCourseHours);
            setMergedCells(newMergedCells);
        }
    }, [pedagogyViews, modules, selectedCourse]);

    useEffect(() => {
        const storedToken = localStorage.getItem('smartcliff_token')
        setToken(storedToken)
    }, [])

    useEffect(() => {
        setExportSelections((prev: any) => ({
            ...prev,
            pedagogy: {
                iDo: selectedPedagogyTypes.includes("iDo") ? activityTypes["iDo"] : [],
                weDo: selectedPedagogyTypes.includes("weDo") ? activityTypes["weDo"] : [],
                youDo: selectedPedagogyTypes.includes("youDo") ? activityTypes["youDo"] : [],
            }
        }));
    }, [selectedPedagogyTypes]);
    useEffect(() => {
        const isOpen = showMergeLevelSection ||
            showMergePedagogySection.iDo ||
            showMergePedagogySection.weDo ||
            showMergePedagogySection.youDo;
        setIsMergeSectionOpen(isOpen);
    }, [showMergeLevelSection, showMergePedagogySection.iDo, showMergePedagogySection.weDo, showMergePedagogySection.youDo]);
    useEffect(() => {
        if (!actionsEnabled || directActionsEnabled) {
            setMovableCell(null);
            cancelSelection();
        }
    }, [actionsEnabled, directActionsEnabled]);

    const cancelSelection = () => {
        setSelectedMergeCells(new Set());
        setMergeSelectionMode(null);
        setIsSelectingCells(false);

    };
    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (isMoveModeActive && movableCell) {
                // Check if click is outside any draggable cell
                const target = event.target as HTMLElement;
                const isDraggableCell = target.closest('[draggable="true"]');

                if (!isDraggableCell) {
                    setMovableCell(null);
                    setIsMoveModeActive(false);
                }
            }
        };

        if (isMoveModeActive) {
            document.addEventListener('mousedown', handleClickOutside);
        }

        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [isMoveModeActive, movableCell]);
    useEffect(() => {
        // When pedagogyViews data OR savedPedagogyMergeSelections change, reprocess the pedagogy data
        if ((pedagogyViews || Object.keys(savedPedagogyMergeSelections).length > 0) && modules.length > 0 && selectedCourse) {
            const { newCourseHours, newMergedCells } = processPedagogyData(pedagogyViews || []);
            setCourseHours(newCourseHours);
            setMergedCells(newMergedCells);
        }
    }, [pedagogyViews, savedPedagogyMergeSelections]);
    useEffect(() => {
        if (selectedDuplicateOptions.hierarchy.length === 0) {
            setEnableModuleSelection(false);
        }
    }, [selectedDuplicateOptions]);
    const activityTypes = {
        "iDo": selectedCourse?.I_Do || [],
        "weDo": selectedCourse?.We_Do || [],
        "youDo": selectedCourse?.You_Do || [],
        "all": [...(selectedCourse?.I_Do || []), ...(selectedCourse?.We_Do || []), ...(selectedCourse?.You_Do || [])]
    }
    const [exportSelections, setExportSelections] = useState<ExportSelections | any>({
        printPedagogy: null,
        hierarchy: {
            module: true,
            subModule: true,
            topic: true,
            subTopic: true,
            level: true,
        },
        pedagogy: {
            iDo: selectedPedagogyTypes.includes("iDo") ? activityTypes["iDo"] : [],
            weDo: selectedPedagogyTypes.includes("weDo") ? activityTypes["weDo"] : [],
            youDo: selectedPedagogyTypes.includes("youDo") ? activityTypes["youDo"] : [],
        },
        showSummary: false,
    });

    // Add this function to filter courses based on selection mode
    const getAvailableDuplicateCourses = () => {
        if (!selectedCourse) return [];

        let filteredCourses = courses.filter((course: Course) => course._id !== selectedCourse._id);

        // Apply category filter
        if (selectedCategory !== 'all') {
            filteredCourses = filteredCourses.filter((course: Course) =>
                course.category === selectedCategory
            );
        }

        if (duplicateSelectionMode === 'all') {
            return filteredCourses;
        } else {
            // Hierarchy-based filtering (original logic)
            return filteredCourses.filter((course: Course) =>
                course.courseHierarchy.join(',') === selectedCourse.courseHierarchy.join(',')
            );
        }
    };
    const getAvailableCategories = () => {
        const categories = new Set<string>();
        categories.add('all'); // Add "all" option

        courses.forEach((course: Course) => {
            if (course.category && course._id !== selectedCourse?._id) {
                categories.add(course.category);
            }
        });

        return Array.from(categories);
    };
    // Function to get common consecutive hierarchy levels between two courses
    const getCommonHierarchyLevels = (currentCourse: any, selectedCourse: any) => {
        const currentHierarchy = currentCourse.courseHierarchy.map((level: string) =>
            level === 'Sub Module' ? 'SubModule' : level === 'Sub Topic' ? 'SubTopic' : level
        );

        const selectedHierarchy = selectedCourse.courseHierarchy.map((level: string) =>
            level === 'Sub Module' ? 'SubModule' : level === 'Sub Topic' ? 'SubTopic' : level
        );

        const commonLevels = [];

        // Check for consecutive common levels starting from the first level
        for (let i = 0; i < Math.min(currentHierarchy.length, selectedHierarchy.length); i++) {
            if (currentHierarchy[i] === selectedHierarchy[i]) {
                commonLevels.push(currentHierarchy[i]);
            } else {
                // Stop at first mismatch - hierarchies must be consecutive
                break;
            }
        }

        return commonLevels;
    };
    // Function to handle duplication confirmation
    const handleDuplicateConfirm = async () => {
        if (!selectedDuplicateCourse || !selectedCourse) return;

        // Get institution ID from localStorage
        const institutionId = localStorage.getItem('smartcliff_institution');
        const createdBy = localStorage.getItem('smartcliff_userId'); // or however you store user ID

        // Combine hierarchy and views selections
        const duplicateItems = [
            ...selectedDuplicateOptions.hierarchy
        ];

        if (duplicateItems.length === 0) {
            showError("Please select at least one item to duplicate");
            return;
        }
        const selectedModuleIds = enableModuleSelection && selectedModulesForDuplication.size > 0
            ? Array.from(selectedModulesForDuplication)
            : undefined;
        try {
            await duplicateCourseHierarchyMutation.mutateAsync({
                duplicateCourseId: selectedDuplicateCourse._id,
                newCourseId: selectedCourse._id,
                institutionId: institutionId || undefined,
                createdBy: createdBy || undefined,
                duplicate: duplicateItems,
                selectedModules: selectedModuleIds
            });
            setDuplicateSelectionMode('hierarchy');
            setEnableModuleSelection(false);
            setSelectedModulesForDuplication(new Set());
        } catch (error) {
            setErrorMessage(`error: ${error}`)
        }
    };
    const ModuleSelectionToggle = () => {
        const isToggleDisabled = selectedDuplicateOptions.hierarchy.length === 0;

        return (
            <div className={`flex items-center justify-between p-3 sm:p-2 border rounded-xl shadow-sm transition-all duration-300 ${isToggleDisabled
                ? "bg-gray-100 border-gray-300 cursor-not-allowed"
                : "bg-gradient-to-r from-indigo-50 via-white to-pink-50 border-gray-200 hover:shadow-md"
                }`}>

                {/* Left Icon + Text */}
                <div className="flex items-center gap-3">
                    <div
                        className={`w-8 h-8 rounded-full flex items-center justify-center transition-all duration-300 shadow-sm ${enableModuleSelection
                            ? "bg-gradient-to-r from-green-400 to-emerald-500 text-white"
                            : isToggleDisabled
                                ? "bg-gray-300 text-gray-400"
                                : "bg-gray-200 text-gray-500"
                            }`}
                    >
                        <CheckSquare className="w-4 h-4" />
                    </div>
                    <div className="leading-tight">
                        <label
                            htmlFor="module-selection"
                            className={`text-sm font-semibold ${isToggleDisabled ? "text-gray-500 cursor-not-allowed" : "text-gray-800 cursor-pointer"
                                }`}
                        >
                            Select module rows to duplicate
                        </label>
                        <p className={`text-xs ${isToggleDisabled ? "text-gray-400" : "text-gray-500"
                            }`}>
                            {isToggleDisabled
                                ? "Select hierarchy levels first to enable module selection"
                                : "Toggle to choose specific hierarchy rows"
                            }
                        </p>
                    </div>
                </div>

                {/* Compact Gradient Toggle */}
                <button
                    type="button"
                    disabled={isToggleDisabled}
                    className={`relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-all duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2 ${isToggleDisabled
                        ? "bg-gray-300 cursor-not-allowed"
                        : enableModuleSelection
                            ? "bg-gradient-to-r from-green-400 to-emerald-500 focus:ring-green-400"
                            : "bg-gray-300 focus:ring-indigo-400"
                        }`}
                    role="switch"
                    aria-checked={enableModuleSelection}
                    aria-disabled={isToggleDisabled}
                    onClick={() => {
                        if (!isToggleDisabled) {
                            const newValue = !enableModuleSelection;
                            setEnableModuleSelection(newValue);
                            if (!newValue) {
                                setSelectedModulesForDuplication(new Set()); // Clear selection
                            }
                        }
                    }}
                >
                    <span
                        aria-hidden="true"
                        className={`pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow-md ring-0 transition duration-300 ease-in-out ${enableModuleSelection ? "translate-x-5" : "translate-x-0"
                            } ${isToggleDisabled ? "opacity-60" : ""}`}
                    />
                </button>
            </div>
        );
    };

    const SearchableCourseSelect = ({
        courses,
        selectedCourse,
        onCourseSelect,
        placeholder = "Search courses..."
    }: {
        courses: Course[];
        selectedCourse: Course | null;
        onCourseSelect: (course: Course | null) => void;
        placeholder?: string;
    }) => {
        const [searchQuery, setSearchQuery] = useState("");
        const [isOpen, setIsOpen] = useState(false);

        // Filter courses based on search query
        const filteredCourses = useMemo(() => {
            if (!searchQuery.trim()) return courses;

            const query = searchQuery.toLowerCase();
            return courses.filter(course =>
                course.courseName.toLowerCase().includes(query) ||
                (course.category && course.category.toLowerCase().includes(query)) ||
                course.courseHierarchy.some(level => level.toLowerCase().includes(query))
            );
        }, [courses, searchQuery]);

        const handleCourseSelect = (course: Course) => {
            onCourseSelect(course);
            setIsOpen(false);
            setSearchQuery("");
        };

        const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
            setSearchQuery(e.target.value);
            if (!isOpen) setIsOpen(true);
        };

        const handleInputFocus = () => {
            setIsOpen(true);
        };

        const handleInputKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
            if (e.key === 'Escape') {
                setIsOpen(false);
            }
            if (e.key === 'Enter' && filteredCourses.length > 0) {
                handleCourseSelect(filteredCourses[0]);
            }
        };

        return (
            <div className="relative flex-1">
                {/* Input Field */}
                <div className="relative">
                    <input
                        type="text"
                        value={isOpen ? searchQuery : (selectedCourse?.courseName || "")}
                        onChange={handleInputChange}
                        onFocus={handleInputFocus}
                        onKeyDown={handleInputKeyDown}
                        placeholder={placeholder}
                        className="w-full h-9 px-3 py-2 bg-gray-50 border text-xs border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500/20 focus:border-blue-500 transition-colors"
                    />
                    <div className="absolute right-2 top-1/2 transform -translate-y-1/2 flex items-center gap-1">
                        {searchQuery && (
                            <button
                                type="button"
                                onClick={() => setSearchQuery("")}
                                className="p-1 hover:bg-gray-200 rounded cursor-pointer transition-colors"
                            >
                                <X className="w-3 h-3 text-gray-500" />
                            </button>
                        )}
                        <ChevronDownIcon className="w-4 h-4 text-gray-400" />
                    </div>
                </div>

                {/* Dropdown Menu */}
                {isOpen && (
                    <>
                        <div
                            className="fixed inset-0 z-40"
                            onClick={() => setIsOpen(false)}
                        />
                        <div className="absolute z-50 w-full mt-1 bg-white border border-gray-200 rounded-md shadow-lg max-h-60 overflow-auto">
                            {filteredCourses.length === 0 ? (
                                <div className="px-3 py-2 text-sm text-gray-500">
                                    No courses found matching "{searchQuery}"
                                </div>
                            ) : (
                                <div className="py-1">
                                    {filteredCourses.map((course) => (
                                        <div
                                            key={course._id}
                                            onClick={() => handleCourseSelect(course)}
                                            className={`px-3 py-2 text-sm cursor-pointer transition-colors hover:bg-blue-50 ${selectedCourse?._id === course._id ? 'bg-blue-100' : ''
                                                }`}
                                        >
                                            <div className="font-medium text-xs text-gray-900">
                                                {course.courseName}
                                            </div>
                                            <div className="flex justify-between text-xs text-gray-500 mt-1">
                                                <span>Hierarchy: {course.courseHierarchy.join(' → ')}</span>
                                                {course.category && (
                                                    <span className="bg-gray-100 px-1.5 text-[10px] rounded">
                                                        {course.category}
                                                    </span>
                                                )}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            )}
                        </div>
                    </>
                )}
            </div>
        );
    };

    const getHierarchyOrder = () => {
        const hierarchyMap: any = {
            'Module': 0,
            'SubModule': 1,
            'Topic': 2,
            'SubTopic': 3
        };

        return selectedCourse?.courseHierarchy
            .map(level => level === 'Sub Module' ? 'SubModule' :
                level === 'Sub Topic' ? 'SubTopic' : level)
            .sort((a, b) => (hierarchyMap[a] || 0) - (hierarchyMap[b] || 0)) || [];
    };

    // Add this helper function to check if a hierarchy level should be enabled
    const isHierarchyLevelEnabled = (level: string) => {
        if (!selectedDuplicateCourse) return false;

        const commonLevels = getCommonHierarchyLevels(selectedCourse, selectedDuplicateCourse);
        const currentIndex = commonLevels.indexOf(level);

        // First level is always enabled
        if (currentIndex === 0) return true;

        // Check if all previous levels are selected
        for (let i = 0; i < currentIndex; i++) {
            if (!selectedDuplicateOptions.hierarchy.includes(commonLevels[i])) {
                return false;
            }
        }

        return true;
    };

    // 2. Replace your existing handleSelectAllHierarchy function with this:
    const handleSelectAllHierarchy = (checked: boolean) => {
        if (checked && selectedDuplicateCourse) {
            const commonLevels = getCommonHierarchyLevels(selectedCourse, selectedDuplicateCourse);
            setSelectedDuplicateOptions(prev => ({
                ...prev,
                hierarchy: commonLevels
            }));
        } else {
            setSelectedDuplicateOptions(prev => ({
                ...prev,
                hierarchy: []
            }));
        }
    };

    // 3. Add this new function to handle hierarchical checkbox changes
    const handleHierarchyCheckboxChange = (checkboxValue: any, checked: string | boolean) => {
        const hierarchyOrder = getHierarchyOrder();
        const currentIndex = hierarchyOrder.indexOf(checkboxValue);

        if (checked) {
            // When selecting, just add the current item
            setSelectedDuplicateOptions(prev => ({
                ...prev,
                hierarchy: [...prev.hierarchy, checkboxValue]
            }));
        } else {
            // When deselecting, remove this item and all items that come after it in hierarchy
            const itemsToRemove = hierarchyOrder.slice(currentIndex);
            setSelectedDuplicateOptions(prev => ({
                ...prev,
                hierarchy: prev.hierarchy.filter(item => !itemsToRemove.includes(item))
            }));
        }
    };

    const fetchModulesForCourse = async () => {
        if (!selectedCourse) return;
        // React Query will handle the caching and refetching automatically
        await refetchModules();
    };
    const initializeCourseHours = (modules: Modules[]) => {
        const initialHours: CourseHours = {};
        const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];
        const hasSubModules = hierarchyLevels.includes('sub module');

        modules.forEach((module) => {
            initialHours[module.id] = initialHours[module.id] || {};

            // Find all submodules for this module
            const moduleSubModules = hasSubModules
                ? subModules.filter(sub => sub.moduleId === module.id)
                : [];

            if (hasSubModules && moduleSubModules.length > 0) {
                // Use actual submodules
                moduleSubModules.forEach((subModule) => {
                    const topicId = `${module.id}-default-topic`;
                    const subtopicId = subModule._id;

                    initialHours[module.id][topicId] = initialHours[module.id][topicId] || {};
                    initialHours[module.id][topicId][subtopicId] = {
                        "iDo": {
                            Lecture: 0,
                            Demonstration: 0,
                            "Video Tutorial": 0,
                            "Live Coding": 0,
                            Presentation: 0,
                            ...(selectedCourse?.I_Do?.reduce((acc, activity) => {
                                acc[activity] = 0;
                                return acc;
                            }, {} as Record<string, number>) || {})
                        },
                        "weDo": {
                            "Interactive Session": 0,
                            "Guided Workshop": 0,
                            "Group Discussion": 0,
                            "Collaborative Coding": 0,
                            "Q&A Session": 0,
                            ...(selectedCourse?.We_Do?.reduce((acc, activity) => {
                                acc[activity] = 0;
                                return acc;
                            }, {} as Record<string, number>) || {})
                        },
                        "youDo": {
                            Assignment: 0,
                            Quiz: 0,
                            Project: 0,
                            Assessment: 0,
                            "Practice Exercise": 0,
                            "Lab Work": 0,
                            ...(selectedCourse?.You_Do?.reduce((acc, activity) => {
                                acc[activity] = 0;
                                return acc;
                            }, {} as Record<string, number>) || {})
                        }
                    };
                });
            } else {
                // Fallback to default subtopic
                const topicId = `${module.id}-default-topic`;
                const subtopicId = `${module.id}-default-subtopic`;

                initialHours[module.id][topicId] = initialHours[module.id][topicId] || {};
                initialHours[module.id][topicId][subtopicId] = {
                    "iDo": {
                        Lecture: 0,
                        Demonstration: 0,
                        "Video Tutorial": 0,
                        "Live Coding": 0,
                        Presentation: 0,
                        ...(selectedCourse?.I_Do?.reduce((acc, activity) => {
                            acc[activity] = 0;
                            return acc;
                        }, {} as Record<string, number>) || {})
                    },
                    "weDo": {
                        "Interactive Session": 0,
                        "Guided Workshop": 0,
                        "Group Discussion": 0,
                        "Collaborative Coding": 0,
                        "Q&A Session": 0,
                        ...(selectedCourse?.We_Do?.reduce((acc, activity) => {
                            acc[activity] = 0;
                            return acc;
                        }, {} as Record<string, number>) || {})
                    },
                    "youDo": {
                        Assignment: 0,
                        Quiz: 0,
                        Project: 0,
                        Assessment: 0,
                        "Practice Exercise": 0,
                        "Lab Work": 0,
                        ...(selectedCourse?.You_Do?.reduce((acc, activity) => {
                            acc[activity] = 0;
                            return acc;
                        }, {} as Record<string, number>) || {})
                    }
                };
            }
        });

        return initialHours;
    };
    const [courseHours, setCourseHours] = useState<CourseHours>(initializeCourseHours([]));

    const createDuplicateTableRows = (): any[] => {
        const rows: any[] = [];
        let rowIndex = 0;

        // Ensure we have modules before proceeding
        if (!duplicateModules.length || !selectedDuplicateCourse) return rows;

        // Get the hierarchy levels that exist in the course
        const hierarchyLevels = selectedDuplicateCourse.courseHierarchy.map(level => level.toLowerCase());
        const hasSubModules = hierarchyLevels.includes('sub module');
        const hasTopics = hierarchyLevels.includes('topic');
        const hasSubTopics = hierarchyLevels.includes('sub topic');

        const sortedModules = [...duplicateModules].sort((a, b) => (a.index || 0) - (b.index || 0));

        sortedModules.forEach((module) => {
            if (hasSubModules) {
                const moduleSubModules = duplicateSubModules.filter(sub => sub.moduleId === module._id)
                    .sort((a, b) => (a.index || 0) - (b.index || 0));

                if (moduleSubModules.length > 0) {
                    moduleSubModules.forEach((subModule) => {
                        const subModuleTopics = duplicateTopics.filter(topic => topic.subModuleId === subModule._id)
                            .sort((a, b) => (a.index || 0) - (b.index || 0));

                        if (subModuleTopics.length > 0) {
                            subModuleTopics.forEach(topic => {
                                const topicSubTopics = duplicateSubTopics.filter(subTopic => subTopic.topicId === topic._id)
                                    .sort((a, b) => (a.index || 0) - (b.index || 0));

                                if (topicSubTopics.length > 0) {
                                    topicSubTopics.forEach(subTopic => {
                                        rows.push({
                                            moduleId: module._id,
                                            moduleName: module.title,
                                            subModuleId: subModule._id,
                                            subModuleName: subModule.title,
                                            topicId: topic._id,
                                            topicName: topic.title,
                                            subtopicId: subTopic._id,
                                            subtopicName: subTopic.title,
                                            rowIndex: rowIndex++,
                                            rowId: `${module._id}-${subModule._id}-${topic._id}-${subTopic._id}`,
                                        });
                                    });
                                } else {
                                    // Topic exists but no subtopics (or subtopics not in hierarchy)
                                    rows.push({
                                        moduleId: module._id,
                                        moduleName: module.title,
                                        subModuleId: subModule._id,
                                        subModuleName: subModule.title,
                                        topicId: topic._id,
                                        topicName: topic.title,
                                        subtopicId: `${topic._id}-placeholder`,
                                        subtopicName: "-",
                                        rowIndex: rowIndex++,
                                        rowId: `${module._id}-${subModule._id}-${topic._id}-placeholder`,
                                    });
                                }
                            });
                        } else {
                            // Submodule exists but no topics (or topics not in hierarchy)
                            rows.push({
                                moduleId: module._id,
                                moduleName: module.title,
                                subModuleId: subModule._id,
                                subModuleName: subModule.title,
                                topicId: `${subModule._id}-placeholder`,
                                topicName: "-",
                                subtopicId: `${subModule._id}-placeholder-sub`,
                                subtopicName: "-",
                                rowIndex: rowIndex++,
                                rowId: `${module._id}-${subModule._id}-placeholder`,
                            });
                        }
                    });
                } else {
                    // Module exists but no submodules (but submodules are in hierarchy)
                    rows.push({
                        moduleId: module._id,
                        moduleName: module.title,
                        subModuleId: `${module._id}-placeholder`,
                        subModuleName: "-",
                        topicId: `${module._id}-placeholder-topic`,
                        topicName: "-",
                        subtopicId: `${module._id}-placeholder-sub`,
                        subtopicName: "-",
                        rowIndex: rowIndex++,
                        rowId: `${module._id}-placeholder`,
                    });
                }
            } else if (hasTopics) {
                const moduleTopics = duplicateTopics.filter(topic => topic.moduleId === module._id)
                    .sort((a, b) => (a.index || 0) - (b.index || 0));

                if (moduleTopics.length > 0) {
                    moduleTopics.forEach(topic => {
                        const topicSubTopics = duplicateSubTopics.filter(subTopic => subTopic.topicId === topic._id)
                            .sort((a, b) => (a.index || 0) - (b.index || 0));

                        if (topicSubTopics.length > 0) {
                            topicSubTopics.forEach(subTopic => {
                                rows.push({
                                    moduleId: module._id,
                                    moduleName: module.title,
                                    subModuleId: null,
                                    subModuleName: "",
                                    topicId: topic._id,
                                    topicName: topic.title,
                                    subtopicId: subTopic._id,
                                    subtopicName: subTopic.title,
                                    rowIndex: rowIndex++,
                                    rowId: `${module._id}-${topic._id}-${subTopic._id}`,
                                });
                            });
                        } else {
                            // Create row with topic but no subtopics
                            rows.push({
                                moduleId: module._id,
                                moduleName: module.title,
                                subModuleId: null,
                                subModuleName: "",
                                topicId: topic._id,
                                topicName: topic.title,
                                subtopicId: `${topic._id}-placeholder`,
                                subtopicName: "-",
                                rowIndex: rowIndex++,
                                rowId: `${module._id}-${topic._id}-placeholder`,
                            });
                        }
                    });
                } else {
                    // Create row with module but no topics
                    rows.push({
                        moduleId: module._id,
                        moduleName: module.title,
                        subModuleId: null,
                        subModuleName: "",
                        topicId: `${module._id}-placeholder`,
                        topicName: "-",
                        subtopicId: `${module._id}-placeholder-sub`,
                        subtopicName: "-",
                        rowIndex: rowIndex++,
                        rowId: `${module._id}-placeholder`,
                    });
                }
            } else {
                // Only module level exists
                rows.push({
                    moduleId: module._id,
                    moduleName: module.title,
                    subModuleId: null,
                    subModuleName: "",
                    topicId: null,
                    topicName: "",
                    subtopicId: `${module._id}-placeholder`,
                    subtopicName: "-",
                    rowIndex: rowIndex++,
                    rowId: `${module._id}-placeholder`,
                });
            }
        });

        return rows;
    };

    const getDuplicateSpans = () => {
        const moduleSpans: { [key: string]: number } = {};
        const subModuleSpans: { [key: string]: number } = {};
        const topicSpans: { [key: string]: number } = {};
        const subtopicSpans: { [key: string]: number } = {};

        const hasSubModules = selectedDuplicateCourse?.courseHierarchy.includes('Sub Module') || false;
        const hasTopics = selectedDuplicateCourse?.courseHierarchy.includes('Topic') || false;
        const hasSubTopics = selectedDuplicateCourse?.courseHierarchy.includes('Sub Topic') || false;

        duplicateModules.forEach((module) => {
            let moduleRowCount = 0;
            const moduleSubModules = duplicateSubModules.filter(sub => sub.moduleId === module._id);

            if (hasSubModules && moduleSubModules.length > 0) {
                moduleSubModules.forEach((subModule) => {
                    let subModuleRowCount = 0;
                    const subModuleTopics = duplicateTopics.filter(topic => topic.subModuleId === subModule._id);

                    if (hasTopics && subModuleTopics.length > 0) {
                        subModuleTopics.forEach(topic => {
                            const topicSubTopics = hasSubTopics
                                ? duplicateSubTopics.filter(subTopic => subTopic.topicId === topic._id)
                                : [];
                            const topicRowCount = hasSubTopics && topicSubTopics.length > 0
                                ? topicSubTopics.length
                                : 1;

                            if (hasSubTopics) {
                                subtopicSpans[topic._id] = topicRowCount;
                            }
                            topicSpans[topic._id] = topicRowCount;
                            subModuleRowCount += topicRowCount;
                        });
                    } else {
                        subModuleRowCount = 1;
                    }

                    subModuleSpans[subModule._id] = subModuleRowCount;
                    moduleRowCount += subModuleRowCount;
                });
            } else {
                // No submodules in hierarchy or no submodules exist
                const moduleTopics = duplicateTopics.filter(topic => topic.moduleId === module._id);

                if (hasTopics && moduleTopics.length > 0) {
                    moduleTopics.forEach(topic => {
                        const topicSubTopics = hasSubTopics
                            ? duplicateSubTopics.filter(subTopic => subTopic.topicId === topic._id)
                            : [];
                        const topicRowCount = hasSubTopics && topicSubTopics.length > 0
                            ? topicSubTopics.length
                            : 1;

                        if (hasSubTopics) {
                            subtopicSpans[topic._id] = topicRowCount;
                        }
                        topicSpans[topic._id] = topicRowCount;
                        moduleRowCount += topicRowCount;
                    });
                } else {
                    moduleRowCount = 1;
                }
            }

            moduleSpans[module._id] = moduleRowCount;
        });

        return {
            moduleSpans,
            subModuleSpans: hasSubModules ? subModuleSpans : {},
            topicSpans: hasTopics ? topicSpans : {},
            subtopicSpans: hasSubTopics ? subtopicSpans : {}
        };
    };

    const handleClosePopup = () => {
        setShowDuplicatePopup(false);
        setSelectedDuplicateCourse(null);
        setDuplicateChecked(false);
        setIsOpen(false);
        setSelectedDuplicateOptions({ hierarchy: [] });
        setEnableModuleSelection(false); // Reset module selection toggle
        setSelectedModulesForDuplication(new Set()); // Clear selected modules
        setDuplicateSelectionMode('hierarchy');
        setSelectedCategory('all');
        setShowCoursePreview(false); // Close preview popup if open
        setPreviewCourse(null);
        setShowDuplicateConfirmation(false);
        setEnableModuleSelection(false);
    };

    const processPedagogyData = (pedagogyViews: any[]) => {
        const newCourseHours: CourseHours = {};
        const newMergedCells: { [key: string]: MergedCell[] } = {};
        const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];

        // Initialize empty course hours structure first
        const initialHours = initializeCourseHours(modules as any);
        Object.keys(initialHours).forEach(moduleId => {
            newCourseHours[moduleId] = { ...initialHours[moduleId] };
        });

        pedagogyViews.forEach(view => {
            view.pedagogies.forEach((pedagogy: any) => {
                // Extract hierarchy IDs from pedagogy data
                const moduleIds = pedagogy.module || [];
                const subModuleIds = pedagogy.subModule || [];
                const topicIds = pedagogy.topic || [];
                const subTopicIds = pedagogy.subTopic || [];

                // Check if this is a merged cell (multiple IDs at any level)
                const isMultiMerge = moduleIds.length > 1 || subModuleIds.length > 1 ||
                    topicIds.length > 1 || subTopicIds.length > 1;

                if (isMultiMerge) {
                    // Handle merged cells with hierarchical matching
                    const rowIds = getAffectedRowIds(moduleIds, subModuleIds, topicIds, subTopicIds);

                    // Only create merge if we found matching rows
                    if (rowIds.length > 0) {
                        // Process I Do activities
                        pedagogy?.iDo?.forEach((activity: { type: string; duration: number }) => {
                            const columnKey = `iDo-${activity.type}`;
                            const mergedCell: MergedCell = {
                                startRow: -1,
                                endRow: -1,
                                value: activity.duration,
                                type: "iDo",
                                activity: activity.type,
                                rowIds,
                                hierarchyIds: {
                                    modules: moduleIds,
                                    subModules: subModuleIds,
                                    topics: topicIds,
                                    subTopics: subTopicIds
                                }
                            };
                            newMergedCells[columnKey] = [...(newMergedCells[columnKey] || []), mergedCell];
                        });

                        // Process We Do activities
                        pedagogy?.weDo?.forEach((activity: { type: string; duration: number }) => {
                            const columnKey = `weDo-${activity.type}`;
                            const mergedCell: MergedCell = {
                                startRow: -1,
                                endRow: -1,
                                value: activity.duration,
                                type: "weDo",
                                activity: activity.type,
                                rowIds,
                                hierarchyIds: {
                                    modules: moduleIds,
                                    subModules: subModuleIds,
                                    topics: topicIds,
                                    subTopics: subTopicIds
                                }
                            };
                            newMergedCells[columnKey] = [...(newMergedCells[columnKey] || []), mergedCell];
                        });

                        // Process You Do activities
                        pedagogy?.youDo?.forEach((activity: { type: string; duration: number }) => {
                            const columnKey = `youDo-${activity.type}`;
                            const mergedCell: MergedCell = {
                                startRow: -1,
                                endRow: -1,
                                value: activity.duration,
                                type: "youDo",
                                activity: activity.type,
                                rowIds,
                                hierarchyIds: {
                                    modules: moduleIds,
                                    subModules: subModuleIds,
                                    topics: topicIds,
                                    subTopics: subTopicIds
                                }
                            };
                            newMergedCells[columnKey] = [...(newMergedCells[columnKey] || []), mergedCell];
                        });
                    }
                } else {
                    // Handle single cell values - find the exact row that matches
                    const moduleId = moduleIds[0] || '';
                    const subModuleId = subModuleIds[0] || '';
                    const topicId = topicIds[0] || '';
                    const subtopicId = subTopicIds[0] || '';

                    if (!moduleId) return; // Skip if no module ID

                    // Find the exact row that matches all provided hierarchy IDs
                    const matchingRowIndex = tableRows.findIndex(row => {
                        const moduleMatch = row.moduleId === moduleId;
                        const subModuleMatch = !subModuleId || row.subModuleId === subModuleId;
                        const topicMatch = !topicId || row.topicId === topicId;
                        const subtopicMatch = !subtopicId || row.subtopicId === subtopicId;

                        return moduleMatch && subModuleMatch && topicMatch && subtopicMatch;
                    });

                    if (matchingRowIndex !== -1) {
                        const row = tableRows[matchingRowIndex];

                        // Use the actual IDs from the row, not the defaults
                        const effectiveTopicId = row.topicId || `${row.moduleId}-default-topic`;
                        const effectiveSubtopicId = row.subtopicId ||
                            (row.topicId ? `${row.topicId}-default-subtopic` : `${row.moduleId}-default-subtopic`);

                        // Initialize nested objects if they don't exist
                        if (!newCourseHours[row.moduleId]) newCourseHours[row.moduleId] = {};
                        if (!newCourseHours[row.moduleId][effectiveTopicId]) {
                            newCourseHours[row.moduleId][effectiveTopicId] = {};
                        }
                        if (!newCourseHours[row.moduleId][effectiveTopicId][effectiveSubtopicId]) {
                            newCourseHours[row.moduleId][effectiveTopicId][effectiveSubtopicId] = {
                                "iDo": {},
                                "weDo": {},
                                "youDo": {}
                            };
                        }

                        // Assign activity values
                        pedagogy.iDo?.forEach((activity: { type: string; duration: number }) => {
                            newCourseHours[row.moduleId][effectiveTopicId][effectiveSubtopicId]["iDo"][activity.type] = activity.duration;
                        });

                        pedagogy.weDo?.forEach((activity: { type: string; duration: number }) => {
                            newCourseHours[row.moduleId][effectiveTopicId][effectiveSubtopicId]["weDo"][activity.type] = activity.duration;
                        });

                        pedagogy.youDo?.forEach((activity: { type: string; duration: number }) => {
                            newCourseHours[row.moduleId][effectiveTopicId][effectiveSubtopicId]["youDo"][activity.type] = activity.duration;
                        });
                    }
                }
            });
        });

        // Update row indices in merged cells
        Object.keys(newMergedCells).forEach(columnKey => {
            newMergedCells[columnKey].forEach(merge => {
                const rowIndices = merge.rowIds.map(rid =>
                    tableRows.findIndex(row => row.rowId === rid))
                    .filter(idx => idx !== -1)
                    .sort((a, b) => a - b);

                if (rowIndices.length > 0) {
                    merge.startRow = rowIndices[0];
                    merge.endRow = rowIndices[rowIndices.length - 1];
                }
            });
        });

        return { newCourseHours, newMergedCells };
    };
    const getAffectedRowIds = (
        modules: string[],
        subModules: string[],
        topics: string[],
        subTopics: string[]
    ) => {
        const rowIds = new Set<string>();

        // For each row, check if it matches the hierarchical pattern
        tableRows.forEach(row => {
            let matches = false;

            // Check module level first
            if (modules.length > 0 && !modules.includes(row.moduleId)) {
                return; // Skip if module doesn't match
            }

            // Check submodule level with hierarchical logic
            if (subModules.length > 0) {
                // If row has a submodule, it must match one of the specified submodules
                if (row.subModuleId && !row.subModuleId.includes('placeholder')) {
                    if (!subModules.includes(row.subModuleId)) {
                        return; // Submodule doesn't match
                    }
                }
                // If row has no submodule (module-level row), it's still valid
            } else {
                // If no submodules specified but row has a real submodule, skip
                if (row.subModuleId && !row.subModuleId.includes('placeholder')) {
                    return;
                }
            }

            // Check topic level with hierarchical logic
            if (topics.length > 0) {
                // If row has a topic, it must match one of the specified topics
                if (row.topicId && !row.topicId.includes('placeholder')) {
                    if (!topics.includes(row.topicId)) {
                        return; // Topic doesn't match
                    }
                }
                // If row has no topic (module/submodule-level row), it's still valid
            } else {
                // If no topics specified but row has a real topic, skip
                if (row.topicId && !row.topicId.includes('placeholder')) {
                    return;
                }
            }

            // Check subtopic level with hierarchical logic
            if (subTopics.length > 0) {
                // If row has a subtopic, it must match one of the specified subtopics
                if (row.subtopicId && !row.subtopicId.includes('placeholder')) {
                    if (!subTopics.includes(row.subtopicId)) {
                        return; // Subtopic doesn't match
                    }
                }
                // If row has no subtopic (higher-level row), it's still valid
            } else {
                // If no subtopics specified but row has a real subtopic, skip
                if (row.subtopicId && !row.subtopicId.includes('placeholder')) {
                    return;
                }
            }

            // If we reached here, the row matches the hierarchical pattern
            rowIds.add(row.rowId);
        });

        return Array.from(rowIds);
    };
    // Helper function to toggle expansion state
    const toggleExpansion = (id: unknown, expandedSet: Iterable<unknown> | null | undefined, setExpandedSet: { (value: React.SetStateAction<Set<unknown>>): void; (value: React.SetStateAction<Set<unknown>>): void; (value: React.SetStateAction<Set<unknown>>): void; (value: React.SetStateAction<Set<unknown>>): void; (value: React.SetStateAction<Set<unknown>>): void; (value: React.SetStateAction<Set<unknown>>): void; (value: React.SetStateAction<Set<unknown>>): void; (arg0: Set<unknown>): void; }) => {
        const newSet = new Set(expandedSet);
        if (newSet.has(id)) {
            newSet.delete(id);
        } else {
            newSet.add(id);
        }
        setExpandedSet(newSet);
    };
    const isLastHierarchy = () => {
        if (!selectedCourse || !dialogType) return false;

        // Normalize hierarchy (all lowercase, no spaces)
        const hierarchyLevels = selectedCourse.courseHierarchy.map(level =>
            level.toLowerCase().replace(/\s+/g, "")
        );

        // Normalize current dialog type
        const currentLevel = dialogType.toLowerCase().replace(/\s+/g, "");

        const currentLevelIndex = hierarchyLevels.findIndex(level => level === currentLevel);

        if (currentLevelIndex === -1) return false;

        // It's the last if its index is the last one in the hierarchy array
        return currentLevelIndex === hierarchyLevels.length - 1;
    };
    const isLastHierarchy2 = (dialogType2: any) => {
        if (!selectedCourse || !dialogType2) return false;

        // Normalize hierarchy (all lowercase, no spaces)
        const hierarchyLevels = selectedCourse.courseHierarchy.map(level =>
            level.toLowerCase().replace(/\s+/g, "")
        );

        // Normalize current dialog type
        const currentLevel = dialogType2.toLowerCase().replace(/\s+/g, "");

        const currentLevelIndex = hierarchyLevels.findIndex(level => level === currentLevel);

        if (currentLevelIndex === -1) return false;

        // It's the last if its index is the last one in the hierarchy array
        return currentLevelIndex === hierarchyLevels.length - 1;
    };

    const filterPlaceholders2 = (id: string | null): string | null => {
        if (id && id.includes("placeholder")) {
            return null;
        }
        return id;
    };

    // Add these helper functions near your other utility functions

    const doesParentHaveOtherChildren = (dialogType: string | null, editMode: any) => {
        if (!dialogType || editMode) return false;

        switch (dialogType) {
            case 'module':
                return true;
            case 'submodule':
                // Check if the parent module has other submodules
                const parentModuleId = selectedModuleForSubModule?.id;
                if (!parentModuleId) return false;
                const otherSubModules = subModules.filter(sm =>
                    sm.moduleId === parentModuleId && sm._id !== (editMode?.data?._id)
                );
                return otherSubModules.length > 0;

            case 'topic':
                // Check if the parent (submodule or module) has other topics
                const parentId = selectedSubModuleForTopic?.id;
                if (!parentId) return false;

                if (hasSubModule2()) {
                    // Parent is submodule
                    const otherTopics = topics.filter(t =>
                        t.subModuleId === parentId && t._id !== (editMode?.data?._id)
                    );
                    return otherTopics.length > 0;
                } else {
                    // Parent is module
                    const otherTopics = topics.filter(t =>
                        t.moduleId === parentId && t._id !== (editMode?.data?._id)
                    );
                    return otherTopics.length > 0;
                }

            case 'subtopic':
                // Check if the parent topic has other subtopics
                const parentTopicId = selectedTopicForSubTopic?.id;
                if (!parentTopicId) return false;
                const otherSubTopics = subTopics.filter(st =>
                    st.topicId === parentTopicId && st._id !== (editMode?.data?._id)
                );
                return otherSubTopics.length > 0;

            default:
                return false;
        }
    };
    // Add this helper function to check if any pedagogy has hours > 0
    const hasPedagogyHoursGreaterThanZero = () => {
        // Check I Do activities
        const iDoHasHours = Object.values(pedagogyHours.iDo).some(hours => hours > 0);

        // Check We Do activities
        const weDoHasHours = Object.values(pedagogyHours.weDo).some(hours => hours > 0);

        // Check You Do activities
        const youDoHasHours = Object.values(pedagogyHours.youDo).some(hours => hours > 0);

        return iDoHasHours || weDoHasHours || youDoHasHours;
    };
    // Combined function to determine if toggle should be shown
    const shouldShowPedagogyLevelToggle = (dialogType: string | null, editMode: any) => {
        if (!isLastHierarchy()) return false;
        if (editMode) return false;

        // Check if parent has other children
        const parentHasOtherChildren = doesParentHaveOtherChildren(dialogType, editMode);

        // Only show toggle if parent has NO other children (this is the first child)
        return !parentHasOtherChildren;
    };

    const getStickyLeftPosition = (index: number) => {
        return `${120 * index}px`
    }
    const hierarchyLevelsCount = selectedCourse?.courseHierarchy.length || 0;
    const hierarchyWidthPercentage = selectedPedagogyTypes.length > 0
        ? 55 / hierarchyLevelsCount // Distribute 60% among hierarchy levels
        : undefined; // Auto width when no pedagogy selected

    const createTableRows = (): any[] => {
        const rows: any[] = [];
        let rowIndex = 0;

        // Ensure we have modules before proceeding
        if (!modules.length || !selectedCourse) return rows;

        // Get the hierarchy levels that exist in the course
        const hierarchyLevels = selectedCourse.courseHierarchy.map(level => level.toLowerCase());
        const hasSubModules = hierarchyLevels.includes('sub module');
        const hasTopics = hierarchyLevels.includes('topic');
        const hasSubTopics = hierarchyLevels.includes('sub topic');

        const sortedModules = [...modules].sort((a, b) => (a.index || 0) - (b.index || 0));

        sortedModules.forEach((module) => {
            if (hasSubModules) {
                const moduleSubModules = subModules.filter(sub => sub.moduleId === module._id)
                    .sort((a, b) => (a.index || 0) - (b.index || 0));

                if (moduleSubModules.length > 0) {
                    moduleSubModules.forEach((subModule) => {
                        const subModuleTopics = topics.filter(topic => topic.subModuleId === subModule._id)
                            .sort((a, b) => (a.index || 0) - (b.index || 0));

                        if (subModuleTopics.length > 0) {
                            subModuleTopics.forEach(topic => {
                                const topicSubTopics = subTopics.filter(subTopic => subTopic.topicId === topic._id)
                                    .sort((a, b) => (a.index || 0) - (b.index || 0));

                                if (topicSubTopics.length > 0) {
                                    topicSubTopics.forEach(subTopic => {
                                        rows.push({
                                            moduleId: module._id,
                                            moduleName: module.title,
                                            subModuleId: subModule._id,
                                            subModuleName: subModule.title,
                                            topicId: topic._id,
                                            topicName: topic.title,
                                            subtopicId: subTopic._id,
                                            subtopicName: subTopic.title,
                                            rowIndex: rowIndex++,
                                            rowId: `${module._id}-${subModule._id}-${topic._id}-${subTopic._id}`,
                                        });
                                    });
                                } else {
                                    // Topic exists but no subtopics (or subtopics not in hierarchy)
                                    rows.push({
                                        moduleId: module._id,
                                        moduleName: module.title,
                                        subModuleId: subModule._id,
                                        subModuleName: subModule.title,
                                        topicId: topic._id,
                                        topicName: topic.title,
                                        subtopicId: `${topic._id}-placeholder`,
                                        subtopicName: "-",
                                        rowIndex: rowIndex++,
                                        rowId: `${module._id}-${subModule._id}-${topic._id}-placeholder`,
                                    });
                                }
                            });
                        } else {
                            // Submodule exists but no topics (or topics not in hierarchy)
                            rows.push({
                                moduleId: module._id,
                                moduleName: module.title,
                                subModuleId: subModule._id,
                                subModuleName: subModule.title,
                                topicId: `${subModule._id}-placeholder`,
                                topicName: "-",
                                subtopicId: `${subModule._id}-placeholder-sub`,
                                subtopicName: "-",
                                rowIndex: rowIndex++,
                                rowId: `${module._id}-${subModule._id}-placeholder`,
                            });
                        }
                    });
                } else {
                    // Module exists but no submodules (but submodules are in hierarchy)
                    rows.push({
                        moduleId: module._id,
                        moduleName: module.title,
                        subModuleId: `${module._id}-placeholder`,
                        subModuleName: "-",
                        topicId: `${module._id}-placeholder-topic`,
                        topicName: "-",
                        subtopicId: `${module._id}-placeholder-sub`,
                        subtopicName: "-",
                        rowIndex: rowIndex++,
                        rowId: `${module._id}-placeholder`,
                    });
                }
            } else if (hasTopics) {
                const moduleTopics = topics.filter(topic => topic.moduleId === module._id)
                    .sort((a, b) => (a.index || 0) - (b.index || 0));

                if (moduleTopics.length > 0) {
                    moduleTopics.forEach(topic => {
                        const topicSubTopics = subTopics.filter(subTopic => subTopic.topicId === topic._id)
                            .sort((a, b) => (a.index || 0) - (b.index || 0));

                        if (topicSubTopics.length > 0) {
                            topicSubTopics.forEach(subTopic => {
                                rows.push({
                                    moduleId: module._id,
                                    moduleName: module.title,
                                    subModuleId: null,
                                    subModuleName: "",
                                    topicId: topic._id,
                                    topicName: topic.title,
                                    subtopicId: subTopic._id,
                                    subtopicName: subTopic.title,
                                    rowIndex: rowIndex++,
                                    rowId: `${module._id}-${topic._id}-${subTopic._id}`,
                                });
                            });
                        } else {
                            // Create row with topic but no subtopics
                            rows.push({
                                moduleId: module._id,
                                moduleName: module.title,
                                subModuleId: null,
                                subModuleName: "",
                                topicId: topic._id,
                                topicName: topic.title,
                                subtopicId: `${topic._id}-placeholder`,
                                subtopicName: "-",
                                rowIndex: rowIndex++,
                                rowId: `${module._id}-${topic._id}-placeholder`,
                            });
                        }
                    });
                } else {
                    // Create row with module but no topics
                    rows.push({
                        moduleId: module._id,
                        moduleName: module.title,
                        subModuleId: null,
                        subModuleName: "",
                        topicId: `${module._id}-placeholder`,
                        topicName: "-",
                        subtopicId: `${module._id}-placeholder-sub`,
                        subtopicName: "-",
                        rowIndex: rowIndex++,
                        rowId: `${module._id}-placeholder`,
                    });
                }
            } else {
                // Only module level exists
                rows.push({
                    moduleId: module._id,
                    moduleName: module.title,
                    subModuleId: null,
                    subModuleName: "",
                    topicId: null,
                    topicName: "",
                    subtopicId: `${module._id}-placeholder`,
                    subtopicName: "-",
                    rowIndex: rowIndex++,
                    rowId: `${module._id}-placeholder`,
                });
            }
        });

        return rows;
    };
    const tableRows = createTableRows()
    useEffect(() => {
        if (scaledContentRef.current) {
            const measureHeight = () => {
                const height = scaledContentRef.current!.scrollHeight;
                setContentHeight(height);
            };

            measureHeight();

            // Re-measure when content changes
            const resizeObserver = new ResizeObserver(measureHeight);
            resizeObserver.observe(scaledContentRef.current);

            return () => resizeObserver.disconnect();
        }
    }, [selectedCourse, tableRows, selectedPedagogyTypes]);
    const calculateNegativeMargin = () => {
        if (!contentHeight || tableZoomLevel >= 1) return 0;

        // Calculate the actual height difference after scaling
        const scaledHeight = contentHeight * tableZoomLevel;
        const heightDifference = contentHeight - scaledHeight;

        return -heightDifference;
    };
    const handleCellClick = (
        moduleId: string,
        topicId: string,
        subtopicId: string,
        type: "iDo" | "weDo" | "youDo",
        activity: string,
        subModuleId?: string
    ) => {
        const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];

        // Get the actual value from courseHours using the provided IDs
        const effectiveTopicId = topicId || `${moduleId}-default-topic`;
        const effectiveSubtopicId = subtopicId ||
            (topicId ? `${topicId}-default-subtopic` : `${moduleId}-default-subtopic`);

        const value = courseHours[moduleId]?.[effectiveTopicId]?.[effectiveSubtopicId]?.[type]?.[activity] || 0;
        const isEditing = value > 0;
        // Set up the form data for the popup
        setPedagogyFormData({
            moduleId,
            topicId: effectiveTopicId,
            subtopicId: effectiveSubtopicId,
            type,
            activity,
            value: value.toString(),
            isEditing,
            ...(hierarchyLevels.includes('sub module') && { subModuleId })
        });

        // Open the popup dialog
        setShowPedagogyDialog(true);
    };
    const handlePedagogySave = async () => {
        if (!pedagogyFormData || !selectedCourse) return;

        const value = Number.parseFloat(pedagogyFormData.value) || 0;
        const { moduleId, topicId, subtopicId, type, activity, subModuleId } = pedagogyFormData;
        if (value <= 0) {
            setErrorMessage("Hours value must be greater than 0");
            setShowErrorDialog(true);
            return;
        }
        // Update local state
        setCourseHours(prev => ({
            ...prev,
            [moduleId]: {
                ...prev[moduleId],
                [topicId]: {
                    ...prev[moduleId]?.[topicId],
                    [subtopicId]: {
                        ...prev[moduleId]?.[topicId]?.[subtopicId],
                        [type]: {
                            ...prev[moduleId]?.[topicId]?.[subtopicId]?.[type],
                            [activity]: value,
                        },
                    },
                },
            },
        }));

        // Prepare payload for API call
        const hierarchyLevels = selectedCourse.courseHierarchy.map(level => level.toLowerCase());

        // Helper function to filter out empty strings and undefined values
        const filterPlaceholders = (id: string | undefined) => {
            return id && !id.includes('placeholder') ? [id] : [];
        };

        const pedagogyData = {
            iDo: type === "iDo" ? [{ type: activity, duration: value }] : [],
            weDo: type === "weDo" ? [{ type: activity, duration: value }] : [],
            youDo: type === "youDo" ? [{ type: activity, duration: value }] : [],
            ...(hierarchyLevels.includes('module') && { module: filterPlaceholders(moduleId) }),
            ...(hierarchyLevels.includes('sub module') && { subModule: filterPlaceholders(subModuleId) }),
            ...(hierarchyLevels.includes('topic') && { topic: filterPlaceholders(topicId) }),
            ...(hierarchyLevels.includes('sub topic') && { subTopic: filterPlaceholders(subtopicId) }),
        };

        try {
            // API call to save the data
            await pedagogyMutation.mutateAsync({
                courses: selectedCourse._id,
                pedagogies: pedagogyViews?.[0]?.pedagogies
                    ? [...pedagogyViews[0].pedagogies, pedagogyData]
                    : [pedagogyData],
            });

            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 2000);
        } catch (error) {
            console.error("Failed to save pedagogy:", error);
            // Revert optimistic update on error
            setCourseHours(prev => ({ ...prev }));
        } finally {
            setShowPedagogyDialog(false);
            setPedagogyFormData(null);
        }
    };
    // Add this function near your other state declarations
    const resetAllFormStates = () => {
        // Reset form data
        setModuleFormData({ title: '', description: '', level: 'Easy', duration: 0, index: 0 });
        setSubModuleFormData({ title: '', description: '', level: 'Easy', duration: 0 });
        setTopicFormData({ title: '', description: '', level: 'Easy', duration: 0 });
        setSubTopicFormData({ title: '', description: '', level: 'Easy', duration: 0 });
        setAddOnlyPedagogyLevel(false);
        // Reset level and pedagogy sections
        setShowLevelSection(false);
        setShowPedagogySection(false);
        setShowMergeLevelSection(false);
        setShowMergePedagogySection({
            iDo: false,
            weDo: false,
            youDo: false
        });
        setSelectedLevelModulesForMerge(new Set());
        setSelectedLevelSubModulesForMerge(new Set());
        setSelectedLevelTopicsForMerge(new Set());
        setSelectedLevelSubTopicsForMerge(new Set());

        setSelectedPedagogyModulesForMerge({});
        setSelectedPedagogySubModulesForMerge({});
        setSelectedPedagogyTopicsForMerge({});
        setSelectedPedagogySubTopicsForMerge({});
        // Reset pedagogy activities and hours
        setSelectedPedagogyActivities({
            iDo: [],
            weDo: [],
            youDo: []
        });
        setPedagogyHours({
            iDo: {},
            weDo: {},
            youDo: {}
        });

        // Reset saved merge selections
        setSavedLevelMergeSelections(null);
        setSavedPedagogyMergeSelections({
            iDo: {},
            weDo: {},
            youDo: {}
        });

        // Reset expanded states
        setExpandedModules(new Set());
        setExpandedSubModules(new Set());
        setExpandedTopics(new Set());

        // Reset selected level
        setSelectedLevel('');
        setDisableAddonlyMode(false);
        // Reset dialog and edit mode
        setDialogType(null);
        setEditMode(null);
    };

    const isFirstChild = (dialogType: string | null, editMode: any) => {
        if (!dialogType || editMode) return false;

        switch (dialogType) {
            case 'module':
                // Always first child for modules since they're top-level
                return modules.length === 0;

            case 'submodule':
                // Check if parent module has other submodules
                const parentModuleId = selectedModuleForSubModule?.id;
                if (!parentModuleId) return false;
                const otherSubModules = subModules.filter(sm =>
                    sm.moduleId === parentModuleId && sm._id !== (editMode?.data?._id)
                );
                return otherSubModules.length === 0;

            case 'topic':
                // Check if parent (submodule or module) has other topics
                const parentId = selectedSubModuleForTopic?.id;
                if (!parentId) return false;

                if (hasSubModule2()) {
                    // Parent is submodule
                    const otherTopics = topics.filter(t =>
                        t.subModuleId === parentId && t._id !== (editMode?.data?._id)
                    );
                    return otherTopics.length === 0;
                } else {
                    // Parent is module
                    const otherTopics = topics.filter(t =>
                        t.moduleId === parentId && t._id !== (editMode?.data?._id)
                    );
                    return otherTopics.length === 0;
                }

            case 'subtopic':
                // Check if parent topic has other subtopics
                const parentTopicId = selectedTopicForSubTopic?.id;
                if (!parentTopicId) return false;
                const otherSubTopics = subTopics.filter(st =>
                    st.topicId === parentTopicId && st._id !== (editMode?.data?._id)
                );
                return otherSubTopics.length === 0;

            default:
                return false;
        }
    };

    // Add this function to get the last child ID of a parent
    const getLastChildId = (parentId: string, type: 'module' | 'submodule' | 'topic' | 'subtopic') => {
        switch (type) {
            case 'module':
                // For module, get the last subtopic under it
                const moduleSubModules = subModules.filter(sm => sm.moduleId === parentId);
                let lastSubtopicId = null;

                // Get all subtopics in this module and find the last one
                const allModuleSubTopics: any[] = [];

                for (const subModule of moduleSubModules) {
                    const subModuleTopics = topics.filter(t => t.subModuleId === subModule._id);
                    for (const topic of subModuleTopics) {
                        const topicSubTopics = subTopics.filter(st => st.topicId === topic._id);
                        allModuleSubTopics.push(...topicSubTopics);
                    }
                }

                // Sort by index to get the actual last child
                if (allModuleSubTopics.length > 0) {
                    const sortedSubTopics = [...allModuleSubTopics].sort((a, b) => (a.index || 0) - (b.index || 0));
                    lastSubtopicId = sortedSubTopics[sortedSubTopics.length - 1]?._id || null;
                }

                return lastSubtopicId;

            case 'submodule':
                // For submodule, get the last subtopic under it
                const subModuleTopics = topics.filter(t => t.subModuleId === parentId);
                let lastSubtopicIdSubModule = null;

                const allSubModuleSubTopics: any[] = [];
                for (const topic of subModuleTopics) {
                    const topicSubTopics = subTopics.filter(st => st.topicId === topic._id);
                    allSubModuleSubTopics.push(...topicSubTopics);
                }

                if (allSubModuleSubTopics.length > 0) {
                    const sortedSubTopics = [...allSubModuleSubTopics].sort((a, b) => (a.index || 0) - (b.index || 0));
                    lastSubtopicIdSubModule = sortedSubTopics[sortedSubTopics.length - 1]?._id || null;
                }

                return lastSubtopicIdSubModule;

            case 'topic':
                // For topic, get the last subtopic
                const topicSubTopics = subTopics.filter(st => st.topicId === parentId);
                if (topicSubTopics.length > 0) {
                    const sortedSubTopics = [...topicSubTopics].sort((a, b) => (a.index || 0) - (b.index || 0));
                    return sortedSubTopics[sortedSubTopics.length - 1]?._id || null;
                }
                return null;

            case 'subtopic':
                // For subtopic, it's the leaf node, so return itself
                return parentId;

            default:
                return null;
        }
    };

    // Add these helper functions to check and delete existing pedagogy/level data
    const checkAndDeleteExistingPedagogyData = async (
        hierarchyIds: {
            modules?: string[];
            subModules?: string[];
            topics?: string[];
            subTopics?: string[];
        },
        alreadyDeletedPedagogyItems: Set<string> = new Set(),
        preserveEditingItem: boolean = false,
        editingItemId?: string
    ) => {
        const pedagogyToUpdate = pedagogyViews?.[0];
        if (!pedagogyToUpdate) return;

        // Determine if this is the first child
        const firstChild = isFirstChild(dialogType, editMode);

        const pedagogiesToDelete = pedagogyToUpdate.pedagogies.filter((pedagogy: any) => {
            if (pedagogy._id && alreadyDeletedPedagogyItems.has(pedagogy._id)) {
                return false;
            }

            // If we're preserving the editing item, don't delete pedagogies that contain it
            if (preserveEditingItem && editingItemId) {
                if (pedagogy.module?.includes(editingItemId) ||
                    pedagogy.subModule?.includes(editingItemId) ||
                    pedagogy.topic?.includes(editingItemId) ||
                    pedagogy.subTopic?.includes(editingItemId)) {
                    return false;
                }
            }

            // For first child: delete ALL pedagogy containing the parent ID (both single and merged)
            if (firstChild) {
                if (dialogType === 'submodule' && hierarchyIds.modules?.some(id =>
                    pedagogy.module?.includes(id))) {
                    return true;
                }
                if (dialogType === 'topic') {
                    const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];
                    const hasSubModules = hierarchyLevels.includes('sub module');

                    if (hasSubModules && hierarchyIds.subModules?.some(id =>
                        pedagogy.subModule?.includes(id))) {
                        return true;
                    }
                    if (!hasSubModules && hierarchyIds.modules?.some(id =>
                        pedagogy.module?.includes(id))) {
                        return true;
                    }
                }
                if (dialogType === 'subtopic' && hierarchyIds.topics?.some(id =>
                    pedagogy.topic?.includes(id))) {
                    return true;
                }
            }
            // For subsequent children: only delete MERGED pedagogy containing the last child ID
            else if (!editMode) {
                let lastChildId = null;
                let parentId = null;

                if (dialogType === 'submodule') {
                    parentId = hierarchyIds.modules?.[0];
                    lastChildId = getLastChildId(parentId || '', 'module');
                } else if (dialogType === 'topic') {
                    const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];
                    const hasSubModules = hierarchyLevels.includes('sub module');

                    if (hasSubModules) {
                        parentId = hierarchyIds.subModules?.[0];
                        lastChildId = getLastChildId(parentId || '', 'submodule');
                    } else {
                        parentId = hierarchyIds.modules?.[0];
                        lastChildId = getLastChildId(parentId || '', 'module');
                    }

                } else if (dialogType === 'subtopic') {
                    parentId = hierarchyIds.topics?.[0];
                    lastChildId = getLastChildId(parentId || '', 'topic');
                }

                // Only delete if it's a MERGED cell (has multiple hierarchy items)
                if (lastChildId && parentId && pedagogy.subTopic?.includes(lastChildId)) {
                    const isMergedCell = isPedagogyMerged(pedagogy);

                    // Check if merged with another parent (contains hierarchy items from different parents)
                    const isMergedWithAnotherParent = checkIfMergedWithAnotherParent(pedagogy, parentId, dialogType);

                    return isMergedCell && isMergedWithAnotherParent;
                }
            }

            return false;
        });

        for (const pedagogy of pedagogiesToDelete) {
            if (pedagogy._id) {
                alreadyDeletedPedagogyItems.add((pedagogy as any)._id);
            }

            // Delete ALL activities for the filtered pedagogies
            if (pedagogy.iDo && pedagogy.iDo.length > 0) {
                for (const activity of pedagogy.iDo) {
                    try {
                        await deletePedagogyMutation.mutateAsync({
                            activityType: "iDo",
                            itemId: activity._id
                        });
                    } catch (error: any) {
                        if (error.response?.status !== 404) {
                            throw error;
                        }
                    }
                }
            }

            if (pedagogy.weDo && pedagogy.weDo.length > 0) {
                for (const activity of pedagogy.weDo) {
                    try {
                        await deletePedagogyMutation.mutateAsync({
                            activityType: "weDo",
                            itemId: activity._id
                        });
                    } catch (error: any) {
                        if (error.response?.status !== 404) {
                            throw error;
                        }
                    }
                }
            }

            if (pedagogy.youDo && pedagogy.youDo.length > 0) {
                for (const activity of pedagogy.youDo) {
                    try {
                        await deletePedagogyMutation.mutateAsync({
                            activityType: "youDo",
                            itemId: activity._id
                        });
                    } catch (error: any) {
                        if (error.response?.status !== 404) {
                            throw error;
                        }
                    }
                }
            }

            // Clean up empty pedagogy entries
            const hasRemainingActivities =
                (pedagogy.iDo && pedagogy.iDo.length > 0) ||
                (pedagogy.weDo && pedagogy.weDo.length > 0) ||
                (pedagogy.youDo && pedagogy.youDo.length > 0);

            if (!hasRemainingActivities && pedagogy._id) {
                try {
                    await deleteDocumentMutation.mutateAsync({
                        model: 'PedagogyView1' as const,
                        id: pedagogy._id
                    });
                } catch (error: any) {
                    if (error.response?.status !== 404) {
                        throw error;
                    }
                }
            }
        }
    };


    const checkAndDeleteExistingLevelData = async (
        hierarchyIds: {
            modules?: string[];
            subModules?: string[];
            topics?: string[];
            subTopics?: string[];
        },
        alreadyDeletedLevels: Set<string> = new Set(),
        preserveEditingItem: boolean = false,
        editingItemId?: string
    ) => {
        if (!levelViewId) return;

        // Determine if this is the first child
        const firstChild = isFirstChild(dialogType, editMode);

        // Check if we have merge selections (meaning we're merging with other elements)
        const hasMergeSelections =
            (savedLevelMergeSelections &&
                (savedLevelMergeSelections.modules.length > 0 ||
                    savedLevelMergeSelections.subModules.length > 0 ||
                    savedLevelMergeSelections.topics.length > 0 ||
                    savedLevelMergeSelections.subTopics.length > 0)) ||
            (showMergeLevelSection &&
                (selectedLevelModulesForMerge.size > 0 ||
                    selectedLevelSubModulesForMerge.size > 0 ||
                    selectedLevelTopicsForMerge.size > 0 ||
                    selectedLevelSubTopicsForMerge.size > 0));

        const levelsToDelete = levelsData.filter((level: any) => {
            if (level._id && alreadyDeletedLevels.has(level._id)) {
                return false;
            }

            if (preserveEditingItem && editingItemId) {
                if (level.module?.includes(editingItemId) ||
                    level.subModule?.includes(editingItemId) ||
                    level.topic?.includes(editingItemId) ||
                    level.subTopic?.includes(editingItemId)) {
                    return false;
                }
            }

            // CASE 1: First child - delete level containing the parent ID
            if (firstChild) {
                if (dialogType === 'submodule' && hierarchyIds.modules?.some(id =>
                    level.module?.includes(id))) {
                    return true;
                }
                if (dialogType === 'topic') {
                    const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];
                    const hasSubModules = hierarchyLevels.includes('sub module');

                    if (hasSubModules && hierarchyIds.subModules?.some(id =>
                        level.subModule?.includes(id))) {
                        return true;
                    }
                    if (!hasSubModules && hierarchyIds.modules?.some(id =>
                        level.module?.includes(id))) {
                        return true;
                    }
                }
                if (dialogType === 'subtopic' && hierarchyIds.topics?.some(id =>
                    level.topic?.includes(id))) {
                    return true;
                }
            }
            // CASE 2: Subsequent children with merge selections - delete current element's level data
            else if (hasMergeSelections) {
                // Delete level data containing the current element ID
                if (dialogType === 'submodule' && hierarchyIds.subModules?.some(id =>
                    level.subModule?.includes(id))) {
                    return true;
                }
                if (dialogType === 'topic' && hierarchyIds.topics?.some(id =>
                    level.topic?.includes(id))) {
                    return true;
                }
                if (dialogType === 'subtopic' && hierarchyIds.subTopics?.some(id =>
                    level.subTopic?.includes(id))) {
                    return true;
                }
            }
            // CASE 3: Subsequent children without merge selections - only delete if parent's last child has merged level
            else if (!editMode) {
                let lastChildId = null;
                let parentId = null;

                // Get parent ID and last child ID based on dialog type
                if (dialogType === 'submodule') {
                    parentId = hierarchyIds.modules?.[0];
                    lastChildId = getLastChildId(parentId || '', 'module');
                } else if (dialogType === 'topic') {
                    const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];
                    const hasSubModules = hierarchyLevels.includes('sub module');

                    if (hasSubModules) {
                        parentId = hierarchyIds.subModules?.[0];
                        lastChildId = getLastChildId(parentId || '', 'submodule');
                    } else {
                        parentId = hierarchyIds.modules?.[0];
                        lastChildId = getLastChildId(parentId || '', 'module');
                    }
                } else if (dialogType === 'subtopic') {
                    parentId = hierarchyIds.topics?.[0];
                    lastChildId = getLastChildId(parentId || '', 'topic');
                }

                // Check if the last child has a merged level (multiple hierarchy items)
                if (lastChildId && parentId && level.subTopic?.includes(lastChildId)) {
                    const isMergedLevel =
                        (level.module && level.module.length > 1) ||
                        (level.subModule && level.subModule.length > 1) ||
                        (level.topic && level.topic.length > 1) ||
                        (level.subTopic && level.subTopic.length > 1);
                    const isMergedWithAnotherParent = checkIfLevelMergedWithAnotherParent(level, parentId, dialogType);
                    return isMergedLevel && isMergedWithAnotherParent;
                }
            }

            return false;
        });

        for (const level of levelsToDelete) {
            if (level._id) {
                await deleteLevelMutation.mutateAsync(level._id);
                alreadyDeletedLevels.add(level._id);
            }
        }
    };


    // Update the checkAndDeleteExistingMergedCells function
    const checkAndDeleteExistingMergedCells = (hierarchyIds: {
        modules?: string[];
        subModules?: string[];
        topics?: string[];
        subTopics?: string[];
    }) => {
        const updatedMergedCells = { ...mergedCells };

        // Determine if this is the first child
        const firstChild = isFirstChild(dialogType, editMode);

        // For first child: use existing logic to delete all merged cells containing parent hierarchy
        if (firstChild) {
            Object.keys(updatedMergedCells).forEach(key => {
                updatedMergedCells[key] = updatedMergedCells[key].filter(merge => {
                    const moduleConflict = hierarchyIds.modules?.some(id =>
                        merge.hierarchyIds?.modules.includes(id)
                    );
                    const subModuleConflict = hierarchyIds.subModules?.some(id =>
                        merge.hierarchyIds?.subModules.includes(id)
                    );
                    const topicConflict = hierarchyIds.topics?.some(id =>
                        merge.hierarchyIds?.topics.includes(id)
                    );
                    const subtopicConflict = hierarchyIds.subTopics?.some(id =>
                        merge.hierarchyIds?.subTopics.includes(id)
                    );

                    return !(moduleConflict || subModuleConflict || topicConflict || subtopicConflict);
                });
            });

            setMergedCells(updatedMergedCells);

            const updatedMergedLevels = mergedLevels.filter(merge => {
                const moduleConflict = hierarchyIds.modules?.some(id =>
                    merge.hierarchyIds.modules.includes(id)
                );
                const subModuleConflict = hierarchyIds.subModules?.some(id =>
                    merge.hierarchyIds.subModules.includes(id)
                );
                const topicConflict = hierarchyIds.topics?.some(id =>
                    merge.hierarchyIds.topics.includes(id)
                );
                const subtopicConflict = hierarchyIds.subTopics?.some(id =>
                    merge.hierarchyIds.subTopics.includes(id)
                );

                return !(moduleConflict || subModuleConflict || topicConflict || subtopicConflict);
            });

            setMergedLevels(updatedMergedLevels);
        }
        // For subsequent children: only remove merged cells containing the parent's last child element ID
        else {
            let lastChildId = null;
            let parentModuleId = null;

            // Get the last child ID and parent module ID based on dialog type
            if (dialogType === 'submodule') {
                parentModuleId = hierarchyIds.modules?.[0] || '';
                lastChildId = getLastChildId(parentModuleId, 'module');
            } else if (dialogType === 'topic') {
                const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];
                const hasSubModules = hierarchyLevels.includes('sub module');

                if (hasSubModules) {
                    const parentSubModuleId = hierarchyIds.subModules?.[0] || '';
                    lastChildId = getLastChildId(parentSubModuleId, 'submodule');
                    // Get the module ID from the submodule
                    const parentSubModule = subModules.find(sm => sm._id === parentSubModuleId);
                    parentModuleId = parentSubModule?.moduleId || '';
                } else {
                    parentModuleId = hierarchyIds.modules?.[0] || '';
                    lastChildId = getLastChildId(parentModuleId, 'module');
                }
            } else if (dialogType === 'subtopic') {
                const parentTopicId = hierarchyIds.topics?.[0] || '';
                lastChildId = getLastChildId(parentTopicId, 'topic');
                // Get the module ID from the topic
                const parentTopic = topics.find(t => t._id === parentTopicId);
                parentModuleId = parentTopic?.moduleId || '';
            }

            // Only proceed if we have both lastChildId and parentModuleId
            if (lastChildId && parentModuleId) {
                Object.keys(updatedMergedCells).forEach(key => {
                    updatedMergedCells[key] = updatedMergedCells[key].filter(merge => {
                        // Only remove merged cells that:
                        // 1. Contain the last child ID in subTopics
                        // 2. AND contain the parent module ID in modules
                        const containsLastChild = merge.hierarchyIds?.subTopics.includes(lastChildId);
                        const containsParentModule = merge.hierarchyIds?.modules.includes(parentModuleId);
                        const isMergedWithAnotherParent = merge.hierarchyIds?.modules && merge.hierarchyIds.modules.length > 1;
                        // Keep the merged cell if it doesn't contain both the last child AND parent module
                        return !(containsLastChild && containsParentModule && isMergedWithAnotherParent);
                    });
                });

                setMergedCells(updatedMergedCells);

                const updatedMergedLevels = mergedLevels.filter(merge => {
                    const containsLastChild = merge.hierarchyIds.subTopics.includes(lastChildId);
                    const containsParentModule = merge.hierarchyIds.modules.includes(parentModuleId);
                    const isMergedWithAnotherParent = merge.hierarchyIds.modules && merge.hierarchyIds.modules.length > 1;
                    return !(containsLastChild && containsParentModule && isMergedWithAnotherParent);
                });

                setMergedLevels(updatedMergedLevels);
            }
        }
    };

    // Update the getLastChildId function to ensure it returns the correct last child
    const isPedagogyMerged = (pedagogy: any): boolean => {
        return (
            (pedagogy.module && pedagogy.module.length > 1) ||
            (pedagogy.subModule && pedagogy.subModule.length > 1) ||
            (pedagogy.topic && pedagogy.topic.length > 1) ||
            (pedagogy.subTopic && pedagogy.subTopic.length > 1)
        );
    };

    const checkAndDeleteExistingPedagogyDataForSelectedActivities = async (
        hierarchyIds: {
            modules?: string[];
            subModules?: string[];
            topics?: string[];
            subTopics?: string[];
        },
        alreadyDeletedPedagogyItems: Set<string> = new Set(),
        preserveEditingItem: boolean = false,
        editingItemId?: string
    ) => {
        const pedagogyToUpdate = pedagogyViews?.[0];
        if (!pedagogyToUpdate) return;

        // Get selected activity types
        const selectedActivityTypes = {
            iDo: selectedPedagogyActivities.iDo,
            weDo: selectedPedagogyActivities.weDo,
            youDo: selectedPedagogyActivities.youDo
        };

        // Get current merge selections for the specific activity
        const currentMergeSelections = savedPedagogyMergeSelections;

        const pedagogiesToDelete = pedagogyToUpdate.pedagogies.filter((pedagogy: any) => {
            if (pedagogy._id && alreadyDeletedPedagogyItems.has(pedagogy._id)) {
                return false;
            }

            // If we're preserving the editing item, don't delete pedagogies that contain it
            if (preserveEditingItem && editingItemId) {
                if (pedagogy.module?.includes(editingItemId) ||
                    pedagogy.subModule?.includes(editingItemId) ||
                    pedagogy.topic?.includes(editingItemId) ||
                    pedagogy.subTopic?.includes(editingItemId)) {
                    return false;
                }
            }

            // Check if this pedagogy contains ANY of the selected merge element IDs
            const containsSelectedElements =
                (hierarchyIds.modules?.some(id => pedagogy.module?.includes(id))) ||
                (hierarchyIds.subModules?.some(id => pedagogy.subModule?.includes(id))) ||
                (hierarchyIds.topics?.some(id => pedagogy.topic?.includes(id))) ||
                (hierarchyIds.subTopics?.some(id => pedagogy.subTopic?.includes(id)));

            if (!containsSelectedElements) return false;

            // For MERGE operations: Delete pedagogy that contains selected merge elements
            // Check if we have any merge selections (meaning we're in merge mode)
            const hasMergeSelections =
                (currentMergeSelections?.iDo && Object.keys(currentMergeSelections.iDo).length > 0) ||
                (currentMergeSelections?.weDo && Object.keys(currentMergeSelections.weDo).length > 0) ||
                (currentMergeSelections?.youDo && Object.keys(currentMergeSelections.youDo).length > 0);

            if (hasMergeSelections && containsSelectedElements) {
                // In merge mode: Only delete if pedagogy contains EXACTLY the selected merge elements
                // This prevents deleting parent's last child single cell values

                // Check if this pedagogy ONLY contains elements from our merge selection (not parent's last child)
                const containsOnlyMergeElements =
                    (!pedagogy.module || pedagogy.module.every((id: string) => hierarchyIds.modules?.includes(id))) &&
                    (!pedagogy.subModule || pedagogy.subModule.every((id: string) => hierarchyIds.subModules?.includes(id))) &&
                    (!pedagogy.topic || pedagogy.topic.every((id: string) => hierarchyIds.topics?.includes(id))) &&
                    (!pedagogy.subTopic || pedagogy.subTopic.every((id: string) => hierarchyIds.subTopics?.includes(id)));

                // Only delete if it contains ONLY our selected merge elements (not mixed with parent's last child)
                return containsOnlyMergeElements;
            }

            // For NON-MERGE operations: Use the original first-child logic
            const firstChild = isFirstChild(dialogType, editMode);

            if (firstChild) {
                // First child logic remains the same
                if (dialogType === 'submodule' && hierarchyIds.modules?.some(id =>
                    pedagogy.module?.includes(id))) {
                    return true;
                }
                if (dialogType === 'topic') {
                    const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];
                    const hasSubModules = hierarchyLevels.includes('sub module');

                    if (hasSubModules && hierarchyIds.subModules?.some(id =>
                        pedagogy.subModule?.includes(id))) {
                        return true;
                    }
                    if (!hasSubModules && hierarchyIds.modules?.some(id =>
                        pedagogy.module?.includes(id))) {
                        return true;
                    }
                }
                if (dialogType === 'subtopic' && hierarchyIds.topics?.some(id =>
                    pedagogy.topic?.includes(id))) {
                    return true;
                }
            } // For subsequent children: only delete MERGED pedagogy containing the last child ID
            else if (!editMode) {
                let lastChildId = null;

                if (dialogType === 'submodule') {
                    lastChildId = getLastChildId(hierarchyIds.modules?.[0] || '', 'module');
                } else if (dialogType === 'topic') {
                    const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];
                    const hasSubModules = hierarchyLevels.includes('sub module');

                    if (hasSubModules) {
                        lastChildId = getLastChildId(hierarchyIds.subModules?.[0] || '', 'submodule');
                    } else {
                        lastChildId = getLastChildId(hierarchyIds.modules?.[0] || '', 'module');
                    }
                } else if (dialogType === 'subtopic') {
                    lastChildId = getLastChildId(hierarchyIds.topics?.[0] || '', 'topic');
                }

                // Only delete if it's a MERGED cell (has multiple hierarchy items) AND contains the last child
                if (lastChildId && pedagogy.subTopic?.includes(lastChildId)) {
                    const isMergedCell = isPedagogyMerged(pedagogy);
                    return isMergedCell;
                }

                // DO NOT delete single cell values for subsequent children
                return false;
            }

            return false;
        });

        // Delete the filtered pedagogies
        for (const pedagogy of pedagogiesToDelete) {
            if (pedagogy._id) {
                alreadyDeletedPedagogyItems.add((pedagogy as any)._id);
            }

            // Delete activities based on selection
            if (selectedActivityTypes.iDo.length > 0 && pedagogy.iDo) {
                for (const activity of pedagogy.iDo) {
                    if (selectedActivityTypes.iDo.includes(activity.type)) {
                        try {
                            await deletePedagogyMutation.mutateAsync({
                                activityType: "iDo",
                                itemId: activity._id
                            });
                        } catch (error: any) {
                            if (error.response?.status !== 404) {
                                throw error;
                            }
                        }
                    }
                }
            }

            if (selectedActivityTypes.weDo.length > 0 && pedagogy.weDo) {
                for (const activity of pedagogy.weDo) {
                    if (selectedActivityTypes.weDo.includes(activity.type)) {
                        try {
                            await deletePedagogyMutation.mutateAsync({
                                activityType: "weDo",
                                itemId: activity._id
                            });
                        } catch (error: any) {
                            if (error.response?.status !== 404) {
                                throw error;
                            }
                        }
                    }
                }
            }

            if (selectedActivityTypes.youDo.length > 0 && pedagogy.youDo) {
                for (const activity of pedagogy.youDo) {
                    if (selectedActivityTypes.youDo.includes(activity.type)) {
                        try {
                            await deletePedagogyMutation.mutateAsync({
                                activityType: "youDo",
                                itemId: activity._id
                            });
                        } catch (error: any) {
                            if (error.response?.status !== 404) {
                                throw error;
                            }
                        }
                    }
                }
            }

            // Clean up empty pedagogy entries
            const hasRemainingActivities =
                (pedagogy.iDo && pedagogy.iDo.length > 0) ||
                (pedagogy.weDo && pedagogy.weDo.length > 0) ||
                (pedagogy.youDo && pedagogy.youDo.length > 0);

            if (!hasRemainingActivities && pedagogy._id) {
                try {
                    await deleteDocumentMutation.mutateAsync({
                        model: 'PedagogyView1' as const,
                        id: pedagogy._id
                    });
                } catch (error: any) {
                    if (error.response?.status !== 404) {
                        throw error;
                    }
                }
            }
        }
    };

    const deleteSingleCellValuesForMerge = async (
        editingItemId: string,
        activityType: "iDo" | "weDo" | "youDo",
        activity: string
    ) => {
        const pedagogyToUpdate = pedagogyViews?.[0];
        if (!pedagogyToUpdate) return;

        const pedagogiesToUpdate = pedagogyToUpdate.pedagogies.filter((pedagogy: any) => {
            const hasEditingItem =
                (pedagogy.module?.includes(editingItemId)) ||
                (pedagogy.subModule?.includes(editingItemId)) ||
                (pedagogy.topic?.includes(editingItemId)) ||
                (pedagogy.subTopic?.includes(editingItemId));

            if (!hasEditingItem) return false;

            // Check if this is a single cell value for the specific activity
            const hasTargetActivity = pedagogy[activityType]?.some(
                (act: any) => act.type === activity
            );

            const isSingleCell =
                (!pedagogy.module || pedagogy.module.length <= 1) &&
                (!pedagogy.subModule || pedagogy.subModule.length <= 1) &&
                (!pedagogy.topic || pedagogy.topic.length <= 1) &&
                (!pedagogy.subTopic || pedagogy.subTopic.length <= 1);

            return hasTargetActivity && isSingleCell;
        });

        for (const pedagogy of pedagogiesToUpdate) {
            // Find the specific activity to delete
            const targetActivity = pedagogy[activityType]?.find(
                (act: any) => act.type === activity
            );

            if (targetActivity && targetActivity._id) {
                try {
                    // Delete only the specific activity using deletePedagogyMutation
                    await deletePedagogyMutation.mutateAsync({
                        activityType: activityType,
                        itemId: targetActivity._id
                    });
                } catch (error: any) {
                    if (error.response?.status !== 404) {
                        console.error(`Failed to delete ${activityType} activity:`, error);
                    }
                    // Continue with other deletions even if one fails
                }
            }
        }
    };

    // Add this helper function to check if a pedagogy is merged with another parent
    const checkIfMergedWithAnotherParent = (pedagogy: any, currentParentId: string, dialogType: string | null): boolean => {
        if (!dialogType) return false;

        switch (dialogType) {
            case 'submodule':
                // For submodule, check if merged with modules other than the current parent
                if (pedagogy.module && pedagogy.module.length > 1) {
                    return pedagogy.module.some((moduleId: string) => moduleId !== currentParentId);
                }
                break;

            case 'topic':
                const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];
                const hasSubModules = hierarchyLevels.includes('sub module');

                if (hasSubModules) {
                    // For topic with submodules, check if merged with submodules other than current parent
                    if (pedagogy.subModule && pedagogy.subModule.length > 1) {
                        return pedagogy.subModule.some((subModuleId: string) => subModuleId !== currentParentId);
                    }
                } else {
                    // For topic without submodules, check if merged with modules other than current parent
                    if (pedagogy.module && pedagogy.module.length > 1) {
                        return pedagogy.module.some((moduleId: string) => moduleId !== currentParentId);
                    }
                }
                break;

            case 'subtopic':
                // For subtopic, check if merged with topics other than current parent
                if (pedagogy.topic && pedagogy.topic.length > 1) {
                    return pedagogy.topic.some((topicId: string) => topicId !== currentParentId);
                }
                break;
        }

        return false;
    };
    // Add this helper function to check if a level is merged with another parent
    const checkIfLevelMergedWithAnotherParent = (level: any, currentParentId: string, dialogType: string | null): boolean => {
        if (!dialogType) return false;

        switch (dialogType) {
            case 'submodule':
                // For submodule, check if merged with modules other than the current parent
                if (level.module && level.module.length > 1) {
                    return level.module.some((moduleId: string) => moduleId !== currentParentId);
                }
                break;

            case 'topic':
                const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];
                const hasSubModules = hierarchyLevels.includes('sub module');

                if (hasSubModules) {
                    // For topic with submodules, check if merged with submodules other than current parent
                    if (level.subModule && level.subModule.length > 1) {
                        return level.subModule.some((subModuleId: string) => subModuleId !== currentParentId);
                    }
                } else {
                    // For topic without submodules, check if merged with modules other than current parent
                    if (level.module && level.module.length > 1) {
                        return level.module.some((moduleId: string) => moduleId !== currentParentId);
                    }
                }
                break;

            case 'subtopic':
                // For subtopic, check if merged with topics other than current parent
                if (level.topic && level.topic.length > 1) {
                    return level.topic.some((topicId: string) => topicId !== currentParentId);
                }
                break;
        }

        return false;
    };
    // Add these helper functions to collect complete hierarchy IDs
    const collectCompleteHierarchyIds = (selectedIds: Set<string>, type: 'module' | 'submodule' | 'topic' | 'subtopic') => {
        const allModuleIds = new Set<string>();
        const allSubModuleIds = new Set<string>();
        const allTopicIds = new Set<string>();
        const allSubTopicIds = new Set<string>();

        if (type === 'module') {
            // For modules, get all hierarchy under each selected module
            selectedIds.forEach(moduleId => {
                allModuleIds.add(moduleId);

                // Get all submodules under this module
                const moduleSubModules = subModules.filter(sm => sm.moduleId === moduleId);
                moduleSubModules.forEach(subModule => {
                    allSubModuleIds.add(subModule._id);

                    // Get all topics under this submodule
                    const subModuleTopics = topics.filter(t => t.subModuleId === subModule._id);
                    subModuleTopics.forEach(topic => {
                        allTopicIds.add(topic._id);

                        // Get all subtopics under this topic
                        const topicSubTopics = subTopics.filter(st => st.topicId === topic._id);
                        topicSubTopics.forEach(subTopic => {
                            allSubTopicIds.add(subTopic._id);
                        });
                    });
                });

                // Get all topics directly under this module (without submodule)
                const moduleTopics = topics.filter(t => t.moduleId === moduleId && !t.subModuleId);
                moduleTopics.forEach(topic => {
                    allTopicIds.add(topic._id);

                    // Get all subtopics under this topic
                    const topicSubTopics = subTopics.filter(st => st.topicId === topic._id);
                    topicSubTopics.forEach(subTopic => {
                        allSubTopicIds.add(subTopic._id);
                    });
                });
            });
        } else if (type === 'submodule') {
            // For submodules, get all hierarchy under each selected submodule
            selectedIds.forEach(subModuleId => {
                const subModule = subModules.find(sm => sm._id === subModuleId);
                if (subModule) {
                    allModuleIds.add(subModule.moduleId);
                    allSubModuleIds.add(subModuleId);

                    // Get all topics under this submodule
                    const subModuleTopics = topics.filter(t => t.subModuleId === subModuleId);
                    subModuleTopics.forEach(topic => {
                        allTopicIds.add(topic._id);

                        // Get all subtopics under this topic
                        const topicSubTopics = subTopics.filter(st => st.topicId === topic._id);
                        topicSubTopics.forEach(subTopic => {
                            allSubTopicIds.add(subTopic._id);
                        });
                    });
                }
            });
        } else if (type === 'topic') {
            // For topics, get all hierarchy for each selected topic
            selectedIds.forEach(topicId => {
                const topic = topics.find(t => t._id === topicId);
                if (topic) {
                    allModuleIds.add(topic.moduleId);
                    if (topic.subModuleId) allSubModuleIds.add(topic.subModuleId);
                    allTopicIds.add(topicId);

                    // Get all subtopics under this topic
                    const topicSubTopics = subTopics.filter(st => st.topicId === topicId);
                    topicSubTopics.forEach(subTopic => {
                        allSubTopicIds.add(subTopic._id);
                    });
                }
            });
        } else if (type === 'subtopic') {
            // For subtopics, get all hierarchy for each selected subtopic
            selectedIds.forEach(subTopicId => {
                const subTopic = subTopics.find(st => st._id === subTopicId);
                if (subTopic) {
                    // allModuleIds.add(subTopic.moduleId);

                    // Add submodule ID if it exists (this was missing)
                    if (subTopic.subModuleId && !subTopic.subModuleId.includes('placeholder') &&
                        !subTopic.subModuleId.includes('none') && subTopic.subModuleId.trim() !== '') {
                        allSubModuleIds.add(subTopic.subModuleId);
                    }

                    allTopicIds.add(subTopic.topicId);
                    allSubTopicIds.add(subTopicId);

                    // Also get the complete hierarchy from the parent topic
                    const parentTopic = topics.find(t => t._id === subTopic.topicId);
                    if (parentTopic) {
                        // Add parent topic's module ID
                        allModuleIds.add(parentTopic.moduleId);

                        // Add parent topic's submodule ID if it exists
                        if (parentTopic.subModuleId && !parentTopic.subModuleId.includes('placeholder') &&
                            !parentTopic.subModuleId.includes('none') && parentTopic.subModuleId.trim() !== '') {
                            allSubModuleIds.add(parentTopic.subModuleId);
                        }
                    }
                }
            });
        }
        return {
            modules: Array.from(allModuleIds),
            subModules: Array.from(allSubModuleIds),
            topics: Array.from(allTopicIds),
            subTopics: Array.from(allSubTopicIds)
        };
    };
    // Add this function to collect hierarchy IDs for pedagogy deletion
    const collectPedagogyHierarchyIdsForDeletion = () => {
        const allModuleIds = new Set<string>();
        const allSubModuleIds = new Set<string>();
        const allTopicIds = new Set<string>();
        const allSubTopicIds = new Set<string>();

        // Add the hierarchy of the item being created/edited
        if (dialogType === 'module' && selectedModuleForSubModule) {
            allModuleIds.add(selectedModuleForSubModule.id);
        } else if (dialogType === 'submodule' && selectedModuleForSubModule) {
            allModuleIds.add(selectedModuleForSubModule.id);
            // Add submodule ID if it's being edited
            if (editMode?.type === 'submodule') {
                allSubModuleIds.add(editMode.data._id);
            }
        } else if (dialogType === 'topic' && selectedSubModuleForTopic) {
            allModuleIds.add(selectedSubModuleForTopic.moduleId);
            if (selectedSubModuleForTopic.id !== null) {
                allSubModuleIds.add(selectedSubModuleForTopic.id);
            }
            // Add topic ID if it's being edited
            if (editMode?.type === 'topic') {
                allTopicIds.add(editMode.data._id);
            }
        } else if (dialogType === 'subtopic' && selectedTopicForSubTopic) {
            allModuleIds.add(selectedTopicForSubTopic.moduleId);
            if (selectedTopicForSubTopic.subModuleId) {
                allSubModuleIds.add(selectedTopicForSubTopic.subModuleId);
            }
            if (selectedTopicForSubTopic.id !== null) {
                allTopicIds.add(selectedTopicForSubTopic.id);
            }
            // Add subtopic ID if it's being edited
            if (editMode?.type === 'subtopic') {
                allSubTopicIds.add(editMode.data._id);
            }
        }

        // Add merge selections for each activity type
        if (savedPedagogyMergeSelections && typeof savedPedagogyMergeSelections === "object") {
            Object?.entries(savedPedagogyMergeSelections).forEach(([activityType, activities]) => {
                Object.entries(activities).forEach(([activity, hierarchy]) => {
                    if (hierarchy) {
                        hierarchy.modules?.forEach(id => allModuleIds.add(id));
                        hierarchy.subModules?.forEach(id => allSubModuleIds.add(id));
                        hierarchy.topics?.forEach(id => allTopicIds.add(id));
                        hierarchy.subTopics?.forEach(id => allSubTopicIds.add(id));
                    }
                });
            });
        }

        return {
            modules: Array.from(allModuleIds),
            subModules: Array.from(allSubModuleIds),
            topics: Array.from(allTopicIds),
            subTopics: Array.from(allSubTopicIds)
        };
    };
    // Helper function to get element names for toast message
    const getElementNamesForToast = (dialogType: string, selectedIds: Set<string>) => {
        if (selectedIds.size === 0) return '';

        const elementNames: string[] = [];

        if (dialogType === 'module') {
            sortedModules.forEach(module => {
                if (selectedIds.has(module._id)) {
                    elementNames.push(module.title);
                }
            });
        } else if (dialogType === 'submodule') {
            sortedSubModules.forEach(subModule => {
                if (selectedIds.has(subModule._id)) {
                    elementNames.push(subModule.title);
                }
            });
        } else if (dialogType === 'topic') {
            sortedTopics.forEach(topic => {
                if (selectedIds.has(topic._id)) {
                    elementNames.push(topic.title);
                }
            });
        } else if (dialogType === 'subtopic') {
            sortedSubTopics.forEach(subTopic => {
                if (selectedIds.has(subTopic._id)) {
                    elementNames.push(subTopic.title);
                }
            });
        }

        // Return first 3 names + count if more
        if (elementNames.length <= 3) {
            return elementNames.join(', ');
        } else {
            return `${elementNames.slice(0, 3).join(', ')} and ${elementNames.length - 3} more`;
        }
    };
    // Update the save functions to use the hierarchy collection
    const saveLevelMergeSelections = () => {
        let hierarchyIds;

        if (dialogType === 'module') {
            hierarchyIds = collectCompleteHierarchyIds(selectedLevelModulesForMerge, 'module');
        } else if (dialogType === 'submodule') {
            hierarchyIds = collectCompleteHierarchyIds(selectedLevelSubModulesForMerge, 'submodule');
        } else if (dialogType === 'topic') {
            hierarchyIds = collectCompleteHierarchyIds(selectedLevelTopicsForMerge, 'topic');
        } else if (dialogType === 'subtopic') {
            hierarchyIds = collectCompleteHierarchyIds(selectedLevelSubTopicsForMerge, 'subtopic');
        }

        if (hierarchyIds) {
            setSavedLevelMergeSelections(hierarchyIds);
            setShowMergeLevelSection(false);
            // Show toast for level merge
            let selectedElementNames = '';
            let elementType = '';

            if (dialogType === 'module') {
                selectedElementNames = getElementNamesForToast('module', selectedLevelModulesForMerge);
                elementType = 'modules';
            } else if (dialogType === 'submodule') {
                selectedElementNames = getElementNamesForToast('submodule', selectedLevelSubModulesForMerge);
                elementType = 'submodules';
            } else if (dialogType === 'topic') {
                selectedElementNames = getElementNamesForToast('topic', selectedLevelTopicsForMerge);
                elementType = 'topics';
            } else if (dialogType === 'subtopic') {
                selectedElementNames = getElementNamesForToast('subtopic', selectedLevelSubTopicsForMerge);
                elementType = 'subtopics';
            }

            const message = selectedElementNames
                ? `Level saved with ${elementType}: ${selectedElementNames}`
                : `Level merge selection saved for ${elementType}`;

            toast.success(message, {
                duration: 4000,
                position: 'top-right',
            });
        }
    };

    const savePedagogyMergeSelections = (activityType: "iDo" | "weDo" | "youDo", activity: string) => {
        let hierarchyIds;
        const modulesForThisActivity = selectedPedagogyModulesForMerge[activityType]?.[activity] || new Set();
        const subModulesForThisActivity = selectedPedagogySubModulesForMerge[activityType]?.[activity] || new Set();
        const topicsForThisActivity = selectedPedagogyTopicsForMerge[activityType]?.[activity] || new Set();
        const subTopicsForThisActivity = selectedPedagogySubTopicsForMerge[activityType]?.[activity] || new Set();
        if (dialogType === 'module') {
            hierarchyIds = collectCompleteHierarchyIds(modulesForThisActivity, 'module');
        } else if (dialogType === 'submodule') {
            hierarchyIds = collectCompleteHierarchyIds(subModulesForThisActivity, 'submodule');
        } else if (dialogType === 'topic') {
            hierarchyIds = collectCompleteHierarchyIds(topicsForThisActivity, 'topic');
        } else if (dialogType === 'subtopic') {
            hierarchyIds = collectCompleteHierarchyIds(subTopicsForThisActivity, 'subtopic');
        }

        if (hierarchyIds) {
            setSavedPedagogyMergeSelections(prev => ({
                ...prev,
                [activityType]: {
                    ...prev[activityType],
                    [activity]: hierarchyIds
                }
            }));

            setShowMergePedagogySection(prev => ({
                ...prev,
                [activityType]: false
            }));
            // Show toast for pedagogy merge
            let selectedElementNames = '';
            let elementType = '';

            if (dialogType === 'module') {
                selectedElementNames = getElementNamesForToast('module', modulesForThisActivity);
                elementType = 'modules';
            } else if (dialogType === 'submodule') {
                selectedElementNames = getElementNamesForToast('submodule', subModulesForThisActivity);
                elementType = 'submodules';
            } else if (dialogType === 'topic') {
                selectedElementNames = getElementNamesForToast('topic', topicsForThisActivity);
                elementType = 'topics';
            } else if (dialogType === 'subtopic') {
                selectedElementNames = getElementNamesForToast('subtopic', subTopicsForThisActivity);
                elementType = 'subtopics';
            }

            const activityTypeDisplay = activityType === 'iDo' ? 'I Do' :
                activityType === 'weDo' ? 'We Do' : 'You Do';

            const message = selectedElementNames
                ? `${activityTypeDisplay} - ${activity} saved with ${elementType}: ${selectedElementNames}`
                : `${activityTypeDisplay} - ${activity} merge selection saved for ${elementType}`;

            toast.success(message, {
                duration: 4000,
                position: 'top-right',
            });
        }
    };
    const hasActualMergeSelection = (mergeSelection: any) => {
        if (!mergeSelection) return false;

        return (
            (mergeSelection.modules && mergeSelection.modules.length > 0) ||
            (mergeSelection.subModules && mergeSelection.subModules.length > 0) ||
            (mergeSelection.topics && mergeSelection.topics.length > 0) ||
            (mergeSelection.subTopics && mergeSelection.subTopics.length > 0)
        );
    };
    // Add this helper function to calculate level merge selection count excluding current element
    const getLevelMergeSelectionCount = () => {
        if (!savedLevelMergeSelections) return 0;

        const currentElementId = editMode?.data?._id;
        if (!currentElementId) {
            // For new elements (not edit mode), count all selections
            return savedLevelMergeSelections.modules.length +
                savedLevelMergeSelections.subModules.length +
                savedLevelMergeSelections.topics.length +
                savedLevelMergeSelections.subTopics.length;
        }

        // For edit mode, exclude the current element from the count
        let count = 0;

        if (dialogType === 'module') {
            count = savedLevelMergeSelections.modules.filter(id => id !== currentElementId).length;
        } else if (dialogType === 'submodule') {
            count = savedLevelMergeSelections.subModules.filter(id => id !== currentElementId).length;
        } else if (dialogType === 'topic') {
            count = savedLevelMergeSelections.topics.filter(id => id !== currentElementId).length;
        } else if (dialogType === 'subtopic') {
            count = savedLevelMergeSelections.subTopics.filter(id => id !== currentElementId).length;
        }

        return count;
    };
    // Update the edit functions to select the right items based on dialog type
    const editLevelMergeSelections = () => {
        if (savedLevelMergeSelections) {
            // Select the appropriate items based on dialog type AND pre-populate from saved data
            if (dialogType === 'module') {
                setSelectedLevelModulesForMerge(new Set(savedLevelMergeSelections.modules));
                // Also set other hierarchy levels if they exist in saved data
                setSelectedLevelSubModulesForMerge(new Set(savedLevelMergeSelections.subModules || []));
                setSelectedLevelTopicsForMerge(new Set(savedLevelMergeSelections.topics || []));
                setSelectedLevelSubTopicsForMerge(new Set(savedLevelMergeSelections.subTopics || []));
            } else if (dialogType === 'submodule') {
                setSelectedLevelSubModulesForMerge(new Set(savedLevelMergeSelections.subModules));
                setSelectedLevelModulesForMerge(new Set(savedLevelMergeSelections.modules || []));
                setSelectedLevelTopicsForMerge(new Set(savedLevelMergeSelections.topics || []));
                setSelectedLevelSubTopicsForMerge(new Set(savedLevelMergeSelections.subTopics || []));
            } else if (dialogType === 'topic') {
                setSelectedLevelTopicsForMerge(new Set(savedLevelMergeSelections.topics));
                setSelectedLevelModulesForMerge(new Set(savedLevelMergeSelections.modules || []));
                setSelectedLevelSubModulesForMerge(new Set(savedLevelMergeSelections.subModules || []));
                setSelectedLevelSubTopicsForMerge(new Set(savedLevelMergeSelections.subTopics || []));
            } else if (dialogType === 'subtopic') {
                setSelectedLevelSubTopicsForMerge(new Set(savedLevelMergeSelections.subTopics));
                setSelectedLevelModulesForMerge(new Set(savedLevelMergeSelections.modules || []));
                setSelectedLevelSubModulesForMerge(new Set(savedLevelMergeSelections.subModules || []));
                setSelectedLevelTopicsForMerge(new Set(savedLevelMergeSelections.topics || []));
            }

            setShowMergeLevelSection(true);
        }
    };

    const editPedagogyMergeSelections = (activityType: "iDo" | "weDo" | "youDo", activity: string) => {
        const savedSelections = savedPedagogyMergeSelections[activityType]?.[activity];

        if (savedSelections) {
            // Load the saved selections for this specific activity
            if (dialogType === 'module') {
                setSelectedPedagogyModulesForMerge(prev => ({
                    ...prev,
                    [activityType]: {
                        ...prev[activityType],
                        [activity]: new Set(savedSelections.modules)
                    }
                }));
            } else if (dialogType === 'submodule') {
                setSelectedPedagogySubModulesForMerge(prev => ({
                    ...prev,
                    [activityType]: {
                        ...prev[activityType],
                        [activity]: new Set(savedSelections.subModules)
                    }
                }));
            } else if (dialogType === 'topic') {
                setSelectedPedagogyTopicsForMerge(prev => ({
                    ...prev,
                    [activityType]: {
                        ...prev[activityType],
                        [activity]: new Set(savedSelections.topics)
                    }
                }));
            } else if (dialogType === 'subtopic') {
                setSelectedPedagogySubTopicsForMerge(prev => ({
                    ...prev,
                    [activityType]: {
                        ...prev[activityType],
                        [activity]: new Set(savedSelections.subTopics)
                    }
                }));
            }

            setShowMergePedagogySection(prev => ({
                ...prev,
                [activityType]: true
            }));

            setCurrentMergeActivity(activity);
        }
    };

    const calculateSectionTotal = (type: "iDo" | "weDo" | "youDo", activities: any) => {
        return activities.reduce((sum: number, activity: string) => {
            return sum + calculateTotalHours(type, activity);
        }, 0);
    };
    const calculateTotalHours = (type: "iDo" | "weDo" | "youDo", activity: string) => {
        // Calculate merged values
        const columnKey = `${type}-${activity}`;
        const mergedValue = mergedCells[columnKey]?.reduce((sum, merge) => sum + merge.value, 0) || 0;

        // Calculate unmerged values
        const unmergedValue = Object.values(courseHours).reduce((sum, module) => {
            return sum + Object.values(module).reduce((moduleSum, topic) => {
                return moduleSum + Object.values(topic).reduce((topicSum, subtopic) => {
                    // Skip if this subtopic is in any merged cell for this activity
                    const isMerged = mergedCells[columnKey]?.some(merge =>
                        merge.hierarchyIds?.subTopics?.includes((subtopic as any)?.subtopicId) ||
                        merge.hierarchyIds?.topics?.includes((topic as any)?.topicId) ||
                        merge.hierarchyIds?.subModules?.includes((topic as any)?.subModuleId) ||
                        merge.hierarchyIds?.modules?.includes((module as any)?.moduleId)
                    );

                    if (!isMerged && subtopic[type]?.[activity]) {
                        return topicSum + (subtopic[type][activity] || 0);
                    }
                    return topicSum;
                }, 0);
            }, 0);
        }, 0);

        return mergedValue + unmergedValue;
    };

    const handleModuleFormChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
        const { name, value } = e.target;
        setModuleFormData(prev => ({
            ...prev,
            [name]: value
        }));
    };
    const handleSubModuleFormChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
        const { name, value } = e.target;
        setSubModuleFormData(prev => ({
            ...prev,
            [name]: value
        }));
    };
    const handleTopicFormChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
        const { name, value } = e.target;
        setTopicFormData(prev => ({
            ...prev,
            [name]: value
        }));
    };
    const handleSubTopicFormChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
        const { name, value } = e.target;
        setSubTopicFormData(prev => ({
            ...prev,
            [name]: value
        }));
    };

    const handleModuleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();

        if (!selectedCourse || !token) return;

        setIsCreatingModule(true);
        const alreadyDeletedLevels = new Set<string>();
        const alreadyDeletedPedagogyItems = new Set<string>();
        try {
            let moduleIdToUnmerge = null;
            let newModule: any;
            if (!addOnlyPedagogyLevel) {
                if (editMode?.type === 'module') {
                    moduleIdToUnmerge = editMode.data._id;
                    await updateModuleMutation.mutateAsync({
                        id: editMode.data._id,
                        data: {
                            ...moduleFormData,
                            courses: selectedCourse._id
                        }
                    });
                } else {
                    // Calculate next index based on existing modules
                    const nextIndex = modules.length > 0
                        ? Math.max(...modules.map(m => m.index || 0)) + 1
                        : 0;

                    newModule = await createModuleMutation.mutateAsync({
                        ...moduleFormData,
                        index: nextIndex,
                        courses: selectedCourse._id,
                        institution: ""
                    });
                    moduleIdToUnmerge = newModule.module._id;
                }
            }

            if (showLevelSection && selectedLevel) {

                let levelData: any;

                if (editMode?.type === 'module' && editingExistingLevelData) {
                    // UPDATE EXISTING LEVEL DATA - Delete old and create new
                    // First delete the existing level
                    if (editingExistingLevelData._id) {
                        await deleteLevelMutation.mutateAsync(editingExistingLevelData._id);
                    }

                    // Then create new level data with updated values
                    levelData = {
                        level: selectedLevel,
                        module: savedLevelMergeSelections?.modules || [
                            editMode?.type === 'module' ? editMode.data._id : newModule.module._id
                        ],
                        subModule: savedLevelMergeSelections?.subModules || [],
                        topic: savedLevelMergeSelections?.topics || [],
                        subTopic: savedLevelMergeSelections?.subTopics || []
                    };

                    await levelViewMutation.mutateAsync({
                        courses: selectedCourse._id,
                        levels: [...levelsData.filter((l: any) => l._id !== editingExistingLevelData._id), levelData]
                    });
                } else {
                    // CREATE NEW LEVEL DATA (existing logic remains the same)
                    levelData = {
                        level: selectedLevel,
                        module: [editMode?.type === 'module' ? editMode.data._id : newModule.module._id]
                    };
                    // If merging with other modules, include their hierarchy too
                    if (savedLevelMergeSelections) {
                        levelData.module = [...levelData.module, ...savedLevelMergeSelections.modules];
                    }
                    // If merging with other modules manually, include their hierarchy too
                    else if (showMergeLevelSection && selectedLevelModulesForMerge.size > 0) {
                        const selectedModulesData = modules.filter(m => selectedLevelModulesForMerge.has(m._id));

                        // Collect all hierarchy IDs from selected modules
                        const allModuleIds = new Set([newModule.module._id]);

                        selectedModulesData.forEach(module => {
                            allModuleIds.add(module._id);
                        });

                        // Update level data with all hierarchy IDs
                        levelData.module = Array.from(allModuleIds);
                    }

                    await levelViewMutation.mutateAsync({
                        courses: selectedCourse._id,
                        levels: [...levelsData, levelData]
                    });
                }
            } else if (editMode?.type === 'module' && editingExistingLevelData) {
                // If level section is unchecked during edit, remove the level data
                if (editingExistingLevelData._id) {
                    await deleteLevelMutation.mutateAsync(editingExistingLevelData._id);
                }
            }

            // Process pedagogy data if needed
            const hasPedagogyData = Object.keys(pedagogyHours).some(type =>
                Object.keys(pedagogyHours[type as keyof typeof pedagogyHours]).some(
                    activity => (pedagogyHours[type as keyof typeof pedagogyHours][activity] || 0) > 0
                )
            );

            if (showPedagogySection && hasPedagogyData) {
                const hierarchyLevels = selectedCourse.courseHierarchy.map(l => l.toLowerCase());

                // First, remove ALL pedagogy data containing the editing element ID
                if (editMode?.type === 'module') {
                    const hierarchyIdsForDeletion = {
                        modules: [editMode.data._id]
                    };

                    await checkAndDeleteExistingPedagogyDataForSelectedActivities(
                        hierarchyIdsForDeletion,
                        alreadyDeletedPedagogyItems,
                        false // Don't preserve - we want to replace the editing item's pedagogy
                    );
                }
                if (showPedagogySection && editMode) {
                    for (const activityType of ["iDo", "weDo", "youDo"] as const) {
                        for (const activity of selectedPedagogyActivities[activityType]) {
                            if (savedPedagogyMergeSelections[activityType]?.[activity]) {
                                await deleteSingleCellValuesForMerge(
                                    editMode.data._id,
                                    activityType,
                                    activity
                                );
                            }
                        }
                    }
                }
                // Now, save ALL pedagogy values from the current form
                const pedagogyDataFromForm: any[] = [];

                (["iDo", "weDo", "youDo"] as const).forEach(activityType => {
                    selectedPedagogyActivities[activityType]
                        .filter(activity => (pedagogyHours[activityType][activity] || 0) > 0)
                        .forEach(activity => {
                            const activityDuration = pedagogyHours[activityType][activity] || 0;
                            let baseHierarchy: any = {};

                            // Original logic
                            baseHierarchy = {
                                // Include parent hierarchy based on dialog type
                                ...(hierarchyLevels.includes('module') && {
                                    module: [editMode?.type === 'module' ? editMode.data._id : newModule?.module._id]
                                })
                            };

                            // Filter out empty arrays
                            Object.keys(baseHierarchy).forEach(key => {
                                if (Array.isArray(baseHierarchy[key]) && baseHierarchy[key].length === 0) {
                                    delete baseHierarchy[key];
                                }
                            });

                            // Check if this activity has specific merge selections
                            const activityMerge = savedPedagogyMergeSelections[activityType]?.[activity];

                            if (activityMerge) {
                                // Create a merged pedagogy entry with combined hierarchy
                                const mergedHierarchy: any = {
                                    [activityType]: [{ type: activity, duration: activityDuration }]
                                };

                                // Combine base hierarchy with merge hierarchy
                                if (baseHierarchy.module || activityMerge.modules.length > 0) {
                                    mergedHierarchy.module = [...new Set([
                                        ...(baseHierarchy.module || []),
                                        ...activityMerge.modules
                                    ])];
                                }

                                pedagogyDataFromForm.push(mergedHierarchy);
                            } else {
                                // Create a regular pedagogy entry with just the base hierarchy
                                const regularHierarchy: any = {
                                    ...baseHierarchy,
                                    [activityType]: [{ type: activity, duration: activityDuration }]
                                };

                                pedagogyDataFromForm.push(regularHierarchy);
                            }
                        });
                });

                // Save ALL pedagogy data from the form
                if (pedagogyDataFromForm.length > 0) {
                    // Get existing pedagogy data that doesn't contain the editing element
                    const existingPedagogyWithoutEditingItem = pedagogyViews?.[0]?.pedagogies?.filter((pedagogy: any) => {
                        const containsEditingItem =
                            (editMode?.type === 'module' && pedagogy.module?.includes(editMode.data._id));
                        return !containsEditingItem;
                    }) || [];

                    // Combine existing pedagogy (without editing item) with new form data
                    const allPedagogyData = [...existingPedagogyWithoutEditingItem, ...pedagogyDataFromForm];

                    await pedagogyMutation.mutateAsync({
                        courses: selectedCourse._id,
                        pedagogies: allPedagogyData
                    });
                } else {
                    // If no pedagogy data in form, remove all pedagogy containing the editing item
                    const existingPedagogyWithoutEditingItem = pedagogyViews?.[0]?.pedagogies?.filter((pedagogy: any) => {
                        const containsEditingItem =
                            (editMode?.type === 'module' && pedagogy.module?.includes(editMode.data._id));
                        return !containsEditingItem;
                    }) || [];

                    await pedagogyMutation.mutateAsync({
                        courses: selectedCourse._id,
                        pedagogies: existingPedagogyWithoutEditingItem
                    });
                }
            } else if (editMode?.type === 'module') {
                // If pedagogy section is unchecked during edit, remove all pedagogy data for this module
                const hierarchyIdsForDeletion = {
                    modules: [editMode.data._id]
                };

                await checkAndDeleteExistingPedagogyData(
                    hierarchyIdsForDeletion,
                    alreadyDeletedPedagogyItems,
                    false
                );

                // Remove from local state as well
                const existingPedagogyWithoutEditingItem = pedagogyViews?.[0]?.pedagogies?.filter((pedagogy: any) => {
                    const containsEditingItem =
                        (editMode?.type === 'module' && pedagogy.module?.includes(editMode.data._id));
                    return !containsEditingItem;
                }) || [];

                await pedagogyMutation.mutateAsync({
                    courses: selectedCourse._id,
                    pedagogies: existingPedagogyWithoutEditingItem
                });
            }

            const selectedLevelModulesData = modules.filter(m => selectedLevelModulesForMerge.has(m._id));

            // Collect hierarchy IDs ONLY from selected merge modules (excluding the current module)
            const allModuleIds = new Set<string>();

            // Add the current module being edited/created
            if (editMode?.type === 'module') {
                allModuleIds.add(editMode.data._id);
            } else if (newModule) {
                allModuleIds.add(newModule.module._id);
            }

            // Add selected merge modules and their hierarchy
            selectedLevelModulesData.forEach(module => {
                allModuleIds.add(module._id);
            });

            const hierarchyIds = {
                modules: Array.from(allModuleIds)
            };

            // Check and delete existing level data only for selected items
            await checkAndDeleteExistingLevelData(
                hierarchyIds,
                alreadyDeletedLevels,
                true, // preserve editing item
                editMode?.type === 'module' ? editMode.data._id : newModule?.module._id
            );

            // Check and delete existing pedagogy data only for selected activity types and items
            const pedagogyHierarchyIds = collectPedagogyHierarchyIdsForDeletion();

            await checkAndDeleteExistingPedagogyDataForSelectedActivities(
                pedagogyHierarchyIds,
                alreadyDeletedPedagogyItems,
                true, // preserve editing item
                editMode?.type === 'module' ? editMode.data._id : newModule?.module._id
            );

            // Check and delete existing merged cells
            checkAndDeleteExistingMergedCells(hierarchyIds);

            await fetchModulesForCourse();

            setShowDialog(false);
            setModuleFormData({
                title: '',
                description: '',
                level: 'Easy',
                duration: 0,
                index: 0
            });
            setEditMode(null);
            resetAllFormStates();
            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 2000);
        } catch (error) {
            console.error("Failed to create/update module:", error);
        } finally {
            setIsCreatingModule(false);
        }
    };

    const handleSubModuleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!selectedModuleForSubModule || !selectedCourse || !token) return;
        setIsCreatingSubModule(true);
        const alreadyDeletedLevels = new Set<string>();
        const alreadyDeletedPedagogyItems = new Set<string>();
        try {
            let subModuleIdToUnmerge = null;
            let newSubModule: any;
            if (!addOnlyPedagogyLevel) {
                if (editMode?.type === 'submodule') {
                    const subModuleIdToUnmerge = editMode.data._id;
                    await updateSubModuleMutation.mutateAsync({
                        id: editMode.data._id,
                        data: {
                            ...subModuleFormData,
                            moduleId: selectedModuleForSubModule.id,
                            courses: selectedCourse._id,
                            index: editMode.data.index
                        }
                    });

                } else {
                    const moduleSubModules = subModules.filter(sub => sub.moduleId === selectedModuleForSubModule.id);
                    const nextIndex = moduleSubModules.length > 0
                        ? Math.max(...moduleSubModules.map(t => t.index ?? 0)) + 1
                        : 0;

                    newSubModule = await createSubModuleMutation.mutateAsync({
                        ...subModuleFormData,
                        moduleId: selectedModuleForSubModule.id,
                        courses: selectedCourse._id,
                        index: nextIndex
                    });

                    const moduleIdToUnmerge = selectedModuleForSubModule.id;

                }
            }

            if (showLevelSection && selectedLevel) {
                const hierarchyLevels = selectedCourse.courseHierarchy.map(l => l.toLowerCase());
                const hasTopics = hierarchyLevels.includes('topic');
                const hasSubTopics = hierarchyLevels.includes('sub topic');

                let levelData: any;

                if (editMode?.type === 'submodule' && editingExistingLevelData) {
                    // UPDATE EXISTING LEVEL DATA
                    levelData = {
                        _id: editingExistingLevelData._id,
                        level: selectedLevel,
                        module: savedLevelMergeSelections?.modules || [],
                        subModule: savedLevelMergeSelections?.subModules || [],
                        topic: savedLevelMergeSelections?.topics || [],
                        subTopic: savedLevelMergeSelections?.subTopics || []
                    };

                    // Ensure the editing item is always included
                    if (!levelData.module?.includes(editMode.data._id)) {
                        levelData.module = [...(levelData.module || []), editMode.data._id];
                    }

                    // Update the level in the database - replace the entire entry
                    const updatedLevels = levelsData.map((level: any) =>
                        level._id === editingExistingLevelData._id ? levelData : level
                    );

                    await levelViewMutation.mutateAsync({
                        courses: selectedCourse._id,
                        levels: updatedLevels
                    });
                } else {
                    // CREATE NEW LEVEL DATA
                    levelData = {
                        level: selectedLevel,
                    };

                    if (addOnlyPedagogyLevel) {
                        // Use all selected hierarchy IDs from merge selections
                        const allIds = getAllSelectedHierarchyIds('level');
                        if (allIds.modules.length > 0) levelData.module = allIds.modules;
                        if (hierarchyLevels.includes('sub module') && allIds.subModules.length > 0) levelData.subModule = allIds.subModules;
                        if (hasTopics && allIds.topics.length > 0) levelData.topic = allIds.topics;
                        if (hasSubTopics && allIds.subTopics.length > 0) levelData.subTopic = allIds.subTopics;
                    } else {
                        // Original logic for creating with hierarchy
                        levelData = {
                            ...levelData,
                            // Include parent module and newly created submodule
                            ...(hierarchyLevels.includes('module') && {
                                module: [selectedModuleForSubModule.id]
                            }),
                            ...(hierarchyLevels.includes('sub module') && {
                                subModule: [editMode?.type === 'submodule' ? editMode.data._id : newSubModule?.subModule._id]
                            })
                        };
                    }

                    // If merging with other submodules, include their hierarchy too
                    if (savedLevelMergeSelections) {
                        levelData.module = [...levelData.module, ...savedLevelMergeSelections.modules];
                        levelData.subModule = [...levelData.subModule, ...savedLevelMergeSelections.subModules];

                        if (hasTopics && savedLevelMergeSelections.topics.length > 0) {
                            levelData.topic = savedLevelMergeSelections.topics;
                        }

                        if (hasSubTopics && savedLevelMergeSelections.subTopics.length > 0) {
                            levelData.subTopic = savedLevelMergeSelections.subTopics;
                        }
                    }

                    await levelViewMutation.mutateAsync({
                        courses: selectedCourse._id,
                        levels: [...levelsData, levelData]
                    });
                }
            } else if (editMode?.type === 'submodule' && editingExistingLevelData) {
                // If level section is unchecked during edit, remove the level data
                if (editingExistingLevelData._id) {
                    await deleteLevelMutation.mutateAsync(editingExistingLevelData._id);
                }
            }

            // Process pedagogy data if needed
            const hasPedagogyData = Object.keys(pedagogyHours).some(type =>
                Object.keys(pedagogyHours[type as keyof typeof pedagogyHours]).some(
                    activity => (pedagogyHours[type as keyof typeof pedagogyHours][activity] || 0) > 0
                )
            );

            if (showPedagogySection && hasPedagogyData) {
                const hierarchyLevels = selectedCourse.courseHierarchy.map(l => l.toLowerCase());
                const hasSubModules = hierarchyLevels.includes('sub module');
                const hasTopics = hierarchyLevels.includes('topic');
                const hasSubTopics = hierarchyLevels.includes('sub topic');

                // First, remove ALL pedagogy data containing the editing element ID
                if (editMode?.type === 'submodule') {
                    const hierarchyIdsForDeletion = {
                        subModules: [editMode.data._id]
                    };

                    await checkAndDeleteExistingPedagogyData(
                        hierarchyIdsForDeletion,
                        alreadyDeletedPedagogyItems
                    );
                }
                if (showPedagogySection && editMode) {
                    for (const activityType of ["iDo", "weDo", "youDo"] as const) {
                        for (const activity of selectedPedagogyActivities[activityType]) {
                            if (savedPedagogyMergeSelections[activityType]?.[activity]) {
                                await deleteSingleCellValuesForMerge(
                                    editMode.data._id,
                                    activityType,
                                    activity
                                );
                            }
                        }
                    }
                }
                // Now, save ALL pedagogy values from the current form
                const pedagogyDataFromForm: any[] = [];

                (["iDo", "weDo", "youDo"] as const).forEach(activityType => {
                    selectedPedagogyActivities[activityType]
                        .filter(activity => (pedagogyHours[activityType][activity] || 0) > 0)
                        .forEach(activity => {
                            const activityDuration = pedagogyHours[activityType][activity] || 0;
                            let baseHierarchy: any = {};

                            if (addOnlyPedagogyLevel) {
                                // Use all selected hierarchy IDs from merge selections
                                const allIds = getAllSelectedHierarchyIds('pedagogy');
                                if (allIds.modules.length > 0) baseHierarchy.module = allIds.modules;
                                if (hasSubModules && allIds.subModules.length > 0) baseHierarchy.subModule = allIds.subModules;
                                if (hasTopics && allIds.topics.length > 0) baseHierarchy.topic = allIds.topics;
                                if (hasSubTopics && allIds.subTopics.length > 0) baseHierarchy.subTopic = allIds.subTopics;
                            } else {
                                // Original logic
                                baseHierarchy = {
                                    // Include parent hierarchy based on dialog type
                                    ...(hierarchyLevels.includes('module') && {
                                        module: [selectedModuleForSubModule?.id]
                                    }),
                                    ...(hasSubModules && {
                                        subModule: [editMode?.type === 'submodule' ? editMode.data._id : newSubModule?.subModule._id]
                                    })
                                };
                            }

                            // Filter out empty arrays
                            Object.keys(baseHierarchy).forEach(key => {
                                if (Array.isArray(baseHierarchy[key]) && baseHierarchy[key].length === 0) {
                                    delete baseHierarchy[key];
                                }
                            });

                            // Check if this activity has specific merge selections
                            const activityMerge = savedPedagogyMergeSelections[activityType]?.[activity];

                            if (activityMerge) {
                                // Create a merged pedagogy entry with combined hierarchy
                                const mergedHierarchy: any = {
                                    [activityType]: [{ type: activity, duration: activityDuration }]
                                };

                                // Combine base hierarchy with merge hierarchy
                                if (baseHierarchy.module || activityMerge.modules.length > 0) {
                                    mergedHierarchy.module = [...new Set([
                                        ...(baseHierarchy.module || []),
                                        ...activityMerge.modules
                                    ])];
                                }

                                if (hasSubModules && (baseHierarchy.subModule || activityMerge.subModules.length > 0)) {
                                    mergedHierarchy.subModule = [...new Set([
                                        ...(baseHierarchy.subModule || []),
                                        ...activityMerge.subModules
                                    ])];
                                }

                                if (hasTopics && (baseHierarchy.topic || activityMerge.topics.length > 0)) {
                                    mergedHierarchy.topic = [...new Set([
                                        ...(baseHierarchy.topic || []),
                                        ...activityMerge.topics
                                    ])];
                                }

                                if (hasSubTopics && (baseHierarchy.subTopic || activityMerge.subTopics.length > 0)) {
                                    mergedHierarchy.subTopic = [...new Set([
                                        ...(baseHierarchy.subTopic || []),
                                        ...activityMerge.subTopics
                                    ])];
                                }

                                pedagogyDataFromForm.push(mergedHierarchy);
                            } else {
                                // Create a regular pedagogy entry with just the base hierarchy
                                const regularHierarchy: any = {
                                    ...baseHierarchy,
                                    [activityType]: [{ type: activity, duration: activityDuration }]
                                };

                                pedagogyDataFromForm.push(regularHierarchy);
                            }
                        });
                });

                // Save ALL pedagogy data from the form
                if (pedagogyDataFromForm.length > 0) {
                    // Get existing pedagogy data that doesn't contain the editing element
                    const existingPedagogyWithoutEditingItem = pedagogyViews?.[0]?.pedagogies?.filter((pedagogy: any) => {
                        const containsEditingItem =
                            (editMode?.type === 'submodule' && pedagogy.subModule?.includes(editMode.data._id));
                        return !containsEditingItem;
                    }) || [];

                    // Combine existing pedagogy (without editing item) with new form data
                    const allPedagogyData = [...existingPedagogyWithoutEditingItem, ...pedagogyDataFromForm];

                    await pedagogyMutation.mutateAsync({
                        courses: selectedCourse._id,
                        pedagogies: allPedagogyData
                    });
                } else {
                    // If no pedagogy data in form, remove all pedagogy containing the editing item
                    const existingPedagogyWithoutEditingItem = pedagogyViews?.[0]?.pedagogies?.filter((pedagogy: any) => {
                        const containsEditingItem =
                            (editMode?.type === 'submodule' && pedagogy.subModule?.includes(editMode.data._id));
                        return !containsEditingItem;
                    }) || [];

                    await pedagogyMutation.mutateAsync({
                        courses: selectedCourse._id,
                        pedagogies: existingPedagogyWithoutEditingItem
                    });
                }
            } else if (editMode?.type === 'submodule') {
                // If pedagogy section is unchecked during edit, remove all pedagogy data for this submodule
                const hierarchyIdsForDeletion = {
                    subModules: [editMode.data._id]
                };

                await checkAndDeleteExistingPedagogyData(
                    hierarchyIdsForDeletion,
                    alreadyDeletedPedagogyItems,
                    false
                );

                // Remove from local state as well
                const existingPedagogyWithoutEditingItem = pedagogyViews?.[0]?.pedagogies?.filter((pedagogy: any) => {
                    const containsEditingItem =
                        (editMode?.type === 'submodule' && pedagogy.subModule?.includes(editMode.data._id));
                    return !containsEditingItem;
                }) || [];

                await pedagogyMutation.mutateAsync({
                    courses: selectedCourse._id,
                    pedagogies: existingPedagogyWithoutEditingItem
                });
            }
            // Add this right after creating the submodule but BEFORE processing level/pedagogy data
            if (!addOnlyPedagogyLevel) {
                // Get all selected submodules for merging
                const selectedLevelSubModulesData = subModules.filter(sm => selectedLevelSubModulesForMerge.has(sm._id));
                // Track already deleted items to prevent duplicate deletion


                const parentModuleIds = new Set([selectedModuleForSubModule.id]);

                const hierarchyIdsForModuleDeletion = {
                    modules: Array.from(parentModuleIds),
                    subModules: [],
                    topics: [],
                    subTopics: []
                };

                // Check and delete existing data for all selected items
                await checkAndDeleteExistingPedagogyData(
                    hierarchyIdsForModuleDeletion,
                    alreadyDeletedPedagogyItems,
                    editMode?.type === 'submodule', // preserve editing item if we're in edit mode
                    editMode?.data?._id // editing item ID
                );
                await checkAndDeleteExistingLevelData(
                    hierarchyIdsForModuleDeletion,
                    alreadyDeletedLevels,
                    editMode?.type === 'submodule', // preserve editing item if we're in edit mode
                    editMode?.data?._id // editing item ID
                );
                checkAndDeleteExistingMergedCells(hierarchyIdsForModuleDeletion);

                // Collect hierarchy IDs for LEVEL deletion (only from level selections)
                const levelHierarchyIds = {
                    modules: new Set([selectedModuleForSubModule.id]),
                    subModules: new Set([editMode?.type === 'submodule' ? editMode.data._id : newSubModule?.subModule._id]),
                    topics: new Set<string>(),
                    subTopics: new Set<string>()
                };

                selectedLevelSubModulesData.forEach(subModule => {
                    levelHierarchyIds.modules.add(subModule.moduleId);
                    levelHierarchyIds.subModules.add(subModule._id);

                    // Get all topics under selected submodules for level deletion
                    const subModuleTopics = topics.filter(t => t.subModuleId === subModule._id);
                    subModuleTopics.forEach(topic => {
                        levelHierarchyIds.topics.add(topic._id);

                        // Get all subtopics under these topics
                        const topicSubTopics = subTopics.filter(st => st.topicId === topic._id);
                        topicSubTopics.forEach(subTopic => {
                            levelHierarchyIds.subTopics.add(subTopic._id);
                        });
                    });
                });

                // Collect hierarchy IDs for PEDAGOGY deletion (only from pedagogy selections)




                // Convert Sets to Arrays for the deletion functions
                const levelIdsForDeletion = {
                    modules: Array.from(levelHierarchyIds.modules),
                    subModules: Array.from(levelHierarchyIds.subModules),
                    topics: Array.from(levelHierarchyIds.topics),
                    subTopics: Array.from(levelHierarchyIds.subTopics)
                };



                // Check and delete existing LEVEL data for level selections only
                await checkAndDeleteExistingLevelData(levelIdsForDeletion, alreadyDeletedLevels, editMode?.type === 'submodule',
                    editMode?.data?._id);

                // Check and delete existing PEDAGOGY data for pedagogy selections only
                const pedagogyHierarchyIds = collectPedagogyHierarchyIdsForDeletion();

                await checkAndDeleteExistingPedagogyDataForSelectedActivities(
                    pedagogyHierarchyIds,
                    alreadyDeletedPedagogyItems,
                    editMode?.type === 'submodule', // preserve editing item if we're in edit mode
                    editMode?.data?._id // editing item ID
                );

                // Check and delete existing merged cells for BOTH level and pedagogy selections
                const mergedCellsHierarchyIds = {
                    modules: Array.from(new Set([...levelHierarchyIds.modules, ...pedagogyHierarchyIds.modules])),
                    subModules: Array.from(new Set([...levelHierarchyIds.subModules, ...pedagogyHierarchyIds.subModules])),
                    topics: Array.from(new Set([...levelHierarchyIds.topics, ...pedagogyHierarchyIds.topics])),
                    subTopics: Array.from(new Set([...levelHierarchyIds.subTopics, ...pedagogyHierarchyIds.subTopics]))
                };

                checkAndDeleteExistingMergedCells(mergedCellsHierarchyIds);
            } else {
                // DELETE LOGIC FOR ADD ONLY PEDAGOGY/LEVEL MODE
                // Get all selected hierarchy IDs for deletion
                const hierarchyIds = getAllSelectedHierarchyIds('pedagogy');

                // Track already deleted items to prevent duplicate deletion
                const alreadyDeletedLevels = new Set<string>();
                const alreadyDeletedPedagogyItems = new Set<string>();

                // Check and delete existing level data
                if (showLevelSection && selectedLevel) {
                    await checkAndDeleteExistingLevelData(hierarchyIds, alreadyDeletedLevels, false);
                }

                // Check and delete existing pedagogy data for selected activities
                await checkAndDeleteExistingPedagogyDataForSelectedActivities(
                    hierarchyIds,
                    alreadyDeletedPedagogyItems, false
                );

                // Check and delete existing merged cells
                checkAndDeleteExistingMergedCells(hierarchyIds);
            }

            await fetchModulesForCourse();
            await refetchSubModules();
            setShowDialog(false);
            setSubModuleFormData({
                title: '',
                description: '',
                level: 'Easy',
                duration: 0
            });

            setEditMode(null);
            resetAllFormStates();
            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 2000);
        } catch (error) {
            console.error("Failed to create/update submodule:", error);
        } finally {
            setIsCreatingSubModule(false);
        }
    };

    const handleTopicSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!selectedSubModuleForTopic || !selectedCourse || !token) return;
        setIsCreatingTopic(true);
        const alreadyDeletedLevels = new Set<string>();
        const alreadyDeletedPedagogyItems = new Set<string>();
        try {
            // Check if submodule is in course hierarchy
            const hierarchyLevels = selectedCourse.courseHierarchy.map(level => level.toLowerCase());
            const hasSubModules = hierarchyLevels.includes('sub module');
            const hasSubTopics = hierarchyLevels.includes('sub topic');

            const topicData: any = {
                ...topicFormData,
                moduleId: selectedSubModuleForTopic.moduleId,
                courses: selectedCourse._id,
                // Only include subModuleId if submodules are in the hierarchy
                ...(hasSubModules && { subModuleId: selectedSubModuleForTopic.id })
            };

            let topicIdToUnmerge: any = null;
            let newTopic: any;
            if (!addOnlyPedagogyLevel) {
                if (editMode?.type === 'topic') {
                    topicIdToUnmerge = editMode.data._id;
                    await updateTopicMutation.mutateAsync({
                        id: editMode.data._id,
                        data: {
                            ...topicData,
                            index: editMode.data.index
                        }
                    });

                } else {
                    const subModuleTopics = topics.filter(topic => topic.subModuleId === selectedSubModuleForTopic.id);
                    const nextIndex = subModuleTopics.length > 0
                        ? Math.max(...subModuleTopics.map(t => t.index ?? 0)) + 1
                        : 0;

                    newTopic = await createTopicMutation.mutateAsync({
                        ...topicData,
                        subModuleId: selectedSubModuleForTopic.id,
                        moduleId: selectedSubModuleForTopic.moduleId,
                        index: nextIndex
                    });
                    topicIdToUnmerge = newTopic.topic._id;
                }
            }

            // Save level data if level section is shown
            if (showLevelSection && selectedLevel) {
                let levelData: any;

                if (editMode?.type === 'topic' && editingExistingLevelData) {
                    // UPDATE EXISTING LEVEL DATA
                    levelData = {
                        _id: editingExistingLevelData._id,
                        level: selectedLevel,
                        module: savedLevelMergeSelections?.modules || [],
                        subModule: savedLevelMergeSelections?.subModules || [],
                        topic: savedLevelMergeSelections?.topics || [],
                        subTopic: savedLevelMergeSelections?.subTopics || []
                    };

                    // Ensure the editing item is always included
                    if (!levelData.module?.includes(editMode.data._id)) {
                        levelData.module = [...(levelData.module || []), editMode.data._id];
                    }

                    // Update the level in the database - replace the entire entry
                    const updatedLevels = levelsData.map((level: any) =>
                        level._id === editingExistingLevelData._id ? levelData : level
                    );

                    await levelViewMutation.mutateAsync({
                        courses: selectedCourse._id,
                        levels: updatedLevels
                    });
                } else {
                    // CREATE NEW LEVEL DATA
                    levelData = {
                        level: selectedLevel,
                    };

                    if (addOnlyPedagogyLevel) {
                        // Use all selected hierarchy IDs from merge selections
                        const allIds = getAllSelectedHierarchyIds('level');
                        if (allIds.modules.length > 0) levelData.module = allIds.modules;
                        if (hasSubModules && allIds.subModules.length > 0) levelData.subModule = allIds.subModules;
                        if (hierarchyLevels.includes('topic') && allIds.topics.length > 0) levelData.topic = allIds.topics;
                        if (hasSubTopics && allIds.subTopics.length > 0) levelData.subTopic = allIds.subTopics;
                    } else {
                        // Original logic for creating with hierarchy
                        levelData = {
                            ...levelData,
                            // Include parent module
                            ...(hierarchyLevels.includes('module') && {
                                module: [selectedSubModuleForTopic.moduleId]
                            }),
                            // Include parent submodule if it exists in hierarchy
                            ...(hasSubModules && {
                                subModule: [selectedSubModuleForTopic.id]
                            }),
                            // Include newly created topic
                            ...(hierarchyLevels.includes('topic') && {
                                topic: [editMode?.type === 'topic' ? editMode.data._id : newTopic.topic._id]
                            })
                        };

                        // If merging with other topics, include their complete hierarchy
                        if (savedLevelMergeSelections) {
                            levelData.module = [...levelData.module, ...savedLevelMergeSelections.modules];

                            if (hasSubModules) {
                                levelData.subModule = [...levelData.subModule, ...savedLevelMergeSelections.subModules];
                            }

                            levelData.topic = [...levelData.topic, ...savedLevelMergeSelections.topics];

                            if (hasSubTopics && savedLevelMergeSelections.subTopics.length > 0) {
                                levelData.subTopic = savedLevelMergeSelections.subTopics;
                            }
                        }
                    }

                    await levelViewMutation.mutateAsync({
                        courses: selectedCourse._id,
                        levels: [...levelsData, levelData]
                    });
                }
            } else if (editMode?.type === 'topic' && editingExistingLevelData) {
                // If level section is unchecked during edit, remove the level data
                if (editingExistingLevelData._id) {
                    await deleteLevelMutation.mutateAsync(editingExistingLevelData._id);
                }
            }

            // Process pedagogy data if needed
            const hasPedagogyData = Object.keys(pedagogyHours).some(type =>
                Object.keys(pedagogyHours[type as keyof typeof pedagogyHours]).some(
                    activity => (pedagogyHours[type as keyof typeof pedagogyHours][activity] || 0) > 0
                )
            );

            if (showPedagogySection && hasPedagogyData) {
                const hierarchyLevels = selectedCourse.courseHierarchy.map(l => l.toLowerCase());
                const hasSubModules = hierarchyLevels.includes('sub module');
                const hasTopics = hierarchyLevels.includes('topic');
                const hasSubTopics = hierarchyLevels.includes('sub topic');

                // First, remove ALL pedagogy data containing the editing element ID
                if (editMode?.type === 'topic') {
                    const hierarchyIdsForDeletion = {
                        topics: [editMode.data._id]
                    };

                    await checkAndDeleteExistingPedagogyData(
                        hierarchyIdsForDeletion,
                        alreadyDeletedPedagogyItems
                    );
                }
                if (showPedagogySection && editMode) {
                    for (const activityType of ["iDo", "weDo", "youDo"] as const) {
                        for (const activity of selectedPedagogyActivities[activityType]) {
                            if (savedPedagogyMergeSelections[activityType]?.[activity]) {
                                await deleteSingleCellValuesForMerge(
                                    editMode.data._id,
                                    activityType,
                                    activity
                                );
                            }
                        }
                    }
                }
                // Now, save ALL pedagogy values from the current form
                const pedagogyDataFromForm: any[] = [];

                (["iDo", "weDo", "youDo"] as const).forEach(activityType => {
                    selectedPedagogyActivities[activityType]
                        .filter(activity => (pedagogyHours[activityType][activity] || 0) > 0)
                        .forEach(activity => {
                            const activityDuration = pedagogyHours[activityType][activity] || 0;
                            let baseHierarchy: any = {};

                            if (addOnlyPedagogyLevel) {
                                // Use all selected hierarchy IDs from merge selections
                                const allIds = getAllSelectedHierarchyIds('pedagogy');
                                if (allIds.modules.length > 0) baseHierarchy.module = allIds.modules;
                                if (hasSubModules && allIds.subModules.length > 0) baseHierarchy.subModule = allIds.subModules;
                                if (hasTopics && allIds.topics.length > 0) baseHierarchy.topic = allIds.topics;
                                if (hasSubTopics && allIds.subTopics.length > 0) baseHierarchy.subTopic = allIds.subTopics;
                            } else {
                                // Original logic
                                baseHierarchy = {
                                    // Include parent hierarchy based on dialog type
                                    ...(hierarchyLevels.includes('module') && {
                                        module: [selectedSubModuleForTopic?.moduleId]
                                    }),
                                    ...(hasSubModules && {
                                        subModule: [selectedSubModuleForTopic?.id]
                                    }),
                                    ...(hasTopics && {
                                        topic: [editMode?.type === 'topic' ? editMode.data._id : newTopic?.topic._id]
                                    })
                                };
                            }

                            // Filter out empty arrays
                            Object.keys(baseHierarchy).forEach(key => {
                                if (Array.isArray(baseHierarchy[key]) && baseHierarchy[key].length === 0) {
                                    delete baseHierarchy[key];
                                }
                            });

                            // Check if this activity has specific merge selections
                            const activityMerge = savedPedagogyMergeSelections[activityType]?.[activity];

                            if (activityMerge) {
                                // Create a merged pedagogy entry with combined hierarchy
                                const mergedHierarchy: any = {
                                    [activityType]: [{ type: activity, duration: activityDuration }]
                                };

                                // Combine base hierarchy with merge hierarchy
                                if (baseHierarchy.module || activityMerge.modules.length > 0) {
                                    mergedHierarchy.module = [...new Set([
                                        ...(baseHierarchy.module || []),
                                        ...activityMerge.modules
                                    ])];
                                }

                                if (hasSubModules && (baseHierarchy.subModule || activityMerge.subModules.length > 0)) {
                                    mergedHierarchy.subModule = [...new Set([
                                        ...(baseHierarchy.subModule || []),
                                        ...activityMerge.subModules
                                    ])];
                                }

                                if (hasTopics && (baseHierarchy.topic || activityMerge.topics.length > 0)) {
                                    mergedHierarchy.topic = [...new Set([
                                        ...(baseHierarchy.topic || []),
                                        ...activityMerge.topics
                                    ])];
                                }

                                if (hasSubTopics && (baseHierarchy.subTopic || activityMerge.subTopics.length > 0)) {
                                    mergedHierarchy.subTopic = [...new Set([
                                        ...(baseHierarchy.subTopic || []),
                                        ...activityMerge.subTopics
                                    ])];
                                }

                                pedagogyDataFromForm.push(mergedHierarchy);
                            } else {
                                // Create a regular pedagogy entry with just the base hierarchy
                                const regularHierarchy: any = {
                                    ...baseHierarchy,
                                    [activityType]: [{ type: activity, duration: activityDuration }]
                                };

                                pedagogyDataFromForm.push(regularHierarchy);
                            }
                        });
                });

                // Save ALL pedagogy data from the form
                if (pedagogyDataFromForm.length > 0) {
                    // Get existing pedagogy data that doesn't contain the editing element
                    const existingPedagogyWithoutEditingItem = pedagogyViews?.[0]?.pedagogies?.filter((pedagogy: any) => {
                        const containsEditingItem =
                            (editMode?.type === 'topic' && pedagogy.topic?.includes(editMode.data._id));
                        return !containsEditingItem;
                    }) || [];

                    // Combine existing pedagogy (without editing item) with new form data
                    const allPedagogyData = [...existingPedagogyWithoutEditingItem, ...pedagogyDataFromForm];

                    await pedagogyMutation.mutateAsync({
                        courses: selectedCourse._id,
                        pedagogies: allPedagogyData
                    });
                } else {
                    // If no pedagogy data in form, remove all pedagogy containing the editing item
                    const existingPedagogyWithoutEditingItem = pedagogyViews?.[0]?.pedagogies?.filter((pedagogy: any) => {
                        const containsEditingItem =
                            (editMode?.type === 'topic' && pedagogy.topic?.includes(editMode.data._id));
                        return !containsEditingItem;
                    }) || [];

                    await pedagogyMutation.mutateAsync({
                        courses: selectedCourse._id,
                        pedagogies: existingPedagogyWithoutEditingItem
                    });
                }
            } else if (editMode?.type === 'topic') {
                // If pedagogy section is unchecked during edit, remove all pedagogy data for this topic
                const hierarchyIdsForDeletion = {
                    topics: [editMode.data._id]
                };

                await checkAndDeleteExistingPedagogyData(
                    hierarchyIdsForDeletion,
                    alreadyDeletedPedagogyItems,
                    false
                );

                // Remove from local state as well
                const existingPedagogyWithoutEditingItem = pedagogyViews?.[0]?.pedagogies?.filter((pedagogy: any) => {
                    const containsEditingItem =
                        (editMode?.type === 'topic' && pedagogy.topic?.includes(editMode.data._id));
                    return !containsEditingItem;
                }) || [];

                await pedagogyMutation.mutateAsync({
                    courses: selectedCourse._id,
                    pedagogies: existingPedagogyWithoutEditingItem
                });
            }
            // Add this right after creating the topic but BEFORE processing level/pedagogy data
            if (!addOnlyPedagogyLevel) {
                // Get all selected topics for merging
                const selectedLevelTopicsData = topics.filter(t => selectedLevelTopicsForMerge.has(t._id));

                // Combine both selections for deletion

                const alreadyDeletedLevels = new Set<string>();
                const alreadyDeletedPedagogyItems = new Set<string>();

                // Collect all hierarchy IDs from selected topics
                const parentModuleIds = new Set([selectedSubModuleForTopic.moduleId]);
                const parentSubModuleIds = new Set([selectedSubModuleForTopic.id]);


                const hierarchyIdsForModuleDeletion = {
                    modules: Array.from(parentModuleIds),
                    subModules: Array.from(parentSubModuleIds),
                    topics: [],
                    subTopics: []
                };

                // Check and delete existing data for all selected items
                await checkAndDeleteExistingPedagogyData(
                    hierarchyIdsForModuleDeletion,
                    alreadyDeletedPedagogyItems,
                    editMode?.type === 'topic', // preserve editing item if we're in edit mode
                    editMode?.data?._id // editing item ID
                );
                await checkAndDeleteExistingLevelData(
                    hierarchyIdsForModuleDeletion,
                    alreadyDeletedLevels,
                    editMode?.type === 'topic', // preserve editing item if we're in edit mode
                    editMode?.data?._id // editing item ID
                );
                checkAndDeleteExistingMergedCells(hierarchyIdsForModuleDeletion);

                // Collect hierarchy IDs for LEVEL deletion
                const levelHierarchyIds = {
                    modules: new Set([selectedSubModuleForTopic.moduleId]),
                    subModules: new Set<string>(),
                    topics: new Set([editMode?.type === 'topic' ? editMode.data._id : newTopic.topic._id]),
                    subTopics: new Set<string>()
                };

                if (selectedSubModuleForTopic.id && !selectedSubModuleForTopic.id.includes('placeholder')) {
                    levelHierarchyIds.subModules.add(selectedSubModuleForTopic.id);
                }

                selectedLevelTopicsData.forEach(topic => {
                    levelHierarchyIds.modules.add(topic.moduleId);
                    if (topic.subModuleId) levelHierarchyIds.subModules.add(topic.subModuleId);
                    levelHierarchyIds.topics.add(topic._id);

                    // Get all subtopics under selected topics for level deletion
                    const topicSubTopics = subTopics.filter(st => st.topicId === topic._id);
                    topicSubTopics.forEach(subTopic => {
                        levelHierarchyIds.subTopics.add(subTopic._id);
                    });
                });

                // Convert to arrays
                const levelIdsForDeletion = {
                    modules: Array.from(levelHierarchyIds.modules),
                    subModules: Array.from(levelHierarchyIds.subModules),
                    topics: Array.from(levelHierarchyIds.topics),
                    subTopics: Array.from(levelHierarchyIds.subTopics)
                };

                // Delete level data for level selections only
                await checkAndDeleteExistingLevelData(levelIdsForDeletion, alreadyDeletedLevels, editMode?.type === 'topic', editMode?.data?._id);

                // Delete pedagogy data for pedagogy selections only
                const pedagogyHierarchyIds = collectPedagogyHierarchyIdsForDeletion();

                await checkAndDeleteExistingPedagogyDataForSelectedActivities(
                    pedagogyHierarchyIds,
                    alreadyDeletedPedagogyItems,
                    editMode?.type === 'topic', // preserve editing item if we're in edit mode
                    editMode?.data?._id // editing item ID
                );

                // Delete merged cells for both
                const mergedCellsHierarchyIds = {
                    modules: Array.from(new Set([...levelHierarchyIds.modules, ...pedagogyHierarchyIds.modules])),
                    subModules: Array.from(new Set([...levelHierarchyIds.subModules, ...pedagogyHierarchyIds.subModules])),
                    topics: Array.from(new Set([...levelHierarchyIds.topics, ...pedagogyHierarchyIds.topics])),
                    subTopics: Array.from(new Set([...levelHierarchyIds.subTopics, ...pedagogyHierarchyIds.subTopics]))
                };

                checkAndDeleteExistingMergedCells(mergedCellsHierarchyIds);

            } else {
                // DELETE LOGIC FOR ADD ONLY PEDAGOGY/LEVEL MODE
                // Get all selected hierarchy IDs for deletion
                const hierarchyIds = getAllSelectedHierarchyIds('pedagogy');

                // Track already deleted items to prevent duplicate deletion
                const alreadyDeletedLevels = new Set<string>();
                const alreadyDeletedPedagogyItems = new Set<string>();

                // Check and delete existing level data
                if (showLevelSection && selectedLevel) {
                    await checkAndDeleteExistingLevelData(hierarchyIds, alreadyDeletedLevels, false);
                }

                // Check and delete existing pedagogy data for selected activities
                await checkAndDeleteExistingPedagogyDataForSelectedActivities(
                    hierarchyIds,
                    alreadyDeletedPedagogyItems,
                    false
                );

                // Check and delete existing merged cells
                checkAndDeleteExistingMergedCells(hierarchyIds);
            }
            await refetchTopics();

            setShowDialog(false);
            setTopicFormData({
                title: '',
                description: '',
                level: 'Easy',
                duration: 0
            });
            setEditMode(null);
            resetAllFormStates();
            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 2000);
        } catch (error) {
            console.error("Failed to create/update topic:", error);
        } finally {
            setIsCreatingTopic(false);
        }
    };

    const handleSubTopicSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!selectedTopicForSubTopic || !selectedCourse || !token) return;
        setIsCreatingSubTopic(true);

        // Track already deleted items to prevent duplicate deletion
        const alreadyDeletedLevels = new Set<string>();
        const alreadyDeletedPedagogyItems = new Set<string>();

        try {
            // Check if submodules are in course hierarchy
            const hierarchyLevels = selectedCourse.courseHierarchy.map(level => level.toLowerCase());
            const hasSubModules = hierarchyLevels.includes('sub module');
            const hasSubTopics = hierarchyLevels.includes('sub topic');

            const subTopicData: any = {
                ...subTopicFormData,
                topicId: selectedTopicForSubTopic.id,
                courses: selectedCourse._id,
                // Include parent hierarchy references
                moduleId: selectedTopicForSubTopic.moduleId,
                ...(hasSubModules && { subModuleId: selectedTopicForSubTopic.subModuleId })
            };

            let subTopicIdToUnmerge: any = null;
            let newSubTopic: any;

            if (!addOnlyPedagogyLevel) {
                if (editMode?.type === 'subtopic') {
                    subTopicIdToUnmerge = editMode.data._id;
                    await updateSubTopicMutation.mutateAsync({
                        id: editMode.data._id,
                        data: {
                            ...subTopicData,
                            index: editMode.data.index
                        }
                    });
                } else {
                    const topicSubTopics = subTopics.filter(subTopic => subTopic.topicId === selectedTopicForSubTopic.id);
                    const nextIndex = topicSubTopics.length > 0
                        ? Math.max(...topicSubTopics.map(t => t.index ?? 0)) + 1
                        : 0;

                    newSubTopic = await createSubTopicMutation.mutateAsync({
                        ...subTopicData,
                        index: nextIndex
                    });
                    subTopicIdToUnmerge = newSubTopic.subTopic._id;
                }
            }

            // Save level data if level section is shown
            if (showLevelSection && selectedLevel) {
                let levelData: any;

                if (editMode?.type === 'subtopic' && editingExistingLevelData) {
                    // UPDATE EXISTING LEVEL DATA
                    levelData = {
                        _id: editingExistingLevelData._id,
                        level: selectedLevel,
                        module: savedLevelMergeSelections?.modules || [],
                        subModule: savedLevelMergeSelections?.subModules || [],
                        topic: savedLevelMergeSelections?.topics || [],
                        subTopic: savedLevelMergeSelections?.subTopics || []
                    };

                    // Ensure the editing item is always included
                    if (!levelData.subTopic?.includes(editMode.data._id)) {
                        levelData.subTopic = [...(levelData.subTopic || []), editMode.data._id];
                    }

                    // Update the level in the database - replace the entire entry
                    const updatedLevels = levelsData.map((level: any) =>
                        level._id === editingExistingLevelData._id ? levelData : level
                    );

                    await levelViewMutation.mutateAsync({
                        courses: selectedCourse._id,
                        levels: updatedLevels
                    });
                } else {
                    // CREATE NEW LEVEL DATA
                    levelData = {
                        level: selectedLevel,
                    };

                    if (addOnlyPedagogyLevel) {
                        // Use all selected hierarchy IDs from merge selections
                        const allIds = getAllSelectedHierarchyIds('level');
                        if (allIds.modules.length > 0) levelData.module = allIds.modules;
                        if (hasSubModules && allIds.subModules.length > 0) levelData.subModule = allIds.subModules;
                        if (hierarchyLevels.includes('topic') && allIds.topics.length > 0) levelData.topic = allIds.topics;
                        if (hasSubTopics && allIds.subTopics.length > 0) levelData.subTopic = allIds.subTopics;
                    } else {
                        // Original logic for creating with hierarchy
                        levelData = {
                            ...levelData,
                            // Include parent module
                            ...(hierarchyLevels.includes('module') && {
                                module: [selectedTopicForSubTopic.moduleId]
                            }),
                            // Include parent submodule if it exists in hierarchy
                            ...(hasSubModules && selectedTopicForSubTopic.subModuleId && {
                                subModule: [selectedTopicForSubTopic.subModuleId]
                            }),
                            // Include parent topic
                            ...(hierarchyLevels.includes('topic') && {
                                topic: [selectedTopicForSubTopic.id]
                            }),
                            // Include newly created subtopic
                            ...(hierarchyLevels.includes('sub topic') && {
                                subTopic: [editMode?.type === 'subtopic' ? editMode.data._id : newSubTopic.subTopic._id]
                            })
                        };

                        // If merging with other subtopics, include their complete hierarchy
                        if (savedLevelMergeSelections) {
                            levelData.module = [...levelData.module, ...savedLevelMergeSelections.modules];

                            if (hasSubModules) {
                                levelData.subModule = [...levelData.subModule, ...savedLevelMergeSelections.subModules];
                            }

                            levelData.topic = [...levelData.topic, ...savedLevelMergeSelections.topics];
                            levelData.subTopic = [...levelData.subTopic, ...savedLevelMergeSelections.subTopics];
                        }
                    }

                    await levelViewMutation.mutateAsync({
                        courses: selectedCourse._id,
                        levels: [...levelsData, levelData]
                    });
                }
            } else if (editMode?.type === 'subtopic' && editingExistingLevelData) {
                // If level section is unchecked during edit, remove the level data
                if (editingExistingLevelData._id) {
                    await deleteLevelMutation.mutateAsync(editingExistingLevelData._id);
                }
            }

            // Process pedagogy data if needed
            const hasPedagogyData = Object.keys(pedagogyHours).some(type =>
                Object.keys(pedagogyHours[type as keyof typeof pedagogyHours]).some(
                    activity => (pedagogyHours[type as keyof typeof pedagogyHours][activity] || 0) > 0
                )
            );

            if (showPedagogySection && hasPedagogyData) {
                const hierarchyLevels = selectedCourse.courseHierarchy.map(l => l.toLowerCase());
                const hasSubModules = hierarchyLevels.includes('sub module');
                const hasTopics = hierarchyLevels.includes('topic');
                const hasSubTopics = hierarchyLevels.includes('sub topic');

                // First, remove ALL pedagogy data containing the editing element ID
                if (editMode?.type === 'subtopic') {
                    const hierarchyIdsForDeletion = {
                        subTopics: [editMode.data._id]
                    };

                    await checkAndDeleteExistingPedagogyData(
                        hierarchyIdsForDeletion,
                        alreadyDeletedPedagogyItems
                    );
                }
                if (showPedagogySection && editMode) {
                    for (const activityType of ["iDo", "weDo", "youDo"] as const) {
                        for (const activity of selectedPedagogyActivities[activityType]) {
                            if (savedPedagogyMergeSelections[activityType]?.[activity]) {
                                await deleteSingleCellValuesForMerge(
                                    editMode.data._id,
                                    activityType,
                                    activity
                                );
                            }
                        }
                    }
                }
                // Now, save ALL pedagogy values from the current form
                const pedagogyDataFromForm: any[] = [];

                (["iDo", "weDo", "youDo"] as const).forEach(activityType => {
                    selectedPedagogyActivities[activityType]
                        .filter(activity => (pedagogyHours[activityType][activity] || 0) > 0)
                        .forEach(activity => {
                            const activityDuration = pedagogyHours[activityType][activity] || 0;
                            let baseHierarchy: any = {};

                            if (addOnlyPedagogyLevel) {
                                // Use all selected hierarchy IDs from merge selections
                                const allIds = getAllSelectedHierarchyIds('pedagogy');
                                if (allIds.modules.length > 0) baseHierarchy.module = allIds.modules;
                                if (hasSubModules && allIds.subModules.length > 0) baseHierarchy.subModule = allIds.subModules;
                                if (hasTopics && allIds.topics.length > 0) baseHierarchy.topic = allIds.topics;
                                if (hasSubTopics && allIds.subTopics.length > 0) baseHierarchy.subTopic = allIds.subTopics;
                            } else {
                                // Original logic
                                baseHierarchy = {
                                    // Include parent hierarchy based on dialog type
                                    ...(hierarchyLevels.includes('module') && {
                                        module: [selectedTopicForSubTopic?.moduleId]
                                    }),
                                    ...(hasSubModules && {
                                        subModule: dialogType === 'subtopic' ? [selectedTopicForSubTopic?.subModuleId] : []
                                    }),
                                    ...(hasTopics && {
                                        topic: dialogType === 'subtopic' ? [selectedTopicForSubTopic?.id] : []
                                    }),
                                    ...(hasSubTopics && dialogType === 'subtopic' && {
                                        subTopic: [editMode?.type === 'subtopic' ? editMode.data._id : newSubTopic?.subTopic._id]
                                    })
                                };
                            }

                            // Filter out empty arrays
                            Object.keys(baseHierarchy).forEach(key => {
                                if (Array.isArray(baseHierarchy[key]) && baseHierarchy[key].length === 0) {
                                    delete baseHierarchy[key];
                                }
                            });

                            // Check if this activity has specific merge selections
                            const activityMerge = savedPedagogyMergeSelections[activityType]?.[activity];

                            if (activityMerge) {
                                // Create a merged pedagogy entry with combined hierarchy
                                const mergedHierarchy: any = {
                                    [activityType]: [{ type: activity, duration: activityDuration }]
                                };

                                // Combine base hierarchy with merge hierarchy
                                if (baseHierarchy.module || activityMerge.modules.length > 0) {
                                    mergedHierarchy.module = [...new Set([
                                        ...(baseHierarchy.module || []),
                                        ...activityMerge.modules
                                    ])];
                                }

                                if (hasSubModules && (baseHierarchy.subModule || activityMerge.subModules.length > 0)) {
                                    mergedHierarchy.subModule = [...new Set([
                                        ...(baseHierarchy.subModule || []),
                                        ...activityMerge.subModules
                                    ])];
                                }

                                if (hasTopics && (baseHierarchy.topic || activityMerge.topics.length > 0)) {
                                    mergedHierarchy.topic = [...new Set([
                                        ...(baseHierarchy.topic || []),
                                        ...activityMerge.topics
                                    ])];
                                }

                                if (hasSubTopics && (baseHierarchy.subTopic || activityMerge.subTopics.length > 0)) {
                                    mergedHierarchy.subTopic = [...new Set([
                                        ...(baseHierarchy.subTopic || []),
                                        ...activityMerge.subTopics
                                    ])];
                                }

                                pedagogyDataFromForm.push(mergedHierarchy);
                            } else {
                                // Create a regular pedagogy entry with just the base hierarchy
                                const regularHierarchy: any = {
                                    ...baseHierarchy,
                                    [activityType]: [{ type: activity, duration: activityDuration }]
                                };

                                pedagogyDataFromForm.push(regularHierarchy);
                            }
                        });
                });

                // Save ALL pedagogy data from the form
                if (pedagogyDataFromForm.length > 0) {
                    // Get existing pedagogy data that doesn't contain the editing element
                    const existingPedagogyWithoutEditingItem = pedagogyViews?.[0]?.pedagogies?.filter((pedagogy: any) => {
                        const containsEditingItem =
                            (editMode?.type === 'subtopic' && pedagogy.subTopic?.includes(editMode.data._id));
                        return !containsEditingItem;
                    }) || [];

                    // Combine existing pedagogy (without editing item) with new form data
                    const allPedagogyData = [...existingPedagogyWithoutEditingItem, ...pedagogyDataFromForm];

                    await pedagogyMutation.mutateAsync({
                        courses: selectedCourse._id,
                        pedagogies: allPedagogyData
                    });
                } else {
                    // If no pedagogy data in form, remove all pedagogy containing the editing item
                    const existingPedagogyWithoutEditingItem = pedagogyViews?.[0]?.pedagogies?.filter((pedagogy: any) => {
                        const containsEditingItem =
                            (editMode?.type === 'subtopic' && pedagogy.subTopic?.includes(editMode.data._id));
                        return !containsEditingItem;
                    }) || [];

                    await pedagogyMutation.mutateAsync({
                        courses: selectedCourse._id,
                        pedagogies: existingPedagogyWithoutEditingItem
                    });
                }
            } else if (editMode?.type === 'subtopic') {
                // If pedagogy section is unchecked during edit, remove all pedagogy data for this subtopic
                const hierarchyIdsForDeletion = {
                    subTopics: [editMode.data._id]
                };

                await checkAndDeleteExistingPedagogyData(
                    hierarchyIdsForDeletion,
                    alreadyDeletedPedagogyItems,
                    false
                );

                // Remove from local state as well
                const existingPedagogyWithoutEditingItem = pedagogyViews?.[0]?.pedagogies?.filter((pedagogy: any) => {
                    const containsEditingItem =
                        (editMode?.type === 'subtopic' && pedagogy.subTopic?.includes(editMode.data._id));
                    return !containsEditingItem;
                }) || [];

                await pedagogyMutation.mutateAsync({
                    courses: selectedCourse._id,
                    pedagogies: existingPedagogyWithoutEditingItem
                });
            }

            // Add this right after creating the subtopic but BEFORE processing level/pedagogy data
            if (!addOnlyPedagogyLevel) {
                // Get all selected subtopics for merging
                const selectedLevelSubTopicsData = subTopics.filter(st => selectedLevelSubTopicsForMerge.has(st._id));

                // Collect all hierarchy IDs from selected subtopics
                const parentModuleIds = new Set([selectedTopicForSubTopic.moduleId]);
                const parentSubModuleIds = new Set([selectedTopicForSubTopic.subModuleId || '']);
                const parentTopicIds = new Set([selectedTopicForSubTopic.id]);

                const hierarchyIdsForParentDeletion = {
                    modules: Array.from(parentModuleIds),
                    subModules: Array.from(parentSubModuleIds),
                    topics: Array.from(parentTopicIds),
                    subTopics: []
                };

                // Check and delete existing data for all parent items
                await checkAndDeleteExistingPedagogyData(
                    hierarchyIdsForParentDeletion,
                    alreadyDeletedPedagogyItems,
                    editMode?.type === 'subtopic', // preserve editing item if we're in edit mode
                    editMode?.data?._id // editing item ID
                );
                await checkAndDeleteExistingLevelData(
                    hierarchyIdsForParentDeletion,
                    alreadyDeletedLevels,
                    editMode?.type === 'subtopic', // preserve editing item if we're in edit mode
                    editMode?.data?._id // editing item ID
                );
                checkAndDeleteExistingMergedCells(hierarchyIdsForParentDeletion);

                // Collect hierarchy IDs for LEVEL deletion
                const levelHierarchyIds = {
                    modules: new Set<string>(),
                    subModules: new Set<string>(),
                    topics: new Set([selectedTopicForSubTopic.id]),
                    subTopics: new Set([editMode?.type === 'subtopic' ? editMode.data._id : newSubTopic?.subTopic._id])
                };

                // Add parent hierarchy for the new subtopic
                levelHierarchyIds.modules.add(selectedTopicForSubTopic.moduleId);
                if (selectedTopicForSubTopic.subModuleId) {
                    levelHierarchyIds.subModules.add(selectedTopicForSubTopic.subModuleId);
                }

                selectedLevelSubTopicsData.forEach(subTopic => {
                    const parentTopic = topics.find(t => t._id === subTopic.topicId);
                    if (parentTopic) {
                        levelHierarchyIds.modules.add(parentTopic.moduleId);
                        if (parentTopic.subModuleId) levelHierarchyIds.subModules.add(parentTopic.subModuleId);
                        levelHierarchyIds.topics.add(parentTopic._id);
                    }
                    levelHierarchyIds.subTopics.add(subTopic._id);
                });

                // Convert to arrays
                const levelIdsForDeletion = {
                    modules: Array.from(levelHierarchyIds.modules),
                    subModules: Array.from(levelHierarchyIds.subModules),
                    topics: Array.from(levelHierarchyIds.topics),
                    subTopics: Array.from(levelHierarchyIds.subTopics)
                };

                // Delete level data for level selections only
                await checkAndDeleteExistingLevelData(levelIdsForDeletion, alreadyDeletedLevels, editMode?.type === 'subtopic', // preserve editing item if we're in edit mode
                    editMode?.data?._id);

                // Delete pedagogy data for pedagogy selections only
                const pedagogyHierarchyIds = collectPedagogyHierarchyIdsForDeletion();

                await checkAndDeleteExistingPedagogyDataForSelectedActivities(
                    pedagogyHierarchyIds,
                    alreadyDeletedPedagogyItems,
                    editMode?.type === 'subtopic', // preserve editing item if we're in edit mode
                    editMode?.data?._id // editing item ID
                );

                // Delete merged cells for both
                const mergedCellsHierarchyIds = {
                    modules: Array.from(new Set([...levelHierarchyIds.modules, ...pedagogyHierarchyIds.modules])),
                    subModules: Array.from(new Set([...levelHierarchyIds.subModules, ...pedagogyHierarchyIds.subModules])),
                    topics: Array.from(new Set([...levelHierarchyIds.topics, ...pedagogyHierarchyIds.topics])),
                    subTopics: Array.from(new Set([...levelHierarchyIds.subTopics, ...pedagogyHierarchyIds.subTopics]))
                };

                checkAndDeleteExistingMergedCells(mergedCellsHierarchyIds);
            } else {
                // DELETE LOGIC FOR ADD ONLY PEDAGOGY/LEVEL MODE
                // Get all selected hierarchy IDs for deletion
                const hierarchyIds = getAllSelectedHierarchyIds('pedagogy');
                const alreadyDeletedLevels = new Set<string>();
                const alreadyDeletedPedagogyItems = new Set<string>();
                // Check and delete existing level data
                if (showLevelSection && selectedLevel) {
                    await checkAndDeleteExistingLevelData(hierarchyIds, alreadyDeletedLevels, false);
                }

                // Check and delete existing pedagogy data for selected activities
                await checkAndDeleteExistingPedagogyDataForSelectedActivities(
                    hierarchyIds,
                    alreadyDeletedPedagogyItems, false
                );

                // Check and delete existing merged cells
                checkAndDeleteExistingMergedCells(hierarchyIds);
            }

            // Clear local merged cells that contain the editing item
            if (editMode?.type === 'subtopic') {
                const updatedMergedCells = { ...mergedCells };
                Object.keys(updatedMergedCells).forEach(key => {
                    updatedMergedCells[key] = updatedMergedCells[key].filter(merge => {
                        const containsEditingItem =
                            merge.hierarchyIds?.subTopics.includes(editMode.data._id);

                        return !containsEditingItem;
                    });
                });
                setMergedCells(updatedMergedCells);
            }

            await refetchSubTopics();
            if (selectedTopicForSubTopic.id) {
                await refetchTopicSubTopics();
            }

            setShowDialog(false);
            setSubTopicFormData({
                title: '',
                description: '',
                level: 'Easy',
                duration: 0
            });
            setEditMode(null);
            resetAllFormStates();
            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 2000);
        } catch (error) {
            console.error("Failed to create/update subtopic:", error);
        } finally {
            setIsCreatingSubTopic(false);
        }
    };

    const preserveLevelDataForEditing = (type: string, id: string) => {
        if (!levelViews || !selectedCourse) return null;

        // Find existing level data for this item
        const existingLevelData = levelsData.find((level: any) => {
            if (type === 'module' && level.module?.includes(id)) return true;
            if (type === 'submodule' && level.subModule?.includes(id)) return true;
            if (type === 'topic' && level.topic?.includes(id)) return true;
            if (type === 'subtopic' && level.subTopic?.includes(id)) return true;
            return false;
        });

        return existingLevelData || null;
    };

    const getAllSelectedHierarchyIds = (type: 'level' | 'pedagogy' = 'level', activityType?: string, activity?: string) => {
        const allModuleIds = new Set<string>();
        const allSubModuleIds = new Set<string>();
        const allTopicIds = new Set<string>();
        const allSubTopicIds = new Set<string>();

        // Get IDs based on dialog type and current selections
        if (dialogType === 'module') {
            // For modules, include the module being edited and any merged modules
            if (!addOnlyPedagogyLevel && editMode?.data?._id) {
                allModuleIds.add(editMode.data._id);
            }

            // Add merged modules based on type
            if (type === 'level' && savedLevelMergeSelections?.modules) {
                savedLevelMergeSelections.modules.forEach(id => allModuleIds.add(id));
            }

            // Also add from pedagogy merge selections if type is pedagogy
            if (type === 'pedagogy' && activityType && activity && savedPedagogyMergeSelections[activityType as ActivityType]?.[activity]?.modules) {
                savedPedagogyMergeSelections[activityType as ActivityType][activity].modules.forEach((id: string) => allModuleIds.add(id));
            }
        }
        // ... similar logic for other dialog types (submodule, topic, subtopic)
        else if (dialogType === 'submodule') {
            // For submodules, include parent module and the submodule being edited
            if (selectedModuleForSubModule?.id) {
                allModuleIds.add(selectedModuleForSubModule.id);
            }
            if (!addOnlyPedagogyLevel && editMode?.data?._id) {
                allSubModuleIds.add(editMode.data._id);
            }

            // Add merged items based on type
            if (type === 'level' && savedLevelMergeSelections) {
                savedLevelMergeSelections.modules.forEach(id => allModuleIds.add(id));
                savedLevelMergeSelections.subModules.forEach(id => allSubModuleIds.add(id));
            }

            // Add from pedagogy merge selections if type is pedagogy
            if (type === 'pedagogy' && activityType && activity && savedPedagogyMergeSelections[activityType as ActivityType]?.[activity]) {
                const pedagogySelection = savedPedagogyMergeSelections[activityType as ActivityType][activity];
                if (pedagogySelection.modules) pedagogySelection.modules.forEach((id: string) => allModuleIds.add(id));
                if (pedagogySelection.subModules) pedagogySelection.subModules.forEach((id: string) => allSubModuleIds.add(id));
            }
        }
        else if (dialogType === 'topic') {
            // For topics, include parent hierarchy and the topic being edited
            if (selectedSubModuleForTopic) {
                allModuleIds.add(selectedSubModuleForTopic.moduleId);
                if (selectedSubModuleForTopic.id !== null) {
                    allSubModuleIds.add(selectedSubModuleForTopic.id);
                }
            }
            if (!addOnlyPedagogyLevel && editMode?.data?._id) {
                allTopicIds.add(editMode.data._id);
            }

            // Add merged items based on type
            if (type === 'level' && savedLevelMergeSelections) {
                savedLevelMergeSelections.modules.forEach(id => allModuleIds.add(id));
                savedLevelMergeSelections.subModules.forEach(id => allSubModuleIds.add(id));
                savedLevelMergeSelections.topics.forEach(id => allTopicIds.add(id));
            }

            // Add from pedagogy merge selections if type is pedagogy
            if (type === 'pedagogy' && activityType && activity && savedPedagogyMergeSelections[activityType as ActivityType]?.[activity]) {
                const pedagogySelection = savedPedagogyMergeSelections[activityType as ActivityType][activity];
                if (pedagogySelection.modules) pedagogySelection.modules.forEach((id: string) => allModuleIds.add(id));
                if (pedagogySelection.subModules) pedagogySelection.subModules.forEach((id: string) => allSubModuleIds.add(id));
                if (pedagogySelection.topics) pedagogySelection.topics.forEach((id: string) => allTopicIds.add(id));
            }
        }
        else if (dialogType === 'subtopic') {
            // For subtopics, include full parent hierarchy and the subtopic being edited
            if (selectedTopicForSubTopic) {
                allModuleIds.add(selectedTopicForSubTopic.moduleId);
                if (selectedTopicForSubTopic.subModuleId) {
                    allSubModuleIds.add(selectedTopicForSubTopic.subModuleId);
                }
                if (selectedTopicForSubTopic.id !== null) {
                    allTopicIds.add(selectedTopicForSubTopic.id);
                }
            }
            if (!addOnlyPedagogyLevel && editMode?.data?._id) {
                allSubTopicIds.add(editMode.data._id);
            }

            // Add merged items based on type
            if (type === 'level' && savedLevelMergeSelections) {
                savedLevelMergeSelections.modules.forEach(id => allModuleIds.add(id));
                savedLevelMergeSelections.subModules.forEach(id => allSubModuleIds.add(id));
                savedLevelMergeSelections.topics.forEach(id => allTopicIds.add(id));
                savedLevelMergeSelections.subTopics.forEach(id => allSubTopicIds.add(id));
            }

            // Add from pedagogy merge selections if type is pedagogy
            if (type === 'pedagogy' && activityType && activity && savedPedagogyMergeSelections[activityType as ActivityType]?.[activity]) {
                const pedagogySelection = savedPedagogyMergeSelections[activityType as ActivityType][activity];
                if (pedagogySelection.modules) pedagogySelection.modules.forEach((id: string) => allModuleIds.add(id));
                if (pedagogySelection.subModules) pedagogySelection.subModules.forEach((id: string) => allSubModuleIds.add(id));
                if (pedagogySelection.topics) pedagogySelection.topics.forEach((id: string) => allTopicIds.add(id));
                if (pedagogySelection.subTopics) pedagogySelection.subTopics.forEach((id: string) => allSubTopicIds.add(id));
            }
        }

        return {
            modules: Array.from(allModuleIds),
            subModules: Array.from(allSubModuleIds),
            topics: Array.from(allTopicIds),
            subTopics: Array.from(allSubTopicIds)
        };
    };
    // for topic
    const areAllSubModulesCompleted = (
        module: any,
        sortedSubModules: any[],
        sortedTopics: any[],
        selectedTopicsForMerge: Set<string>,
        currentSubModuleId: string | undefined,
        currentTopicId: string | undefined // Add this parameter
    ) => {
        const moduleSubModules = sortedSubModules.filter((sm: { moduleId: any; }) => sm.moduleId === module._id);


        if (moduleSubModules.length === 0) return false; // no submodules → not complete

        return moduleSubModules.every((sm: { _id: any; }) => {
            // const subTopics = sortedTopics.filter((t: { subModuleId: any; }) => t.subModuleId === sm._id);
            const subTopics = sortedTopics.filter((t: { subModuleId: any; _id: any; }) =>
                t.subModuleId === sm._id && t._id !== currentTopicId // Exclude current topic
            );

            // ❌ If submodule has no topics → incomplete (unless it's the current editing submodule)
            if (subTopics.length === 0 && sm._id !== currentSubModuleId) {
                return false;
            }

            // ✅ All topics in this submodule must be selected
            return subTopics.every((t: { _id: any; }) => selectedTopicsForMerge.has(t._id));
        });
    };

    const areAllModuleTopicsCompleted = (
        module: any,
        sortedTopics: any,
        selectedTopicsForMerge: any,
        currentTopicId: any
    ) => {
        const moduleTopics = sortedTopics.filter((t: { moduleId: any; _id: any; }) => t.moduleId === module._id && t._id !== currentTopicId);

        if (moduleTopics.length === 0) return false; // no topics → not complete

        // All topics in this module must be selected
        return moduleTopics.every((t: { _id: any; }) => selectedTopicsForMerge.has(t._id));
    };

    const PreviewButton = ({ course }: { course: Course | null }) => {
        const handlePreviewClick = () => {
            if (course) {
                setPreviewCourse(course);
                setShowCoursePreview(true);
            }
        };

        return (
            <button
                onClick={handlePreviewClick}
                disabled={!course}
                className={`flex items-center gap-1.5 px-3 py-1.5 text-xs font-medium rounded-md transition-all ${course
                    ? "bg-blue-50 text-blue-700 border border-blue-200 hover:bg-blue-100 hover:border-blue-300 cursor-pointer"
                    : "bg-gray-100 text-gray-400 cursor-not-allowed"
                    }`}
                title={course ? `Preview ${course.courseName}` : "Select a course to preview"}
            >
                <Eye className="w-3.5 h-3.5" />
                Preview
            </button>
        );
    };
    const FullCoursePreviewTable = ({
        tableRows,
        selectedCourse,
        moduleSpans,
        subModuleSpans,
        topicSpans,
        subtopicSpans,
    }: {
        tableRows: any[];
        selectedCourse: Course | null;
        moduleSpans: { [key: string]: number };
        subModuleSpans: { [key: string]: number };
        topicSpans: { [key: string]: number };
        subtopicSpans: { [key: string]: number };
    }) => {
        const getStickyLeftPositions = () => {
            const positions: { [key: string]: number } = {};
            let currentLeft = 0;

            // Show ALL hierarchy levels from the course
            if (selectedCourse?.courseHierarchy.includes('Module')) {
                positions['module'] = currentLeft;
                currentLeft += 80;
            }

            if (selectedCourse?.courseHierarchy.includes('Sub Module')) {
                positions['subModule'] = currentLeft;
                currentLeft += 80;
            }

            if (selectedCourse?.courseHierarchy.includes('Topic')) {
                positions['topic'] = currentLeft;
                currentLeft += 80;
            }

            if (selectedCourse?.courseHierarchy.includes('Sub Topic')) {
                positions['subTopic'] = currentLeft;
                currentLeft += 80;
            }

            return positions;
        };

        const stickyPositions = getStickyLeftPositions();

        return (
            <div className="overflow-x-auto">
                <Table className="border-separate border-spacing-0 w-full text-[8px]">
                    <TableHeader>
                        <TableRow className="bg-blue-100">
                            {/* Show ALL hierarchy columns without checkboxes */}
                            {selectedCourse?.courseHierarchy.includes('Module') && (
                                <TableHead
                                    className="border border-gray-400 text-center font-bold p-0.5 sticky bg-blue-100 z-10 min-w-[80px]"
                                    style={{ left: `${stickyPositions['module']}px` }}
                                >
                                    Module
                                </TableHead>
                            )}
                            {selectedCourse?.courseHierarchy.includes('Sub Module') && (
                                <TableHead
                                    className="border border-gray-400 text-center font-bold p-0.5 sticky bg-blue-100 z-10 min-w-[80px]"
                                    style={{ left: `${stickyPositions['subModule']}px` }}
                                >
                                    Sub Module
                                </TableHead>
                            )}
                            {selectedCourse?.courseHierarchy.includes('Topic') && (
                                <TableHead
                                    className="border border-gray-400 text-center font-bold p-0.5 sticky bg-blue-100 z-10 min-w-[80px]"
                                    style={{ left: `${stickyPositions['topic']}px` }}
                                >
                                    Topic
                                </TableHead>
                            )}
                            {selectedCourse?.courseHierarchy.includes('Sub Topic') && (
                                <TableHead
                                    className="border border-gray-400 text-center font-bold p-0.5 sticky bg-blue-100 z-10 min-w-[80px]"
                                    style={{ left: `${stickyPositions['subTopic']}px` }}
                                >
                                    Sub Topic
                                </TableHead>
                            )}
                        </TableRow>
                    </TableHeader>
                    <TableBody>
                        {(() => {
                            const moduleRowTracker: { [key: string]: boolean } = {};
                            const subModuleRowTracker: { [key: string]: boolean } = {};
                            const topicRowTracker: { [key: string]: boolean } = {};
                            const subtopicRowTracker: { [key: string]: boolean } = {};

                            return tableRows.map((row, index) => {
                                const isFirstSubtopicInModule = !moduleRowTracker[row.moduleId];
                                const isFirstSubtopicInSubModule = !subModuleRowTracker[row.subModuleId];
                                const isFirstSubtopicInTopic = !topicRowTracker[row.topicId];
                                const isFirstSubtopicInSubtopic = !subtopicRowTracker[row.subtopicId];

                                if (isFirstSubtopicInModule) moduleRowTracker[row.moduleId] = true;
                                if (isFirstSubtopicInSubModule) subModuleRowTracker[row.subModuleId] = true;
                                if (isFirstSubtopicInTopic) topicRowTracker[row.topicId] = true;
                                if (isFirstSubtopicInSubtopic) subtopicRowTracker[row.subtopicId] = true;

                                return (
                                    <TableRow
                                        key={`preview-${row.rowId}`}
                                        className={`hover:bg-gray-50 h-6`}
                                    >
                                        {/* Module Cell - Show for all modules */}
                                        {selectedCourse?.courseHierarchy.includes('Module') && isFirstSubtopicInModule && (
                                            <TableCell
                                                rowSpan={moduleSpans[row.moduleId]}
                                                className="border border-gray-400 text-left text-[9px] font-medium p-0.5 bg-blue-50 text-center align-middle max-w-[80px] h-6 sticky z-10"
                                                style={{ left: `${stickyPositions['module']}px` }}
                                            >
                                                <span
                                                    className="whitespace-normal break-words px-4 text-center flex-1"
                                                    title={row.moduleName === "Default Module" ? "-" : row.moduleName}
                                                >
                                                    {row.moduleName === "Default Module" ? "-" : row.moduleName}
                                                </span>
                                            </TableCell>
                                        )}

                                        {/* SubModule Cell - Show for all submodules */}
                                        {selectedCourse?.courseHierarchy.includes('Sub Module') && isFirstSubtopicInSubModule && (
                                            <TableCell
                                                rowSpan={subModuleSpans[row.subModuleId]}
                                                className="border border-gray-400 text-left p-0.5 bg-blue-50 text-[9px] font-medium text-center align-middle max-w-[80px] h-6 sticky z-10"
                                                style={{ left: `${stickyPositions['subModule']}px` }}
                                            >
                                                <span
                                                    className="whitespace-nowrap overflow-hidden text-ellipsis block px-1"
                                                    title={row.subModuleName === "Default Submodule" ? "-" : row.subModuleName}
                                                >
                                                    {row.subModuleName === "Default Submodule" ? "-" : row.subModuleName}
                                                </span>
                                            </TableCell>
                                        )}

                                        {/* Topic Cell - Show for all topics */}
                                        {selectedCourse?.courseHierarchy.includes("Topic") && isFirstSubtopicInTopic && (
                                            <TableCell
                                                rowSpan={topicSpans[row.topicId]}
                                                className="border border-gray-400 text-left p-0.5 bg-blue-50 text-[9px] font-medium text-center align-middle max-w-[80px] h-6 sticky z-10"
                                                style={{ left: `${stickyPositions['topic']}px` }}
                                            >
                                                <span
                                                    className="whitespace-nowrap overflow-hidden text-ellipsis block px-1"
                                                    title={row.topicName === "Default Topic" ? "-" : row.topicName}
                                                >
                                                    {row.topicName === "Default Topic" ? "-" : row.topicName}
                                                </span>
                                            </TableCell>
                                        )}

                                        {/* Subtopic Cell - Show for all subtopics */}
                                        {selectedCourse?.courseHierarchy.includes("Sub Topic") && (
                                            <TableCell
                                                className="border border-gray-400 text-left p-0.5 bg-blue-50 text-[9px] font-medium text-center align-middle max-w-[80px] h-6 sticky z-10"
                                                style={{ left: `${stickyPositions['subTopic']}px` }}
                                            >
                                                <span
                                                    className="whitespace-nowrap overflow-hidden text-ellipsis block px-1"
                                                    title={row.subtopicName === "Default Subtopic" ? "-" : row.subtopicName}
                                                >
                                                    {row.subtopicName === "Default Subtopic" ? "-" : row.subtopicName}
                                                </span>
                                            </TableCell>
                                        )}
                                    </TableRow>
                                );
                            });
                        })()}
                    </TableBody>
                </Table>
            </div>
        );
    };
    const calculateConfirmationStats = () => {
        if (!selectedDuplicateCourse) return { modules: 0, subModules: 0, topics: 0, subTopics: 0, total: 0 };

        const allTableRows = createDuplicateTableRows();

        // Filter rows based on selection (same logic as ConfirmationPreviewTable)
        const filteredRows = enableModuleSelection && selectedModulesForDuplication.size > 0
            ? allTableRows.filter(row => selectedModulesForDuplication.has(row.moduleId))
            : allTableRows;

        // Get the selected hierarchy levels for display
        const selectedHierarchy = selectedDuplicateOptions.hierarchy.map(level =>
            level === 'SubModule' ? 'Sub Module' :
                level === 'SubTopic' ? 'Sub Topic' : level
        );

        // Count only items that are in the selected hierarchy and not placeholders
        const uniqueModules = new Set();
        const uniqueSubModules = new Set();
        const uniqueTopics = new Set();
        const uniqueSubTopics = new Set();

        filteredRows.forEach(row => {
            // Only count if the hierarchy level is selected
            if (selectedHierarchy.includes('Module') && row.moduleId && !row.moduleId.includes('placeholder') && row.moduleName !== "Default Module") {
                uniqueModules.add(row.moduleId);
            }
            if (selectedHierarchy.includes('Sub Module') && row.subModuleId && !row.subModuleId.includes('placeholder') && row.subModuleName !== "Default Submodule") {
                uniqueSubModules.add(row.subModuleId);
            }
            if (selectedHierarchy.includes('Topic') && row.topicId && !row.topicId.includes('placeholder') && row.topicName !== "Default Topic") {
                uniqueTopics.add(row.topicId);
            }
            if (selectedHierarchy.includes('Sub Topic') && row.subtopicId && !row.subtopicId.includes('placeholder') && row.subtopicName !== "Default Subtopic") {
                uniqueSubTopics.add(row.subtopicId);
            }
        });

        const modulesCount = uniqueModules.size;
        const subModulesCount = uniqueSubModules.size;
        const topicsCount = uniqueTopics.size;
        const subTopicsCount = uniqueSubTopics.size;
        const totalCount = modulesCount + subModulesCount + topicsCount + subTopicsCount;

        return {
            modules: modulesCount,
            subModules: subModulesCount,
            topics: topicsCount,
            subTopics: subTopicsCount,
            total: totalCount
        };
    };
    const ConfirmationPreviewTable = ({
        selectedDuplicateCourse,
        selectedHierarchy,
        selectedModules,
        enableModuleSelection
    }: {
        selectedDuplicateCourse: Course | null;
        selectedHierarchy: string[];
        selectedModules: Set<string>;
        enableModuleSelection: boolean;
    }) => {
        if (!selectedDuplicateCourse) return null;

        // Get all table rows
        const allTableRows = createDuplicateTableRows();

        // Filter rows based on selection
        const filteredRows = enableModuleSelection && selectedModules.size > 0
            ? allTableRows.filter(row => selectedModules.has(row.moduleId))
            : allTableRows;

        // Get spans for the filtered rows
        const spans = getDuplicateSpans();

        // Convert hierarchy for display
        const displayHierarchy = selectedHierarchy.map(level =>
            level === 'SubModule' ? 'Sub Module' :
                level === 'SubTopic' ? 'Sub Topic' : level
        );

        const getStickyLeftPositions = () => {
            const positions: { [key: string]: number } = {};
            let currentLeft = 0;

            if (displayHierarchy.includes('Module')) {
                positions['module'] = currentLeft;
                currentLeft += 80;
            }

            if (displayHierarchy.includes('Sub Module')) {
                positions['subModule'] = currentLeft;
                currentLeft += 80;
            }

            if (displayHierarchy.includes('Topic')) {
                positions['topic'] = currentLeft;
                currentLeft += 80;
            }

            if (displayHierarchy.includes('Sub Topic')) {
                positions['subTopic'] = currentLeft;
                currentLeft += 80;
            }

            return positions;
        };

        const stickyPositions = getStickyLeftPositions();

        if (filteredRows.length === 0) {
            return (
                <div className="flex items-center justify-center h-32 text-gray-500 text-sm">
                    No items selected for duplication
                </div>
            );
        }

        return (
            <div className="overflow-x-auto">
                <Table className="border-separate border-spacing-0 w-full text-xs">
                    <TableHeader>
                        <TableRow className="bg-green-100">
                            {displayHierarchy.includes('Module') && (
                                <TableHead
                                    className="border border-gray-400 text-center font-bold p-0.5 sticky bg-green-100 z-10 min-w-[80px]"
                                    style={{ left: `${stickyPositions['module']}px` }}
                                >
                                    Module
                                </TableHead>
                            )}
                            {displayHierarchy.includes('Sub Module') && (
                                <TableHead
                                    className="border border-gray-400 text-center font-bold p-0.5 sticky bg-green-100 z-10 min-w-[80px]"
                                    style={{ left: `${stickyPositions['subModule']}px` }}
                                >
                                    Sub Module
                                </TableHead>
                            )}
                            {displayHierarchy.includes('Topic') && (
                                <TableHead
                                    className="border border-gray-400 text-center font-bold p-0.5 sticky bg-green-100 z-10 min-w-[80px]"
                                    style={{ left: `${stickyPositions['topic']}px` }}
                                >
                                    Topic
                                </TableHead>
                            )}
                            {displayHierarchy.includes('Sub Topic') && (
                                <TableHead
                                    className="border border-gray-400 text-center font-bold p-0.5 sticky bg-green-100 z-10 min-w-[80px]"
                                    style={{ left: `${stickyPositions['subTopic']}px` }}
                                >
                                    Sub Topic
                                </TableHead>
                            )}
                        </TableRow>
                    </TableHeader>
                    <TableBody>
                        {(() => {
                            const moduleRowTracker: { [key: string]: boolean } = {};
                            const subModuleRowTracker: { [key: string]: boolean } = {};
                            const topicRowTracker: { [key: string]: boolean } = {};
                            const subtopicRowTracker: { [key: string]: boolean } = {};

                            return filteredRows.map((row, index) => {
                                const isFirstSubtopicInModule = !moduleRowTracker[row.moduleId];
                                const isFirstSubtopicInSubModule = !subModuleRowTracker[row.subModuleId];
                                const isFirstSubtopicInTopic = !topicRowTracker[row.topicId];
                                const isFirstSubtopicInSubtopic = !subtopicRowTracker[row.subtopicId];

                                if (isFirstSubtopicInModule) moduleRowTracker[row.moduleId] = true;
                                if (isFirstSubtopicInSubModule) subModuleRowTracker[row.subModuleId] = true;
                                if (isFirstSubtopicInTopic) topicRowTracker[row.topicId] = true;
                                if (isFirstSubtopicInSubtopic) subtopicRowTracker[row.subtopicId] = true;

                                return (
                                    <TableRow
                                        key={`confirmation-${row.rowId}`}
                                        className={`hover:bg-green-50 h-6`}
                                    >
                                        {displayHierarchy.includes('Module') && isFirstSubtopicInModule && (
                                            <TableCell
                                                rowSpan={spans.moduleSpans[row.moduleId]}
                                                className="border border-gray-400 text-left text-[10px] font-medium p-0.5 bg-green-50 text-center align-middle max-w-[80px] h-6 sticky z-10"
                                                style={{ left: `${stickyPositions['module']}px` }}
                                            >
                                                <span
                                                    className="whitespace-normal break-words px-4 text-center flex-1"
                                                    title={row.moduleName === "Default Module" ? "-" : row.moduleName}
                                                >
                                                    {row.moduleName === "Default Module" ? "-" : row.moduleName}
                                                </span>
                                            </TableCell>
                                        )}
                                        {displayHierarchy.includes('Sub Module') && isFirstSubtopicInSubModule && (
                                            <TableCell
                                                rowSpan={spans.subModuleSpans[row.subModuleId]}
                                                className="border border-gray-400 text-left p-0.5 bg-green-50 text-[10px] font-medium text-center align-middle max-w-[80px] h-6 sticky z-10"
                                                style={{ left: `${stickyPositions['subModule']}px` }}
                                            >
                                                <span
                                                    className="whitespace-nowrap overflow-hidden text-ellipsis block px-1"
                                                    title={row.subModuleName === "Default Submodule" ? "-" : row.subModuleName}
                                                >
                                                    {row.subModuleName === "Default Submodule" ? "-" : row.subModuleName}
                                                </span>
                                            </TableCell>
                                        )}
                                        {displayHierarchy.includes('Topic') && isFirstSubtopicInTopic && (
                                            <TableCell
                                                rowSpan={spans.topicSpans[row.topicId]}
                                                className="border border-gray-400 text-left p-0.5 bg-green-50 text-[10px] font-medium text-center align-middle max-w-[80px] h-6 sticky z-10"
                                                style={{ left: `${stickyPositions['topic']}px` }}
                                            >
                                                <span
                                                    className="whitespace-nowrap overflow-hidden text-ellipsis block px-1"
                                                    title={row.topicName === "Default Topic" ? "-" : row.topicName}
                                                >
                                                    {row.topicName === "Default Topic" ? "-" : row.topicName}
                                                </span>
                                            </TableCell>
                                        )}
                                        {displayHierarchy.includes('Sub Topic') && (
                                            <TableCell
                                                className="border border-gray-400 text-left p-0.5 bg-green-50 text-[10px] font-medium text-center align-middle max-w-[80px] h-6 sticky z-10"
                                                style={{ left: `${stickyPositions['subTopic']}px` }}
                                            >
                                                <span
                                                    className="whitespace-nowrap overflow-hidden text-ellipsis block px-1"
                                                    title={row.subtopicName === "Default Subtopic" ? "-" : row.subtopicName}
                                                >
                                                    {row.subtopicName === "Default Subtopic" ? "-" : row.subtopicName}
                                                </span>
                                            </TableCell>
                                        )}
                                    </TableRow>
                                );
                            });
                        })()}
                    </TableBody>
                </Table>
            </div>
        );
    };
    const CoursePreviewPopup = () => {
        if (!previewCourse) return null;

        const previewTableRows = createDuplicateTableRows();
        const spans = getDuplicateSpans();

        return (
            <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                className="fixed inset-0 bg-black/50 backdrop-blur-sm z-[60] flex items-center justify-center p-4"
            >
                <motion.div
                    initial={{ scale: 0.95, opacity: 0 }}
                    animate={{ scale: 1, opacity: 1 }}
                    transition={{ type: "spring", damping: 25, stiffness: 300 }}
                    className="bg-white rounded-xl shadow-lg w-full max-w-7xl max-h-[95vh] flex flex-col overflow-hidden border border-gray-200"
                >
                    {/* Header */}
                    <div className="flex justify-between items-center px-4 py-2 bg-gradient-to-r from-blue-600 to-indigo-700 text-white">
                        <div className="flex items-center gap-1.5">
                            <Eye className="w-4 h-4" />
                            <h2 className="text-base font-semibold">Course Preview - {previewCourse.courseName}</h2>
                        </div>
                        <button
                            onClick={() => setShowCoursePreview(false)}
                            className="p-1.5 cursor-pointer hover:bg-red-600/80 bg-red-500 rounded-md transition"
                        >
                            <X className="w-3.5 h-3.5" />
                        </button>
                    </div>

                    {/* Content */}
                    <div className="flex-1 overflow-auto thin-scrollbar p-4 space-y-3">

                        {/* Course Info */}
                        <div className="grid grid-cols-3 gap-3 text-xs">
                            <div className="bg-gray-50 p-2 rounded-md">
                                <span className="font-medium text-gray-700">Course Name:</span>
                                <p className="text-gray-900">{previewCourse.courseName}</p>
                            </div>
                            <div className="bg-gray-50 p-2 rounded-md">
                                <span className="font-medium text-gray-700">Hierarchy:</span>
                                <p className="text-gray-900">{previewCourse.courseHierarchy.join(' → ')}</p>
                            </div>
                            {previewCourse.category && (
                                <div className="bg-gray-50 p-2 rounded-md">
                                    <span className="font-medium text-gray-700">Category:</span>
                                    <p className="text-gray-900">{previewCourse.category}</p>
                                </div>
                            )}
                        </div>

                        {/* Preview Table - Show ALL hierarchy levels without checkboxes */}
                        <div className="border border-gray-200 overflow-hidden">
                            <div className="max-h-96 overflow-auto thin-scrollbar">
                                <FullCoursePreviewTable
                                    tableRows={previewTableRows}
                                    selectedCourse={previewCourse}
                                    moduleSpans={spans.moduleSpans}
                                    subModuleSpans={spans.subModuleSpans}
                                    topicSpans={spans.topicSpans}
                                    subtopicSpans={spans.subtopicSpans}
                                />
                            </div>
                        </div>

                        {/* Statistics */}
                        <div className="grid grid-cols-4 gap-2 text-[11px]">
                            {[
                                {
                                    label: "Modules",
                                    color: "blue",
                                    count: duplicateModules.filter(m => m.courses.includes(previewCourse._id)).length,
                                },
                                {
                                    label: "Sub Modules",
                                    color: "green",
                                    count: duplicateSubModules.filter(sm => sm.courses.includes(previewCourse._id)).length,
                                },
                                {
                                    label: "Topics",
                                    color: "orange",
                                    count: duplicateTopics.filter(t => t.courses.includes(previewCourse._id)).length,
                                },
                                {
                                    label: "Sub Topics",
                                    color: "purple",
                                    count: duplicateSubTopics.filter(st => st.courses === previewCourse._id).length,
                                },
                            ].map((item, index) => (
                                <div
                                    key={index}
                                    className={`flex flex-col items-center justify-center rounded-full border border-${item.color}-200 bg-${item.color}-50 text-${item.color}-700 py-2 px-1 shadow-sm`}
                                >
                                    <span className={`text-${item.color}-600 font-semibold text-[13px]`}>
                                        {item.count}
                                    </span>
                                    <span className="text-[10px] font-medium">{item.label}</span>
                                </div>
                            ))}
                        </div>


                    </div>
                </motion.div>
            </motion.div>
        );
    };

    const hasValuesInSelectedCells = (type: "iDo" | "weDo" | "youDo", activity: string, selectedRows: number[]) => {
        return selectedRows.some(rowIndex => {
            const row = tableRows[rowIndex];
            const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];

            // Get effective IDs based on hierarchy
            const effectiveTopicId = hierarchyLevels.includes('topic')
                ? row.topicId
                : `${row.moduleId}-default-topic`;
            const effectiveSubtopicId = hierarchyLevels.includes('sub topic')
                ? row.subtopicId
                : hierarchyLevels.includes('topic')
                    ? `${row.topicId}-default-subtopic`
                    : `${row.moduleId}-default-subtopic`;

            // Check for merged cells first
            const mergeInfo = isCellMerged(rowIndex, type, activity);
            if (mergeInfo.isMerged && mergeInfo.value > 0) {
                return true;
            }

            // Check individual cell value
            const cellValue = courseHours[row.moduleId]?.[effectiveTopicId]?.[effectiveSubtopicId]?.[type]?.[activity] || 0;
            return cellValue > 0;
        });
    };
    const mergeCells = (type: "iDo" | "weDo" | "youDo", activity: string, selectedRowsArray?: number[]) => {
        // Use provided selectedRowsArray or get from selectedCells state
        const rowsToMerge = selectedRowsArray || Array.from(selectedCells)
            .filter(key => key.endsWith(`::${type}::${activity}`))
            .map(key => parseInt(key.split('::')[0]))
            .sort((a, b) => a - b);

        if (rowsToMerge.length < 2) {
            showError("Please select at least 2 rows to merge!");
            return;
        }

        // Check if selected rows are consecutive
        let canMerge = true;
        for (let i = 1; i < rowsToMerge.length; i++) {
            if (rowsToMerge[i] !== rowsToMerge[i - 1] + 1) {
                canMerge = false;
                break;
            }
        }

        if (!canMerge) {
            showError("Selected rows must be consecutive to merge!");
            return;
        }

        // Check hierarchy validity for all selected rows


        // Check if any selected cell already has a value
        const hasValues = hasValuesInSelectedCells(type, activity, rowsToMerge);

        if (hasValues) {
            showError(`Cannot merge - one or more selected cells already have values for ${activity} (${type}).`);
            return;
        }
        const mergeStatuses = rowsToMerge.map(rowIndex => {
            const mergeInfo = isCellMerged(rowIndex, type, activity);
            return mergeInfo.isMerged;
        });

        const hasMixedMergeStatus = new Set(mergeStatuses).size > 1;
        if (hasMixedMergeStatus) {
            showError("Cannot merge already merged cells with individual cells!");
            return;
        }
        // Collect all hierarchy IDs from selected rows
        const modules = new Set<string>();
        const subModules = new Set<string>();
        const topics = new Set<string>();
        const subTopics = new Set<string>();
        const rowIds: string[] = [];

        rowsToMerge.forEach(rowIndex => {
            const row = tableRows[rowIndex];
            if (row.moduleId) modules.add(row.moduleId);
            if (row.subModuleId) subModules.add(row.subModuleId);
            if (row.topicId) topics.add(row.topicId);
            if (row.subtopicId) subTopics.add(row.subtopicId);
            rowIds.push(row.rowId);
        });

        // Set up pending merge and show dialog
        setPendingMerge({
            type: type,
            activity,
            selectedRows: rowsToMerge,
            hierarchyIds: {
                modules: Array.from(modules),
                subModules: Array.from(subModules),
                topics: Array.from(topics),
                subTopics: Array.from(subTopics)
            }
        });
        setMergeHours("");
        setShowMergeDialog(true);
    };
    const confirmMerge = async () => {
        if (!pendingMerge || !selectedCourse) return;
        setIsMergeConfirm(true);
        const hours = Number.parseFloat(mergeHours) || 0;
        const { type, activity, selectedRows: selectedRowsArray, hierarchyIds } = pendingMerge;
        if (hasValuesInSelectedCells(type, activity, selectedRowsArray)) {
            setErrorMessage(`Cannot merge - one or more selected cells already have values for ${activity} (${type}).`);
            setShowErrorDialog(true);
            setShowMergeDialog(false);
            return;
        }

        try {
            const columnKey = `${type}-${activity}`;
            const rowIds = selectedRowsArray.map((rowIndex) => tableRows[rowIndex].rowId);

            const newMerge: MergedCell = {
                startRow: selectedRowsArray[0],
                endRow: selectedRowsArray[selectedRowsArray.length - 1],
                value: hours,
                type,
                activity,
                rowIds,
                hierarchyIds: hierarchyIds || {
                    modules: [],
                    subModules: [],
                    topics: [],
                    subTopics: []
                }
            };

            setMergedCells((prev) => ({
                ...prev,
                [columnKey]: [...(prev[columnKey] || []), newMerge],
            }));

            // Prepare pedagogy data based on course hierarchy
            const hierarchyLevels = selectedCourse.courseHierarchy.map(l => l.toLowerCase());
            const pedagogies = [{
                iDo: type === "iDo" ? [{ type: activity, duration: hours }] : [],
                weDo: type === "weDo" ? [{ type: activity, duration: hours }] : [],
                youDo: type === "youDo" ? [{ type: activity, duration: hours }] : [],
                // Only include hierarchy levels that exist in the course
                ...(hierarchyIds?.modules && hierarchyIds.modules.filter(id => !id.includes('placeholder') && !id.includes('none')).length > 0 && {
                    module: hierarchyIds.modules.filter(id => !id.includes('placeholder') && !id.includes('none'))
                }),
                ...(hierarchyIds?.subModules && hierarchyIds.subModules.filter(id => !id.includes('placeholder') && !id.includes('none')).length > 0 && {
                    subModule: hierarchyIds.subModules.filter(id => !id.includes('placeholder') && !id.includes('none'))
                }),
                ...(hierarchyIds?.topics && hierarchyIds.topics.filter(id => !id.includes('placeholder') && !id.includes('none')).length > 0 && {
                    topic: hierarchyIds.topics.filter(id => !id.includes('placeholder') && !id.includes('none'))
                }),
                ...(hierarchyIds?.subTopics && hierarchyIds.subTopics.filter(id => !id.includes('placeholder') && !id.includes('none')).length > 0 && {
                    subTopic: hierarchyIds.subTopics.filter(id => !id.includes('placeholder') && !id.includes('none'))
                })
            }];

            const payload = {
                courses: selectedCourse._id,
                pedagogies: pedagogyViews?.[0]?.pedagogies
                    ? [...pedagogyViews[0].pedagogies, ...pedagogies]
                    : pedagogies,
            };

            // Save to backend
            await pedagogyMutation.mutateAsync(payload);



            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 2000);
        } catch (error) {
            console.error("Failed to merge cells:", error);
            alert("Failed to merge cells. Please try again.");
        } finally {

            setIsMergeConfirm(false);
            setShowMergeDialog(false);
            setPendingMerge(null);
            setMergeHours("");
        }
    };
    const unmergeCell = (type: "iDo" | "weDo" | "youDo" | "all", activity: string, mergeIndex: number, hierarchyIds?: any) => {
        // Determine the actual type when "all" is selected
        const actualType = selectedPedagogyTypes.includes("all")
            ? activityTypes["iDo"].includes(activity) ? "iDo"
                : activityTypes["weDo"].includes(activity) ? "weDo"
                    : "youDo"
            : type;

        setPendingUnmerge({
            type: actualType,
            activity,
            mergeIndex,
            hierarchyIds // Add hierarchyIds to pendingUnmerge
        });
        setShowUnmergeDialog(true);
    };
    const confirmUnmerge = async () => {
        if (!pendingUnmerge || !token || !selectedCourse) {
            setShowUnmergeDialog(false);
            return;
        }
        setIsUnmergeConfirm(true);

        try {
            const { type, activity, mergeIndex, hierarchyIds } = pendingUnmerge;
            const columnKey = `${type}-${activity}`;

            // For backend merges (mergeIndex = -2)
            if (mergeIndex === -2) {
                // Find the pedagogy item in the backend data that matches the hierarchy
                const pedagogyToUpdate = pedagogyViews?.[0];

                if (!pedagogyToUpdate) {
                    throw new Error("Pedagogy data not found");
                }

                // Find the matching pedagogy item
                const matchingPedagogyIndex = pedagogyToUpdate.pedagogies.findIndex(p => {
                    const matchesType =
                        (type === "iDo" && p.iDo.some(i => i.type === activity)) ||
                        (type === "weDo" && p.weDo.some(w => w.type === activity)) ||
                        (type === "youDo" && p.youDo.some(y => y.type === activity));

                    const matchesHierarchy =
                        JSON.stringify(p.module || []) === JSON.stringify(hierarchyIds?.modules || []) &&
                        JSON.stringify(p.subModule || []) === JSON.stringify(hierarchyIds?.subModules || []) &&
                        JSON.stringify(p.topic || []) === JSON.stringify(hierarchyIds?.topics || []) &&
                        JSON.stringify(p.subTopic || []) === JSON.stringify(hierarchyIds?.subTopics || []);

                    return matchesType && matchesHierarchy;
                });

                if (matchingPedagogyIndex !== -1) {
                    const matchingPedagogy = pedagogyToUpdate.pedagogies[matchingPedagogyIndex];

                    // Find the specific activity to delete
                    let activityToDelete;

                    if (type === "iDo") {
                        activityToDelete = matchingPedagogy.iDo.find(i => i.type === activity);
                    } else if (type === "weDo") {
                        activityToDelete = matchingPedagogy.weDo.find(w => w.type === activity);
                    } else {
                        activityToDelete = matchingPedagogy.youDo.find(y => y.type === activity);
                    }

                    if (activityToDelete && activityToDelete._id) {
                        // Use deletePedagogyMutation to delete the specific activity
                        await deletePedagogyMutation.mutateAsync({
                            activityType: type,
                            itemId: activityToDelete._id
                        });
                    } else {
                        // If we can't find the specific activity, remove the entire pedagogy item
                        const updatedPedagogies = pedagogyToUpdate.pedagogies.filter((_, index) => index !== matchingPedagogyIndex);

                        await pedagogyViewApi.update(pedagogyViews[0]._id).mutationFn({
                            courses: selectedCourse._id,
                            pedagogies: updatedPedagogies
                        });
                    }
                }
            } else {
                // For frontend merges
                const mergeToRemove = mergedCells[columnKey]?.[mergeIndex];

                if (!mergeToRemove) {
                    throw new Error("Merge data not found");
                }

                // Find the pedagogy item in the backend data
                const pedagogyToUpdate = pedagogyViews?.[0];

                if (pedagogyToUpdate) {
                    // Find the matching pedagogy item
                    const matchingPedagogyIndex = pedagogyToUpdate.pedagogies.findIndex(p => {
                        const matchesType =
                            (type === "iDo" && p.iDo.some(i => i.type === activity)) ||
                            (type === "weDo" && p.weDo.some(w => w.type === activity)) ||
                            (type === "youDo" && p.youDo.some(y => y.type === activity));

                        const matchesHierarchy =
                            JSON.stringify(p.module || []) === JSON.stringify(mergeToRemove.hierarchyIds?.modules || []) &&
                            JSON.stringify(p.subModule || []) === JSON.stringify(mergeToRemove.hierarchyIds?.subModules || []) &&
                            JSON.stringify(p.topic || []) === JSON.stringify(mergeToRemove.hierarchyIds?.topics || []) &&
                            JSON.stringify(p.subTopic || []) === JSON.stringify(mergeToRemove.hierarchyIds?.subTopics || []);

                        return matchesType && matchesHierarchy;
                    });

                    if (matchingPedagogyIndex !== -1) {
                        const matchingPedagogy = pedagogyToUpdate.pedagogies[matchingPedagogyIndex];

                        // Find the specific activity to delete
                        let activityToDelete;

                        if (type === "iDo") {
                            activityToDelete = matchingPedagogy.iDo.find(i => i.type === activity);
                        } else if (type === "weDo") {
                            activityToDelete = matchingPedagogy.weDo.find(w => w.type === activity);
                        } else {
                            activityToDelete = matchingPedagogy.youDo.find(y => y.type === activity);
                        }

                        if (activityToDelete && activityToDelete._id) {
                            // Use deletePedagogyMutation to delete the specific activity
                            await deletePedagogyMutation.mutateAsync({
                                activityType: type,
                                itemId: activityToDelete._id
                            });
                        } else {
                            // If we can't find the specific activity, remove the entire pedagogy item
                            const updatedPedagogies = pedagogyToUpdate.pedagogies.filter((_, index) => index !== matchingPedagogyIndex);

                            await pedagogyViewApi.update(pedagogyViews[0]._id).mutationFn({
                                courses: selectedCourse._id,
                                pedagogies: updatedPedagogies
                            });
                        }
                    }
                }

                // Update local state to remove the merge
                setMergedCells(prev => ({
                    ...prev,
                    [columnKey]: prev[columnKey]?.filter((_, index) => index !== mergeIndex) || [],
                }));
            }

            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 2000);
        } catch (error) {
            console.error("Error unmerging cells:", error);
            setErrorMessage(error instanceof Error ? error.message : "Failed to unmerge cells");
            setShowErrorDialog(true);
        } finally {
            setShowUnmergeDialog(false);
            setPendingUnmerge(null);
            setIsUnmergeConfirm(false);
        }
    };
    const isCellMerged = (rowIndex: number, type: "iDo" | "weDo" | "youDo", activity: string) => {
        const actualType = selectedPedagogyTypes.includes("all")
            ? activityTypes["iDo"].includes(activity) ? "iDo"
                : activityTypes["weDo"].includes(activity) ? "weDo"
                    : "youDo"
            : type;

        const columnKey = `${type}-${activity}`;
        const merges = mergedCells[columnKey] || [];
        const row = tableRows[rowIndex];

        // First check backend pedagogy data for merged cells
        if (pedagogyViews && pedagogyViews.length > 0) {
            for (const view of pedagogyViews) {
                for (const pedagogy of view.pedagogies) {
                    const pedagogyModules = pedagogy.module || [];
                    const pedagogySubModules = pedagogy.subModule || [];
                    const pedagogyTopics = pedagogy.topic || [];
                    const pedagogySubTopics = pedagogy.subTopic || [];

                    // Check if this is a merged pedagogy (multiple IDs at any level)
                    const isMultiMerge = pedagogyModules.length > 1 || pedagogySubModules.length > 1 ||
                        pedagogyTopics.length > 1 || pedagogySubTopics.length > 1;

                    if (!isMultiMerge) continue;

                    // Check if this row matches the pedagogy hierarchy
                    const moduleMatch = pedagogyModules.length === 0 || pedagogyModules.includes(row.moduleId);
                    const subModuleMatch = pedagogySubModules.length === 0 ||
                        (!row.subModuleId || row.subModuleId.includes('placeholder')) ||
                        pedagogySubModules.includes(row.subModuleId);
                    const topicMatch = pedagogyTopics.length === 0 ||
                        (!row.topicId || row.topicId.includes('placeholder')) ||
                        pedagogyTopics.includes(row.topicId);
                    const subtopicMatch = pedagogySubTopics.length === 0 ||
                        (!row.subtopicId || row.subtopicId.includes('placeholder')) ||
                        pedagogySubTopics.includes(row.subtopicId);

                    if (moduleMatch && subModuleMatch && topicMatch && subtopicMatch) {
                        // Check if this specific activity type has data
                        const activityData = pedagogy[actualType]?.find((a: any) => a.type === activity);
                        if (activityData) {
                            // Find all affected rows for this pedagogy merge
                            const affectedRowIds = getAffectedRowIds(
                                pedagogyModules,
                                pedagogySubModules,
                                pedagogyTopics,
                                pedagogySubTopics,
                            );

                            const rowIndices = affectedRowIds
                                .map(rid => tableRows.findIndex(r => r.rowId === rid))
                                .filter(idx => idx !== -1)
                                .sort((a, b) => a - b);

                            if (rowIndices.length > 0) {
                                return {
                                    isMerged: true,
                                    isStart: rowIndex === rowIndices[0],
                                    rowSpan: rowIndices.length,
                                    value: activityData.duration,
                                    mergeIndex: -2, // Backend merge (different from frontend merge)
                                    hierarchyIds: { // Add this
                                        modules: pedagogyModules,
                                        subModules: pedagogySubModules,
                                        topics: pedagogyTopics,
                                        subTopics: pedagogySubTopics,
                                    },
                                    type: actualType
                                };
                            }
                        }
                    }
                }
            }
        }

        // Then check frontend merged cells (existing logic)
        for (const merge of merges) {
            const mergeModules = merge.hierarchyIds?.modules || [];
            const mergeSubModules = merge.hierarchyIds?.subModules || [];
            const mergeTopics = merge.hierarchyIds?.topics || [];
            const mergeSubTopics = merge.hierarchyIds?.subTopics || [];

            // Check module level
            if (mergeModules.length > 0 && !mergeModules.includes(row.moduleId)) {
                continue; // Module doesn't match
            }

            // Check submodule level with hierarchical logic
            if (mergeSubModules.length > 0) {
                // If row has a submodule, it must match one of the specified submodules
                if (row.subModuleId && !row.subModuleId.includes('placeholder')) {
                    if (!mergeSubModules.includes(row.subModuleId)) {
                        continue; // Submodule doesn't match
                    }
                }
                // If row has no submodule (module-level row), it's still valid
            } else {
                // If no submodules specified but row has a real submodule, skip
                if (row.subModuleId && !row.subModuleId.includes('placeholder')) {
                    continue;
                }
            }

            // Check topic level with hierarchical logic
            if (mergeTopics.length > 0) {
                // If row has a topic, it must match one of the specified topics
                if (row.topicId && !row.topicId.includes('placeholder')) {
                    if (!mergeTopics.includes(row.topicId)) {
                        continue; // Topic doesn't match
                    }
                }
                // If row has no topic (higher-level row), it's still valid
            } else {
                // If no topics specified but row has a real topic, skip
                if (row.topicId && !row.topicId.includes('placeholder')) {
                    continue;
                }
            }

            // Check subtopic level with hierarchical logic
            if (mergeSubTopics.length > 0) {
                // If row has a subtopic, it must match one of the specified subtopics
                if (row.subtopicId && !row.subtopicId.includes('placeholder')) {
                    if (!mergeSubTopics.includes(row.subtopicId)) {
                        continue; // Subtopic doesn't match
                    }
                }
                // If row has no subtopic (higher-level row), it's still valid
            } else {
                // If no subtopics specified but row has a real subtopic, skip
                if (row.subtopicId && !row.subtopicId.includes('placeholder')) {
                    continue;
                }
            }

            // If we reached here, the row matches the merge hierarchy
            const rowIndices = merge.rowIds
                .map(rid => tableRows.findIndex(r => r.rowId === rid))
                .filter(idx => idx !== -1)
                .sort((a, b) => a - b);

            if (rowIndices.length > 0) {
                return {
                    isMerged: true,
                    isStart: rowIndex === rowIndices[0],
                    rowSpan: rowIndices.length,
                    value: merge.value,
                    mergeIndex: merges.indexOf(merge),
                    hierarchyIds: merge.hierarchyIds,
                    type: actualType
                };
            }
        }

        return {
            isMerged: false,
            isStart: false,
            rowSpan: 1,
            value: 0,
            mergeIndex: -1,
            hierarchyIds: null,
            type: actualType
        };
    };
    const getSpans = () => {
        const moduleSpans: { [key: string]: number } = {};
        const subModuleSpans: { [key: string]: number } = {};
        const topicSpans: { [key: string]: number } = {};
        const subtopicSpans: { [key: string]: number } = {};

        const hasSubModules = selectedCourse?.courseHierarchy.includes('Sub Module') || false;
        const hasTopics = selectedCourse?.courseHierarchy.includes('Topic') || false;
        const hasSubTopics = selectedCourse?.courseHierarchy.includes('Sub Topic') || false;

        courseStructure.forEach((module) => {
            let moduleRowCount = 0;
            const moduleSubModules = subModules.filter(sub => sub.moduleId === module.id);

            if (hasSubModules && moduleSubModules.length > 0) {
                moduleSubModules.forEach((subModule) => {
                    let subModuleRowCount = 0;
                    const subModuleTopics = topics.filter(topic => topic.subModuleId === subModule._id);

                    if (hasTopics && subModuleTopics.length > 0) {
                        subModuleTopics.forEach(topic => {
                            const topicSubTopics = hasSubTopics
                                ? subTopics.filter(subTopic => subTopic.topicId === topic._id)
                                : [];
                            const topicRowCount = hasSubTopics && topicSubTopics.length > 0
                                ? topicSubTopics.length
                                : 1;

                            if (hasSubTopics) {
                                subtopicSpans[topic._id] = topicRowCount;
                            }
                            topicSpans[topic._id] = topicRowCount;
                            subModuleRowCount += topicRowCount;
                        });
                    } else {
                        subModuleRowCount = 1;
                    }

                    subModuleSpans[subModule._id] = subModuleRowCount;
                    moduleRowCount += subModuleRowCount;
                });
            } else {
                // No submodules in hierarchy or no submodules exist
                const moduleTopics = topics.filter(topic => topic.moduleId === module.id);

                if (hasTopics && moduleTopics.length > 0) {
                    moduleTopics.forEach(topic => {
                        const topicSubTopics = hasSubTopics
                            ? subTopics.filter(subTopic => subTopic.topicId === topic._id)
                            : [];
                        const topicRowCount = hasSubTopics && topicSubTopics.length > 0
                            ? topicSubTopics.length
                            : 1;

                        if (hasSubTopics) {
                            subtopicSpans[topic._id] = topicRowCount;
                        }
                        topicSpans[topic._id] = topicRowCount;
                        moduleRowCount += topicRowCount;
                    });
                } else {
                    moduleRowCount = 1;
                }
            }

            moduleSpans[module.id] = moduleRowCount;
        });

        return {
            moduleSpans,
            subModuleSpans: hasSubModules ? subModuleSpans : {},
            topicSpans: hasTopics ? topicSpans : {},
            subtopicSpans: hasSubTopics ? subtopicSpans : {}
        };
    };
    const { moduleSpans, subModuleSpans, topicSpans } = getSpans()

    const ValidationFeedback = () => {
        if (!mergeSelectionMode || selectedMergeCells.size === 0) return null;

        const selectedRows = Array.from(selectedMergeCells)
            .map(cellKey => {
                if (mergeSelectionMode === 'level') {
                    const rowId = cellKey.replace('level::', '');
                    return tableRows.findIndex(row => row.rowId === rowId);
                } else {
                    const parts = cellKey.split('::');
                    const rowId = parts.slice(2).join('::');
                    return tableRows.findIndex(row => row.rowId === rowId);
                }
            })
            .filter(idx => idx !== -1)
            .sort((a, b) => a - b);

        // Check if at least 2 rows are selected
        if (selectedRows.length < 2) {
            return (
                <div className="fixed top-40 right-4 z-50 bg-yellow-900 p-3 rounded-lg shadow-lg border border-yellow-700">
                    <div className="flex items-center gap-2">
                        <AlertTriangle className="h-4 w-4 text-yellow-300" />
                        <span className="text-sm text-yellow-100">Please select at least 2 rows to merge!</span>
                    </div>
                </div>
            );
        }

        // Check if selected rows are consecutive
        let isConsecutive = true;
        for (let i = 1; i < selectedRows.length; i++) {
            if (selectedRows[i] !== selectedRows[i - 1] + 1) {
                isConsecutive = false;
                break;
            }
        }



        // Check hierarchy validity for all selected rows


        if (mergeSelectionMode === 'level') {
            // Check if any selected row already has a level value
            const hasLevelValues = selectedRows.some(rowIndex => {
                const row = tableRows[rowIndex];
                const levelInfo = isLevelMerged(rowIndex);
                return levelInfo.value && levelInfo.value !== "-";
            });

            if (hasLevelValues) {
                return (
                    <div className="fixed top-40 right-4 z-50 bg-red-900 p-3 rounded-lg shadow-lg border border-red-700">
                        <div className="flex items-center gap-2">
                            <AlertCircle className="h-4 w-4 text-red-300" />
                            <span className="text-sm text-red-100">Cannot merge - one or more selected rows already have level values!</span>
                        </div>
                    </div>
                );
            }
            if (!isConsecutive) {
                return (
                    <div className="fixed top-40 right-4 z-50 bg-yellow-900 p-3 rounded-lg shadow-lg border border-yellow-700">
                        <div className="flex items-center gap-2">
                            <AlertTriangle className="h-4 w-4 text-yellow-300" />
                            <span className="text-sm text-yellow-100">Selected rows must be consecutive to merge!</span>
                        </div>
                    </div>
                );
            }
        } else {
            // For pedagogy, check if we have a consistent type and activity
            const cellTypes = new Set();
            const cellActivities = new Set();

            Array.from(selectedMergeCells).forEach(cellKey => {
                const parts = cellKey.split('::');
                cellTypes.add(parts[0]);
                cellActivities.add(parts[1]);
            });

            if (cellTypes.size > 1 || cellActivities.size > 1) {
                return (
                    <div className="fixed top-40 right-4 z-50 bg-red-900 p-3 rounded-lg shadow-lg border border-red-700">
                        <div className="flex items-center gap-2">
                            <AlertCircle className="h-4 w-4 text-red-300" />
                            <span className="text-sm text-red-100">Cannot merge different types of activities!</span>
                        </div>
                    </div>
                );
            }

            // Check if any selected cell already has a value (including merged cells)
            const firstCellKey = Array.from(selectedMergeCells)[0];
            const [type, activity] = firstCellKey.split('::').slice(0, 2);

            const hasValues = selectedRows.some(rowIndex => {
                const row = tableRows[rowIndex];
                const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];
                const effectiveTopicId = hierarchyLevels.includes('topic')
                    ? row.topicId
                    : `${row.moduleId}-default-topic`;
                const effectiveSubtopicId = hierarchyLevels.includes('sub topic')
                    ? row.subtopicId
                    : hierarchyLevels.includes('topic')
                        ? `${row.topicId}-default-subtopic`
                        : `${row.moduleId}-default-subtopic`;

                // Check for merged cells first
                const mergeInfo = isCellMerged(rowIndex, type as "iDo" | "weDo" | "youDo", activity);
                if (mergeInfo.isMerged && mergeInfo.value > 0) {
                    return true;
                }

                // Check individual cell value
                const cellValue = courseHours[row.moduleId]?.[effectiveTopicId]?.[effectiveSubtopicId]?.[type as "iDo" | "weDo" | "youDo"]?.[activity] || 0;
                return cellValue > 0;
            });

            if (hasValues) {
                return (
                    <div className="fixed top-40 right-4 z-50 bg-red-900 p-3 rounded-lg shadow-lg border border-red-700">
                        <div className="flex items-center gap-2">
                            <AlertCircle className="h-4 w-4 text-red-300" />
                            <span className="text-sm text-red-100">Cannot merge - one or more selected cells already have values!</span>
                        </div>
                    </div>
                );
            }

            // Check if we're trying to merge a mix of merged and unmerged cells
            const mergeStatuses = selectedRows.map(rowIndex => {
                const mergeInfo = isCellMerged(rowIndex, type as "iDo" | "weDo" | "youDo", activity);
                return mergeInfo.isMerged;
            });

            const hasMixedMergeStatus = new Set(mergeStatuses).size > 1;
            if (hasMixedMergeStatus) {
                return (
                    <div className="fixed top-40 right-4 z-50 bg-red-900 p-3 rounded-lg shadow-lg border border-red-700">
                        <div className="flex items-center gap-2">
                            <AlertCircle className="h-4 w-4 text-red-300" />
                            <span className="text-sm text-red-100">Cannot merge already merged cells with individual cells!</span>
                        </div>
                    </div>
                );
            }
            if (!isConsecutive) {
                return (
                    <div className="fixed top-40 right-4 z-50 bg-yellow-900 p-3 rounded-lg shadow-lg border border-yellow-700">
                        <div className="flex items-center gap-2">
                            <AlertTriangle className="h-4 w-4 text-yellow-300" />
                            <span className="text-sm text-yellow-100">Selected rows must be consecutive to merge!</span>
                        </div>
                    </div>
                );
            }
        }

        return (
            <div className="fixed top-40 right-4 z-50 bg-green-900 p-3 rounded-lg shadow-lg border border-green-700">
                <div className="flex items-center gap-2">
                    <CheckCircle className="h-4 w-4 text-green-300" />
                    <span className="text-sm text-green-100">Selection valid for merging</span>
                </div>
            </div>
        );
    };
    const handleLevelSave = async () => {
        if (!editingLevel || !selectedCourse) return;
        setIsLevelSave(true);

        try {
            const hierarchyLevels = selectedCourse.courseHierarchy.map(l => l.toLowerCase());
            const filterPlaceholders = (ids: string[] = []) => {
                return ids.filter(id => id && !id.includes('placeholder'));
            };
            const levelData = {
                // Only include non-placeholder hierarchy levels
                ...(hierarchyLevels.includes("module") && editingLevel.hierarchy.module && {
                    module: filterPlaceholders(editingLevel.hierarchy.module)
                }),
                ...(hierarchyLevels.includes("sub module") && editingLevel.hierarchy.subModule && {
                    subModule: filterPlaceholders(editingLevel.hierarchy.subModule)
                }),
                ...(hierarchyLevels.includes("topic") && editingLevel.hierarchy.topic && {
                    topic: filterPlaceholders(editingLevel.hierarchy.topic)
                }),
                ...(hierarchyLevels.includes("sub topic") && editingLevel.hierarchy.subTopic && {
                    subTopic: filterPlaceholders(editingLevel.hierarchy.subTopic)
                }),
                level: editingLevel.level,
            };

            await levelViewMutation.mutateAsync({
                courses: selectedCourse._id,
                levels: [...levelsData.filter((l: { module: any; subModule: any; topic: any; subTopic: any; }) =>
                    !(JSON.stringify(l.module || []) === JSON.stringify(levelData.module || []) &&
                        JSON.stringify(l.subModule || []) === JSON.stringify(levelData.subModule || []) &&
                        JSON.stringify(l.topic || []) === JSON.stringify(levelData.topic || []) &&
                        JSON.stringify(l.subTopic || []) === JSON.stringify(levelData.subTopic || []))
                ), levelData]
            });

            setShowLevelDialog(false);
            setEditingLevel(null);
        } catch (error) {
            console.error("Failed to save level:", error);
            setErrorMessage(error instanceof Error ? error.message : "Failed to save level");
            setShowErrorDialog(true);
        } finally {
            setIsLevelSave(false);
        }
    };
    const confirmLevelMerge = async () => {
        if (!pendingLevelMerge || !selectedCourse) return;
        setIsLevelMergeSave(true);

        try {
            const { selectedRows: selectedRowsArray, hierarchyIds } = pendingLevelMerge;
            const filterPlaceholders = (ids: string[] = []) => {
                return ids.filter(id => id && !id.includes('placeholder'));
            };
            const filteredHierarchyIds = {
                modules: filterPlaceholders(hierarchyIds?.modules),
                subModules: filterPlaceholders(hierarchyIds?.subModules),
                topics: filterPlaceholders(hierarchyIds?.topics),
                subTopics: filterPlaceholders(hierarchyIds?.subTopics)
            };
            const levelData = {
                // Only include non-placeholder hierarchy levels
                ...(filteredHierarchyIds.modules.length > 0 && { module: filteredHierarchyIds.modules }),
                ...(filteredHierarchyIds.subModules.length > 0 && { subModule: filteredHierarchyIds.subModules }),
                ...(filteredHierarchyIds.topics.length > 0 && { topic: filteredHierarchyIds.topics }),
                ...(filteredHierarchyIds.subTopics.length > 0 && { subTopic: filteredHierarchyIds.subTopics }),
                level: mergeLevelValue,
            };

            await levelViewMutation.mutateAsync({
                courses: selectedCourse._id,
                levels: [...levelsData, levelData]
            });


            setShowMergeLevelDialog(false);
            setPendingLevelMerge(null);
            setMergeLevelValue("");
        } catch (error) {
            console.error("Failed to merge levels:", error);
            setErrorMessage(error instanceof Error ? error.message : "Failed to merge levels");
            setShowErrorDialog(true);
        } finally {
            setIsLevelMergeSave(false);
        }
    };
    const isLevelMerged = (rowIndex: number) => {
        const row = tableRows[rowIndex];

        // Check for backend level data
        const matchingLevel = levelsData.find((level: any) => {
            const levelModules = level.module || [];
            const levelSubModules = level.subModule || [];
            const levelTopics = level.topic || [];
            const levelSubTopics = level.subTopic || [];

            // Check module level
            if (levelModules.length > 0 && !levelModules.includes(row.moduleId)) {
                return false; // Module doesn't match
            }

            // Check submodule level with hierarchical logic
            if (levelSubModules.length > 0) {
                // If row has a submodule, it must match one of the specified submodules
                if (row.subModuleId && !row.subModuleId.includes('placeholder')) {
                    if (!levelSubModules.includes(row.subModuleId)) {
                        return false; // Submodule doesn't match
                    }
                }
                // If row has no submodule (module-level row), it's still valid
            } else {
                // If no submodules specified but row has a real submodule, skip
                if (row.subModuleId && !row.subModuleId.includes('placeholder')) {
                    return false;
                }
            }

            // Check topic level with hierarchical logic
            if (levelTopics.length > 0) {
                // If row has a topic, it must match one of the specified topics
                if (row.topicId && !row.topicId.includes('placeholder')) {
                    if (!levelTopics.includes(row.topicId)) {
                        return false; // Topic doesn't match
                    }
                }
                // If row has no topic (higher-level row), it's still valid
            } else {
                // If no topics specified but row has a real topic, skip
                if (row.topicId && !row.topicId.includes('placeholder')) {
                    return false;
                }
            }

            // Check subtopic level with hierarchical logic
            if (levelSubTopics.length > 0) {
                // If row has a subtopic, it must match one of the specified subtopics
                if (row.subtopicId && !row.subtopicId.includes('placeholder')) {
                    if (!levelSubTopics.includes(row.subtopicId)) {
                        return false; // Subtopic doesn't match
                    }
                }
                // If row has no subtopic (higher-level row), it's still valid
            } else {
                // If no subtopics specified but row has a real subtopic, skip
                if (row.subtopicId && !row.subtopicId.includes('placeholder')) {
                    return false;
                }
            }

            return true;
        });

        if (matchingLevel) {
            // Check if this is a merged level (multiple IDs at any level)
            const isMultiMerge = (matchingLevel.module && matchingLevel.module.length > 1) ||
                (matchingLevel.subModule && matchingLevel.subModule.length > 1) ||
                (matchingLevel.topic && matchingLevel.topic.length > 1) ||
                (matchingLevel.subTopic && matchingLevel.subTopic.length > 1);

            if (isMultiMerge) {
                // This is a merged level - find all affected rows
                const affectedRowIds = getAffectedRowIds(
                    matchingLevel.module || [],
                    matchingLevel.subModule || [],
                    matchingLevel.topic || [],
                    matchingLevel.subTopic || [],
                );

                const mergeRowIndices = affectedRowIds
                    .map((rid) => tableRows.findIndex((r) => r.rowId === rid))
                    .filter((idx) => idx !== -1)
                    .sort((a, b) => a - b);

                if (mergeRowIndices.length > 0) {
                    return {
                        isMerged: true,
                        isStart: rowIndex === mergeRowIndices[0],
                        rowSpan: mergeRowIndices.length,
                        value: matchingLevel.level,
                        mergeIndex: -1, // Backend merge
                        hierarchyIds: {
                            modules: matchingLevel.module || [],
                            subModules: matchingLevel.subModule || [],
                            topics: matchingLevel.topic || [],
                            subTopics: matchingLevel.subTopic || [],
                        },
                    };
                }
            } else {
                // This is a single level
                return {
                    isMerged: false,
                    isStart: false,
                    rowSpan: 1,
                    value: matchingLevel.level,
                    mergeIndex: -1,
                    hierarchyIds: null,
                };
            }
        }

        // If no level found in database, check individual item level
        return {
            isMerged: false,
            isStart: false,
            rowSpan: 1,

            mergeIndex: -1,
            hierarchyIds: null,
        };
    };
    const handleDeleteLevel = (row: any, mergeInfo: any) => {
        if (mergeInfo.isMerged) {
            // Handle merged level deletion
            if (mergeInfo.mergeIndex !== -1) {
                unmergeLevel(mergeInfo.mergeIndex);
            } else {
                // Find backend level data using the same logic as isLevelMerged
                const backendLevel = levelsData.find((l: any) => {
                    const levelModules = l.module || [];
                    const levelSubModules = l.subModule || [];
                    const levelTopics = l.topic || [];
                    const levelSubTopics = l.subTopic || [];

                    // Check module level
                    if (levelModules.length > 0 && !levelModules.includes(row.moduleId)) {
                        return false; // Module doesn't match
                    }

                    // Check submodule level with hierarchical logic
                    if (levelSubModules.length > 0) {
                        // If row has a submodule, it must match one of the specified submodules
                        if (row.subModuleId && !row.subModuleId.includes('placeholder')) {
                            if (!levelSubModules.includes(row.subModuleId)) {
                                return false; // Submodule doesn't match
                            }
                        }
                        // If row has no submodule (module-level row), it's still valid
                    } else {
                        // If no submodules specified but row has a real submodule, skip
                        if (row.subModuleId && !row.subModuleId.includes('placeholder')) {
                            return false;
                        }
                    }

                    // Check topic level with hierarchical logic
                    if (levelTopics.length > 0) {
                        // If row has a topic, it must match one of the specified topics
                        if (row.topicId && !row.topicId.includes('placeholder')) {
                            if (!levelTopics.includes(row.topicId)) {
                                return false; // Topic doesn't match
                            }
                        }
                        // If row has no topic (higher-level row), it's still valid
                    } else {
                        // If no topics specified but row has a real topic, skip
                        if (row.topicId && !row.topicId.includes('placeholder')) {
                            return false;
                        }
                    }

                    // Check subtopic level with hierarchical logic
                    if (levelSubTopics.length > 0) {
                        // If row has a subtopic, it must match one of the specified subtopics
                        if (row.subtopicId && !row.subtopicId.includes('placeholder')) {
                            if (!levelSubTopics.includes(row.subtopicId)) {
                                return false; // Subtopic doesn't match
                            }
                        }
                        // If row has no subtopic (higher-level row), it's still valid
                    } else {
                        // If no subtopics specified but row has a real subtopic, skip
                        if (row.subtopicId && !row.subtopicId.includes('placeholder')) {
                            return false;
                        }
                    }

                    return true;
                });

                if (backendLevel) {
                    unmergeLevel(-1, backendLevel);
                } else {
                    setErrorMessage("Could not find level data to delete");
                    setShowErrorDialog(true);
                }
            }
        } else {
            // Handle single level deletion with filtered hierarchy
            const filterPlaceholders = (ids: string[] = []) => {
                return ids.filter(id => id && !id.includes('placeholder'));
            };

            setLevelToDelete({
                id: row.rowId,
                level: mergeInfo.value,
                hierarchy: {
                    module: filterPlaceholders([row.moduleId]),
                    subModule: filterPlaceholders(row.subModuleId ? [row.subModuleId] : []),
                    topic: filterPlaceholders(row.topicId ? [row.topicId] : []),
                    subTopic: filterPlaceholders(row.subtopicId ? [row.subtopicId] : [])
                }
            });
            setShowLevelDeleteConfirmation(true);
        }
    };

    // Helper function to compare arrays
    const arraysEqual = (a: any[], b: any[]) => {
        if (a.length !== b.length) return false;
        const sortedA = [...a].sort();
        const sortedB = [...b].sort();
        return sortedA.every((val, index) => val === sortedB[index]);
    };
    const renderLevelCell = (row: any, rowIndex: number) => {
        const mergeInfo = isLevelMerged(rowIndex);

        const isSelected = selectedMergeCells.has(`level::${row.rowId}`);
        const disabledClass = "cursor-pointer";
        const showCheckbox = mergeSelectionMode === 'level' && selectedMergeCells.size > 0;
        const hasValue = mergeInfo.value && mergeInfo.value !== "-";
        // Skip rendering if this is part of a merged cell but not the first row
        if (mergeInfo.isMerged && !mergeInfo.isStart) return null;

        return (
            <motion.td
                key={`level-${row.rowId}`}
                className={`border border-gray-400 text-center text-[10px] p-0.5 transition-colors
        ${mergeInfo.isMerged ? "bg-blue-200 hover:bg-blue-300" : "bg-blue-50 hover:bg-blue-100"}
        ${mergeInfo.isMerged ? "font-bold" : ""}
        min-w-[80px] h-[32px]
        ${disabledClass}
        sticky bg-white z-20
        ${isSelected ? "bg-blue-200 border-2 border-indigo-500 shadow-[0_0_0_2px_#3b82f6_inset]" : ""}`}
                style={{
                    left: getStickyLeftPosition(selectedCourse?.courseHierarchy.length || 0),
                }}
                rowSpan={mergeInfo.rowSpan}

            >
                <div className="relative w-full h-full flex items-center">
                    {/* Center - Value Display */}
                    <div className="absolute inset-0 flex items-center justify-center">
                        <span>{mergeInfo.value || "-"}</span>
                    </div>

                    {/* Right End - Action Menu or Checkbox */}
                    <div className="absolute right-0 top-1/2 transform -translate-y-1/2 z-10">
                        {showCheckbox ? (
                            <Checkbox
                                checked={selectedMergeCells.has(`level::${row.rowId}`)}
                                onCheckedChange={() => {


                                    setSelectedMergeCells(prev => {
                                        const newSelection = new Set(prev);
                                        if (newSelection.has(`level::${row.rowId}`)) {
                                            newSelection.delete(`level::${row.rowId}`);
                                        } else {
                                            newSelection.add(`level::${row.rowId}`);
                                        }
                                        return newSelection;
                                    });
                                }}

                                className="mr-1 h-5 w-5 rounded-sm border-1 border-gray-500
             data-[state=checked]:bg-gray-900 data-[state=checked]:border-gray-900
             data-[state=checked]:text-white shadow-sm transition-colors
             hover:border-gray-600 focus:outline-none"
                            />
                        ) : (
                            directActionsEnabled && (
                                <CellActionMenu
                                    cellType="level"
                                    cellKey={`level-${row.rowId}`}
                                    hasValue={hasValue}
                                    isMerged={mergeInfo.isMerged}

                                    onAdd={() => {
                                        // Handle add level for empty cell
                                        setIsNewLevel(true);
                                        setEditingLevel({
                                            id: null,
                                            level: '',
                                            hierarchy: {
                                                module: [row.moduleId],
                                                subModule: row.subModuleId ? [row.subModuleId] : [],
                                                topic: row.topicId ? [row.topicId] : [],
                                                subTopic: row.subtopicId ? [row.subtopicId] : []
                                            }
                                        });
                                        setShowLevelDialog(true);
                                    }}
                                    onEdit={() => {
                                        // For merged cells, use the hierarchy IDs from the merge info
                                        setIsNewLevel(false);

                                        // For merged cells, use the hierarchy IDs from the merge info
                                        // For single cells, use the row's hierarchy
                                        const hierarchyData: any = mergeInfo.isMerged
                                            ? mergeInfo.hierarchyIds
                                            : {
                                                modules: [row.moduleId],
                                                subModules: row.subModuleId ? [row.subModuleId] : [],
                                                topics: row.topicId ? [row.topicId] : [],
                                                subTopics: row.subtopicId ? [row.subtopicId] : []
                                            };

                                        // Find the existing level data for editing
                                        let existingLevelId = null;
                                        if (!mergeInfo.isMerged) {
                                            const existingLevel = levelsData.find((l: any) =>
                                                l.level === mergeInfo.value &&
                                                JSON.stringify(l.module || []) === JSON.stringify(hierarchyData.modules) &&
                                                JSON.stringify(l.subModule || []) === JSON.stringify(hierarchyData.subModules) &&
                                                JSON.stringify(l.topic || []) === JSON.stringify(hierarchyData.topics) &&
                                                JSON.stringify(l.subTopic || []) === JSON.stringify(hierarchyData.subTopics)
                                            );
                                            existingLevelId = existingLevel?._id || null;
                                        }

                                        setEditingLevel({
                                            id: mergeInfo.isMerged ? 'merged' : existingLevelId,
                                            level: mergeInfo.value,
                                            hierarchy: {
                                                ...(selectedCourse?.courseHierarchy.includes("Module") && {
                                                    module: hierarchyData.modules
                                                }),
                                                ...(selectedCourse?.courseHierarchy.includes("Sub Module") && {
                                                    subModule: hierarchyData.subModules
                                                }),
                                                ...(selectedCourse?.courseHierarchy.includes("Topic") && {
                                                    topic: hierarchyData.topics
                                                }),
                                                ...(selectedCourse?.courseHierarchy.includes("Sub Topic") && {
                                                    subTopic: hierarchyData.subTopics
                                                }),
                                            }
                                        });
                                        setShowLevelDialog(true);
                                    }}
                                    onDelete={() => {
                                        handleDeleteLevel(row, mergeInfo);
                                    }}
                                    onMerge={() => {
                                        setMergeSelectionMode('level');
                                        setSelectedMergeCells(new Set([`level::${row.rowId}`]));
                                    }}
                                    onUnmerge={mergeInfo.isMerged ? () => {
                                        if (mergeInfo.mergeIndex !== -1) {
                                            unmergeLevel(mergeInfo.mergeIndex);
                                        } else {
                                            // Find backend level data using the same logic as isLevelMerged
                                            const backendLevel = levelsData.find((l: any) => {
                                                const levelModules = l.module || [];
                                                const levelSubModules = l.subModule || [];
                                                const levelTopics = l.topic || [];
                                                const levelSubTopics = l.subTopic || [];

                                                // Check module level
                                                if (levelModules.length > 0 && !levelModules.includes(row.moduleId)) {
                                                    return false; // Module doesn't match
                                                }

                                                // Check submodule level with hierarchical logic
                                                if (levelSubModules.length > 0) {
                                                    // If row has a submodule, it must match one of the specified submodules
                                                    if (row.subModuleId && !row.subModuleId.includes('placeholder')) {
                                                        if (!levelSubModules.includes(row.subModuleId)) {
                                                            return false; // Submodule doesn't match
                                                        }
                                                    }
                                                    // If row has no submodule (module-level row), it's still valid
                                                } else {
                                                    // If no submodules specified but row has a real submodule, skip
                                                    if (row.subModuleId && !row.subModuleId.includes('placeholder')) {
                                                        return false;
                                                    }
                                                }

                                                // Check topic level with hierarchical logic
                                                if (levelTopics.length > 0) {
                                                    // If row has a topic, it must match one of the specified topics
                                                    if (row.topicId && !row.topicId.includes('placeholder')) {
                                                        if (!levelTopics.includes(row.topicId)) {
                                                            return false; // Topic doesn't match
                                                        }
                                                    }
                                                    // If row has no topic (higher-level row), it's still valid
                                                } else {
                                                    // If no topics specified but row has a real topic, skip
                                                    if (row.topicId && !row.topicId.includes('placeholder')) {
                                                        return false;
                                                    }
                                                }

                                                // Check subtopic level with hierarchical logic
                                                if (levelSubTopics.length > 0) {
                                                    // If row has a subtopic, it must match one of the specified subtopics
                                                    if (row.subtopicId && !row.subtopicId.includes('placeholder')) {
                                                        if (!levelSubTopics.includes(row.subtopicId)) {
                                                            return false; // Subtopic doesn't match
                                                        }
                                                    }
                                                    // If row has no subtopic (higher-level row), it's still valid
                                                } else {
                                                    // If no subtopics specified but row has a real subtopic, skip
                                                    if (row.subtopicId && !row.subtopicId.includes('placeholder')) {
                                                        return false;
                                                    }
                                                }

                                                return true;
                                            });

                                            if (backendLevel) {
                                                unmergeLevel(-1, backendLevel);
                                            } else {
                                                setErrorMessage("Could not find level data to unmerge");
                                                setShowErrorDialog(true);
                                            }
                                        }
                                    } : undefined}

                                />
                            )
                        )}
                    </div>
                </div>
            </motion.td>
        );
    };
    const unmergeLevel = async (mergeIndex: number, levelData?: any) => {
        if (mergeIndex === -1 && levelData) {
            // This is a backend level deletion (unmerge)
            // Set up pending unmerge and show confirmation dialog
            setPendingLevelUnmerge({
                mergeIndex,
                levelData
            });
            setShowUnmergeLevelDialog(true);
        } else {
            // For frontend merged levels
            setPendingLevelUnmerge({ mergeIndex, levelData });
            setShowUnmergeLevelDialog(true);
        }
    };
    const confirmLevelUnmerge = async () => {
        if (!pendingLevelUnmerge) {
            setShowUnmergeLevelDialog(false);
            return;
        }
        setIsLevelUnmergeConfirm(true);

        try {
            const { mergeIndex, levelData } = pendingLevelUnmerge;

            if (mergeIndex === -1 && levelData) {
                // Handle backend level unmerge
                try {
                    // Filter placeholder IDs before deletion
                    const filterPlaceholders = (ids: string[] = []) => {
                        return ids.filter(id => id && !id.includes('placeholder'));
                    };

                    const filteredHierarchy = {
                        module: filterPlaceholders(levelData.module),
                        subModule: filterPlaceholders(levelData.subModule),
                        topic: filterPlaceholders(levelData.topic),
                        subTopic: filterPlaceholders(levelData.subTopic)
                    };

                    // Find the exact level to delete using filtered hierarchy
                    const exactLevelData = levelsData.find((l: any) => {
                        const levelModules = filterPlaceholders(l.module || []);
                        const levelSubModules = filterPlaceholders(l.subModule || []);
                        const levelTopics = filterPlaceholders(l.topic || []);
                        const levelSubTopics = filterPlaceholders(l.subTopic || []);

                        return (
                            arraysEqual(levelModules, filteredHierarchy.module) &&
                            arraysEqual(levelSubModules, filteredHierarchy.subModule) &&
                            arraysEqual(levelTopics, filteredHierarchy.topic) &&
                            arraysEqual(levelSubTopics, filteredHierarchy.subTopic) &&
                            l.level === levelData.level
                        );
                    });

                    if (exactLevelData?._id) {
                        await deleteLevelMutation.mutateAsync(exactLevelData._id);
                        setShowSuccessMessage(true);
                        setTimeout(() => setShowSuccessMessage(false), 2000);
                    } else {
                        setErrorMessage("Level not found for unmerge");
                        setShowErrorDialog(true);
                    }
                } catch (error) {
                    console.error("Failed to unmerge level:", error);
                    setErrorMessage(error instanceof Error ? error.message : "Failed to unmerge level");
                    setShowErrorDialog(true);
                }
            } else if (mergeIndex !== -1) {
                // Handle local merged levels
                setMergedLevels(prev => prev.filter((_, i) => i !== mergeIndex));
            }

            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 2000);
        } catch (error) {
            console.error("Failed to unmerge level:", error);
            setErrorMessage(error instanceof Error ? error.message : "Failed to unmerge level");
            setShowErrorDialog(true);
        } finally {
            setShowUnmergeLevelDialog(false);
            setPendingLevelUnmerge(null);
            setIsLevelUnmergeConfirm(false);
        }
    };
    const handleEdit = async (type: 'module' | 'submodule' | 'topic' | 'subtopic', data: any) => {
        setEditMode({ type, data });

        const existingLevelData = preserveLevelDataForEditing(type, data._id);

        // Store these in state to use during submission
        setEditingExistingLevelData(existingLevelData);

        // Populate form based on type
        if (type === 'module') {
            setModuleFormData({
                title: data.title,
                description: data.description || '',
                level: data.level || 'Easy',
                duration: data.duration || 0,
                index: data.index || 0 // Populate index
            });
            setDialogType('module');
        } else if (type === 'submodule') {
            setSubModuleFormData({
                title: data.title,
                description: data.description || '',
                level: data.level || 'Easy',
                duration: data.duration || 0
            });
            // Find the parent module for the submodule
            const parentModule = modules.find(m => m._id === data.moduleId);
            if (parentModule) {
                setSelectedModuleForSubModule({
                    id: parentModule._id,
                    name: parentModule.title
                });
            }
            setDialogType('submodule');
        } else if (type === 'topic') {
            setTopicFormData({
                title: data.title,
                description: data.description || '',
                level: data.level || 'Easy',
                duration: data.duration || 0
            });

            // Find the parent module for the topic
            const parentModule = modules.find(m => m._id === data.moduleId);

            // Only set submodule if it's in the hierarchy
            const hierarchyLevels = selectedCourse?.courseHierarchy.map(level => level.toLowerCase()) || [];
            if (hierarchyLevels.includes('sub module')) {
                const parentSubModule = subModules.find(sm => sm._id === data.subModuleId);
                if (parentSubModule) {
                    setSelectedSubModuleForTopic({
                        id: parentSubModule._id,
                        moduleId: parentSubModule.moduleId,
                        name: parentSubModule.title
                    });
                }
            } else {
                // If submodules aren't in hierarchy, just set the module
                if (parentModule) {
                    setSelectedSubModuleForTopic({
                        id: parentModule._id,
                        moduleId: parentModule._id,
                        name: parentModule.title
                    });
                }
            }
            setDialogType('topic');
        } else if (type === 'subtopic') {
            setSubTopicFormData({
                title: data.title,
                description: data.description || '',
                level: data.level || 'Easy',
                duration: data.duration || 0
            });
            // Find the parent topic for the subtopic
            const parentTopic = topics.find(t => t._id === data.topicId);
            if (parentTopic) {
                setSelectedTopicForSubTopic({
                    id: parentTopic._id,
                    moduleId: parentTopic.moduleId,
                    subModuleId: parentTopic.subModuleId,
                    name: parentTopic.title
                });
            }
            setDialogType('subtopic');
        }
        await fetchAndSetLevelData(type, data._id);

        // Fetch and set existing pedagogy data
        await fetchAndSetPedagogyData(type, data._id);
        setShowDialog(true);
    };

    const fetchAndSetLevelData = async (type: string, id: string) => {
        if (!levelViews || !selectedCourse) return;

        // Find level data for this item
        const levelData = levelsData.find((level: any) => {
            if (type === 'module' && level.module?.includes(id)) return true;
            if (type === 'submodule' && level.subModule?.includes(id)) return true;
            if (type === 'topic' && level.topic?.includes(id)) return true;
            if (type === 'subtopic' && level.subTopic?.includes(id)) return true;
            return false;
        });

        if (levelData) {
            setShowLevelSection(true);
            setSelectedLevel(levelData.level);

            // Collect ALL hierarchy IDs from the existing level data
            const allModuleIds = new Set(levelData.module || []);
            const allSubModuleIds = new Set(levelData.subModule || []);
            const allTopicIds = new Set(levelData.topic || []);
            const allSubTopicIds = new Set(levelData.subTopic || []);

            // Set saved merge selections with ALL hierarchy IDs
            setSavedLevelMergeSelections({
                modules: Array?.from(allModuleIds),
                subModules: Array.from(allSubModuleIds),
                topics: Array.from(allTopicIds),
                subTopics: Array.from(allSubTopicIds)
            });

            // Also set the selection sets for editing
            setSelectedLevelModulesForMerge(new Set(levelData.module || []));
            setSelectedLevelSubModulesForMerge(new Set(levelData.subModule || []));
            setSelectedLevelTopicsForMerge(new Set(levelData.topic || []));
            setSelectedLevelSubTopicsForMerge(new Set(levelData.subTopic || []));

            // Enable merge section for editing
            // setShowMergeLevelSection(true);
        } else {
            // No level data found, clear everything
            setShowLevelSection(false);
            setSelectedLevel('');
            setSavedLevelMergeSelections(null);
            setSelectedLevelModulesForMerge(new Set());
            setSelectedLevelSubModulesForMerge(new Set());
            setSelectedLevelTopicsForMerge(new Set());
            setSelectedLevelSubTopicsForMerge(new Set());
            setShowMergeLevelSection(false);
        }
    };

    const fetchAndSetPedagogyData = async (type: string, id: string) => {
        if (!pedagogyViews || !selectedCourse) return;

        // Find ALL pedagogy data for this item (not just the first one)
        const allPedagogyData = pedagogyViews[0]?.pedagogies.filter((pedagogy: any) => {
            if (type === 'module' && pedagogy.module?.includes(id)) return true;
            if (type === 'submodule' && pedagogy.subModule?.includes(id)) return true;
            if (type === 'topic' && pedagogy.topic?.includes(id)) return true;
            if (type === 'subtopic' && pedagogy.subTopic?.includes(id)) return true;
            return false;
        });

        if (allPedagogyData && allPedagogyData.length > 0) {
            setShowPedagogySection(true);

            // Initialize arrays to collect all activities
            const allIDoActivities: string[] = [];
            const allWeDoActivities: string[] = [];
            const allYouDoActivities: string[] = [];

            // Initialize objects to collect all hours
            const allIDoHours: { [key: string]: number } = {};
            const allWeDoHours: { [key: string]: number } = {};
            const allYouDoHours: { [key: string]: number } = {};

            // Initialize objects to collect merge selections
            const allIDoMergeSelections: { [activity: string]: any } = {};
            const allWeDoMergeSelections: { [activity: string]: any } = {};
            const allYouDoMergeSelections: { [activity: string]: any } = {};

            // Process each pedagogy entry
            allPedagogyData.forEach((pedagogy: any) => {
                // Process I Do activities
                if (pedagogy.iDo && pedagogy.iDo.length > 0) {
                    pedagogy.iDo.forEach((activity: any) => {
                        if (!allIDoActivities.includes(activity.type)) {
                            allIDoActivities.push(activity.type);
                        }
                        allIDoHours[activity.type] = activity.duration;

                        // Check for merged items
                        if (pedagogy.module && pedagogy.module.length > 1 ||
                            pedagogy.subModule && pedagogy.subModule.length > 1 ||
                            pedagogy.topic && pedagogy.topic.length > 1 ||
                            pedagogy.subTopic && pedagogy.subTopic.length > 1) {

                            allIDoMergeSelections[activity.type] = {
                                modules: pedagogy.module || [],
                                subModules: pedagogy.subModule || [],
                                topics: pedagogy.topic || [],
                                subTopics: pedagogy.subTopic || []
                            };
                        }
                    });
                }

                // Process We Do activities
                if (pedagogy.weDo && pedagogy.weDo.length > 0) {
                    pedagogy.weDo.forEach((activity: any) => {
                        if (!allWeDoActivities.includes(activity.type)) {
                            allWeDoActivities.push(activity.type);
                        }
                        allWeDoHours[activity.type] = activity.duration;

                        // Check for merged items
                        if (pedagogy.module && pedagogy.module.length > 1 ||
                            pedagogy.subModule && pedagogy.subModule.length > 1 ||
                            pedagogy.topic && pedagogy.topic.length > 1 ||
                            pedagogy.subTopic && pedagogy.subTopic.length > 1) {

                            allWeDoMergeSelections[activity.type] = {
                                modules: pedagogy.module || [],
                                subModules: pedagogy.subModule || [],
                                topics: pedagogy.topic || [],
                                subTopics: pedagogy.subTopic || []
                            };
                        }
                    });
                }

                // Process You Do activities
                if (pedagogy.youDo && pedagogy.youDo.length > 0) {
                    pedagogy.youDo.forEach((activity: any) => {
                        if (!allYouDoActivities.includes(activity.type)) {
                            allYouDoActivities.push(activity.type);
                        }
                        allYouDoHours[activity.type] = activity.duration;

                        // Check for merged items
                        if (pedagogy.module && pedagogy.module.length > 1 ||
                            pedagogy.subModule && pedagogy.subModule.length > 1 ||
                            pedagogy.topic && pedagogy.topic.length > 1 ||
                            pedagogy.subTopic && pedagogy.subTopic.length > 1) {

                            allYouDoMergeSelections[activity.type] = {
                                modules: pedagogy.module || [],
                                subModules: pedagogy.subModule || [],
                                topics: pedagogy.topic || [],
                                subTopics: pedagogy.subTopic || []
                            };
                        }
                    });
                }
            });

            // Set the collected activities
            setSelectedPedagogyActivities({
                iDo: allIDoActivities,
                weDo: allWeDoActivities,
                youDo: allYouDoActivities
            });

            // Set the collected hours
            setPedagogyHours({
                iDo: allIDoHours,
                weDo: allWeDoHours,
                youDo: allYouDoHours
            });

            // Set the collected merge selections
            setSavedPedagogyMergeSelections(prev => ({
                ...prev,
                iDo: { ...prev.iDo, ...allIDoMergeSelections },
                weDo: { ...prev.weDo, ...allWeDoMergeSelections },
                youDo: { ...prev.youDo, ...allYouDoMergeSelections }
            }));
        }
    };

    const handleDeleteClick = (type: 'module' | 'submodule' | 'topic' | 'subtopic', id: string) => {
        setItemToDelete({ type, id });
        setShowDeleteDialog(true);
    };
    const confirmDelete = async () => {
        if (!itemToDelete || !token) return;
        setIsConfirmDelete(true);
        try {
            let model: 'Module1' | 'SubModule1' | 'Topic1' | 'SubTopic1';

            // Map the item type to the corresponding model
            switch (itemToDelete.type) {
                case 'module':
                    model = 'Module1';
                    break;
                case 'submodule':
                    model = 'SubModule1';
                    break;
                case 'topic':
                    model = 'Topic1';
                    break;
                case 'subtopic':
                    model = 'SubTopic1';
                    break;
                default:
                    throw new Error('Invalid item type');
            }

            await deleteDocumentMutation.mutateAsync({
                model,
                id: itemToDelete.id
            });

            // Refresh data
            if (selectedCourse) {
                await fetchModulesForCourse();
                await refetchModules();

                await refetchSubModules();

                await refetchTopics();
                queryClient.invalidateQueries({ queryKey: ['levelViews'] });
                await refetchSubTopics();
                if (selectedTopicForSubTopic?.id) {
                    await refetchTopicSubTopics();
                }
            }

            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 2000);
        } catch (error) {
            console.error("Failed to delete:", error);
            setErrorMessage(error instanceof Error ? error.message : "Failed to delete item");
            setShowErrorDialog(true);
        } finally {
            setShowDeleteDialog(false);
            setItemToDelete(null);
            setIsConfirmDelete(false);
        }
    };

    // Helper function to get immediate children for a specific parent
    const getImmediateChildrenForParent = (parentType: 'module' | 'submodule' | 'topic', parentId: string) => {
        switch (parentType) {
            case 'module':
                // For module, show submodules if they exist, otherwise show topics
                if (selectedCourse?.courseHierarchy.includes('Sub Module')) {
                    return sortedSubModules.filter(sub => sub.moduleId === parentId);
                } else if (selectedCourse?.courseHierarchy.includes('Topic')) {
                    return sortedTopics.filter(topic => topic.moduleId === parentId);
                }
                return [];

            case 'submodule':
                // For submodule, show topics
                return sortedTopics.filter(topic => topic.subModuleId === parentId);

            case 'topic':
                // For topic, show subtopics
                return sortedSubTopics.filter(subtopic => subtopic.topicId === parentId);

            default:
                return [];
        }
    };

    // Function to activate hierarchical delete mode from CellActionsMenu
    const activateHierarchicalDeleteMode = (parentType: 'module' | 'submodule' | 'topic', parentId: string) => {
        const children = getImmediateChildrenForParent(parentType, parentId);

        if (children.length === 0) {
            setErrorMessage(`No ${getChildType(parentType)} found for this ${parentType}`);
            setShowErrorDialog(true);
            return;
        }

        const childType = getChildType(parentType);

        // Set hierarchical delete mode
        setHierarchicalDeleteMode({
            parentType,
            parentId,
            childType
        });

        // Also set the regular delete mode for the floating actions
        setDeleteMode({
            type: childType,
            selectedItems: new Set()
        });
    };

    // Helper to get child type name
    const getChildType = (parentType: 'module' | 'submodule' | 'topic'): 'submodule' | 'topic' | 'subtopic' => {
        switch (parentType) {
            case 'module':
                return selectedCourse?.courseHierarchy.includes('Sub Module') ? 'submodule' : 'topic';
            case 'submodule':
                return 'topic';
            case 'topic':
                return 'subtopic';
            default:
                return 'subtopic';
        }
    };

    // Check if item should show checkbox in hierarchical delete mode
    const shouldShowHierarchicalCheckbox = (itemType: 'submodule' | 'topic' | 'subtopic', itemId: string) => {
        if (!hierarchicalDeleteMode || hierarchicalDeleteMode.childType !== itemType) return false;

        const children = getImmediateChildrenForParent(hierarchicalDeleteMode.parentType, hierarchicalDeleteMode.parentId);
        return children.some(child => child._id === itemId);
    };

    // Helper function to get immediate children based on hierarchy
    const getImmediateChildren = (parentType: 'module' | 'submodule' | 'topic', parentId: string) => {
        switch (parentType) {
            case 'module':
                // For module, show submodules if they exist, otherwise show topics
                if (selectedCourse?.courseHierarchy.includes('Sub Module')) {
                    return sortedSubModules.filter(sub => sub.moduleId === parentId);
                } else if (selectedCourse?.courseHierarchy.includes('Topic')) {
                    return sortedTopics.filter(topic => topic.moduleId === parentId);
                }
                return [];

            case 'submodule':
                // For submodule, show topics
                return sortedTopics.filter(topic => topic.subModuleId === parentId);

            case 'topic':
                // For topic, show subtopics
                return sortedSubTopics.filter(subtopic => subtopic.topicId === parentId);

            default:
                return [];
        }
    };

    // Function to activate hierarchical delete mode
    // const activateHierarchicalDeleteMode = (parentType: 'module' | 'submodule' | 'topic', parentId: string) => {
    //     const children = getImmediateChildren(parentType, parentId);

    //     if (children.length === 0) {
    //         // If no children, show message
    //         setErrorMessage(`No ${getChildType(parentType)} found for this ${parentType}`);
    //         setShowErrorDialog(true);
    //         return;
    //     }

    //     // Determine the child type based on hierarchy
    //     const childType = getChildType(parentType);

    //     setDeleteMode({
    //         type: childType,
    //         selectedItems: new Set()
    //     });
    // };

    // Helper to get child type name
    // const getChildType = (parentType: 'module' | 'submodule' | 'topic'): 'submodule' | 'topic' | 'subtopic' => {
    //     switch (parentType) {
    //         case 'module':
    //             return selectedCourse?.courseHierarchy.includes('Sub Module') ? 'submodule' : 'topic';
    //         case 'submodule':
    //             return 'topic';
    //         case 'topic':
    //             return 'subtopic';
    //         default:
    //             return 'subtopic';
    //     }
    // };

    // Helper function to check if item should show checkbox in hierarchical delete mode
    const shouldShowCheckbox = (itemType: 'module' | 'submodule' | 'topic' | 'subtopic', itemId: string) => {
        if (!deleteMode.type || deleteMode.type !== itemType) return false;

        // Get all items of the current delete mode type
        const items = getItemsForDeletion(deleteMode.type);

        // Check if this item exists in the available items for deletion
        return items.some(item => item._id === itemId);
    };

    const handleMultipleDeleteClick = () => {
        setShowMultipleDeleteDialog(true);
    };

    // New function to handle delete mode activation
    // const activateDeleteMode = (type: 'module' | 'submodule' | 'topic' | 'subtopic') => {
    //     setDeleteMode({
    //         type,
    //         selectedItems: new Set()
    //     });
    //     setShowMultipleDeleteDialog(false);
    // };
    const activateGlobalDeleteMode = (type: 'module' | 'submodule' | 'topic' | 'subtopic') => {
        setDeleteMode({
            type,
            selectedItems: new Set()
        });
        setHierarchicalDeleteMode(null); // Ensure no hierarchical mode
        setShowMultipleDeleteDialog(false);
    };
    // Function to cancel delete mode
    // Function to cancel delete mode
    const cancelDeleteMode = () => {
        setDeleteMode({
            type: null,
            selectedItems: new Set()
        });
        setHierarchicalDeleteMode(null); // Reset hierarchical mode
        setShowDeleteConfirmation(false);
    };

    // Function to handle item selection in delete mode
    const handleDeleteModeSelection = (id: string, checked: boolean) => {
        setDeleteMode(prev => ({
            ...prev,
            selectedItems: new Set(checked ? [...prev.selectedItems, id] : [...prev.selectedItems].filter(item => item !== id))
        }));
    };

    // Function to handle select all in delete mode
    const handleDeleteModeSelectAll = (checked: boolean, items: any[]) => {
        setDeleteMode(prev => ({
            ...prev,
            selectedItems: checked ? new Set(items.filter(item => !isDefaultItem(item.title)).map(item => item._id)) : new Set()
        }));
    };

    const confirmMultipleDelete = async () => {
        if (!deleteMode.type || deleteMode.selectedItems.size === 0 || !token) return;
        setIsConfirmMultiDelete(true);
        try {
            let model: 'Module1' | 'SubModule1' | 'Topic1' | 'SubTopic1';

            // Map the item type to the corresponding model
            switch (deleteMode.type) {
                case 'module':
                    model = 'Module1';
                    break;
                case 'submodule':
                    model = 'SubModule1';
                    break;
                case 'topic':
                    model = 'Topic1';
                    break;
                case 'subtopic':
                    model = 'SubTopic1';
                    break;
                default:
                    throw new Error('Invalid item type');
            }

            // Convert Set to comma-separated string
            const idsToDelete = Array.from(deleteMode.selectedItems).join(',');

            await deleteDocumentMutation.mutateAsync({
                model,
                id: idsToDelete
            });

            // Refresh data
            if (selectedCourse) {
                await fetchModulesForCourse();
                await refetchModules();
                await refetchSubModules();
                await refetchTopics();
                queryClient.invalidateQueries({ queryKey: ['levelViews'] });
                await refetchSubTopics();
                if (selectedTopicForSubTopic?.id) {
                    await refetchTopicSubTopics();
                }
            }

            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 2000);
            setShowDeleteConfirmation(false);
            // Close delete mode
            cancelDeleteMode();
        } catch (error) {
            console.error("Failed to delete items:", error);
            setErrorMessage(error instanceof Error ? error.message : "Failed to delete items");
            setShowErrorDialog(true);
        } finally {
            setIsConfirmMultiDelete(false);
        }
    };
    // Helper functions for multiple delete
    const getItemsForDeletion = (type: 'module' | 'submodule' | 'topic' | 'subtopic') => {
        switch (type) {
            case 'module':
                return sortedModules.filter(module => !isDefaultItem(module.title));
            case 'submodule':
                return sortedSubModules.filter(subModule => !isDefaultItem(subModule.title));
            case 'topic':
                return sortedTopics.filter(topic => !isDefaultItem(topic.title));
            case 'subtopic':
                return sortedSubTopics.filter(subTopic => !isDefaultItem(subTopic.title));
            default:
                return [];
        }
    };

    const zoomTableIn = () => {
        setTableZoomLevel((prev) => Math.min(prev + 0.1, 1))
    }
    const zoomTableOut = () => {
        setTableZoomLevel((prev) => Math.max(prev - 0.1, 0.5))
    }
    const resetTableZoom = () => {
        setTableZoomLevel(1)
    }
    const isDefaultItem = (name: string) => {
        return name.includes("Default") || name === "-" || name === "" || name.includes("placeholder");
    };
    const MergeButton = () => {
        if (selectedMergeCells.size < 2 || !mergeSelectionMode) return null;

        const handleMerge = () => {
            const selectedRows = Array.from(selectedMergeCells)
                .map(cellKey => {
                    if (mergeSelectionMode === 'level') {
                        const rowId = cellKey.replace('level::', '');
                        return tableRows.findIndex(row => row.rowId === rowId);
                    } else {
                        const parts = cellKey.split('::');
                        const type = parts[0] as "iDo" | "weDo" | "youDo";
                        const activity = parts[1];
                        const rowId = parts.slice(2).join('::');
                        const rowIndex = tableRows.findIndex(row => row.rowId === rowId);
                        return { rowIndex, type, activity };
                    }
                })
                .filter((item: any) => {
                    if (mergeSelectionMode === 'level') {
                        return item !== -1;
                    } else {
                        return item?.rowIndex !== -1;
                    }
                })
                .sort((a: any, b: any) => {
                    if (mergeSelectionMode === 'level') {
                        return a - b;
                    } else {
                        return a.rowIndex - b.rowIndex;
                    }
                });

            // Check if at least 2 rows are selected
            if (selectedRows.length < 2) {
                showError("Please select at least 2 rows to merge!");
                return;
            }

            // Extract row indices for validation
            const rowIndices = mergeSelectionMode === 'level'
                ? selectedRows as number[]
                : (selectedRows as { rowIndex: number; type: string; activity: string }[]).map(item => item.rowIndex);

            // Check if selected rows are consecutive
            let canMerge = true;
            for (let i = 1; i < rowIndices.length; i++) {
                if (rowIndices[i] !== rowIndices[i - 1] + 1) {
                    canMerge = false;
                    break;
                }
            }

            if (!canMerge) {
                showError("Selected rows must be consecutive to merge!");
                return;
            }

            // Check hierarchy validity for all selected rows


            if (mergeSelectionMode === 'level') {
                // Check if any selected row already has a level value
                const hasLevelValues = (selectedRows as number[]).some(rowIndex => {
                    const row = tableRows[rowIndex];
                    const levelInfo = isLevelMerged(rowIndex);
                    return levelInfo.value && levelInfo.value !== "-";
                });

                if (hasLevelValues) {
                    showError("Cannot merge - one or more selected rows already have level values!");
                    return;
                }

                // Collect hierarchy IDs based on course structure
                const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];
                const hierarchyIds = {
                    modules: new Set<string>(),
                    subModules: new Set<string>(),
                    topics: new Set<string>(),
                    subTopics: new Set<string>()
                };

                (selectedRows as number[]).forEach(rowIndex => {
                    const row = tableRows[rowIndex];
                    if (hierarchyLevels.includes('module')) hierarchyIds.modules.add(row.moduleId);
                    if (hierarchyLevels.includes('sub module')) hierarchyIds.subModules.add(row.subModuleId);
                    if (hierarchyLevels.includes('topic')) hierarchyIds.topics.add(row.topicId);
                    if (hierarchyLevels.includes('sub topic')) hierarchyIds.subTopics.add(row.subtopicId);
                });

                // Call handleMergeLevelsClick with the selected rows
                setPendingLevelMerge({
                    selectedRows: selectedRows as number[],
                    hierarchyIds: {
                        modules: Array.from(hierarchyIds.modules),
                        subModules: Array.from(hierarchyIds.subModules),
                        topics: Array.from(hierarchyIds.topics),
                        subTopics: Array.from(hierarchyIds.subTopics)
                    }
                });
                setMergeLevelValue("");
                setShowMergeLevelDialog(true);
            } else {
                // For pedagogy merging, extract type and activity from first cell
                const firstCell = selectedRows[0] as { rowIndex: number; type: string; activity: string };
                const type = firstCell.type as "iDo" | "weDo" | "youDo";
                const activity = firstCell.activity;

                const selectedRowsArray = (selectedRows as { rowIndex: number; type: string; activity: string }[])
                    .map(item => item.rowIndex);

                // Check if any selected cell already has a value
                const hasValues = selectedRowsArray.some(rowIndex => {
                    const row = tableRows[rowIndex];
                    const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];
                    const effectiveTopicId = hierarchyLevels.includes('topic')
                        ? row.topicId
                        : `${row.moduleId}-default-topic`;
                    const effectiveSubtopicId = hierarchyLevels.includes('sub topic')
                        ? row.subtopicId
                        : hierarchyLevels.includes('topic')
                            ? `${row.topicId}-default-subtopic`
                            : `${row.moduleId}-default-subtopic`;

                    // Check for merged cells
                    const mergeInfo = isCellMerged(rowIndex, type, activity);
                    if (mergeInfo.isMerged && mergeInfo.value > 0) {
                        return true;
                    }

                    // Check individual cell value
                    const cellValue = courseHours[row.moduleId]?.[effectiveTopicId]?.[effectiveSubtopicId]?.[type]?.[activity] || 0;
                    return cellValue > 0;
                });

                if (hasValues) {
                    showError(`Cannot merge - one or more selected cells already have values for ${activity} (${type}).`);
                    return;
                }

                // Check if we're trying to merge a mix of merged and unmerged cells
                const mergeStatuses = selectedRowsArray.map(rowIndex => {
                    const mergeInfo = isCellMerged(rowIndex, type, activity);
                    return mergeInfo.isMerged;
                });

                const hasMixedMergeStatus = new Set(mergeStatuses).size > 1;
                if (hasMixedMergeStatus) {
                    showError("Cannot merge already merged cells with individual cells!");
                    return;
                }

                // Call mergeCells function
                mergeCells(type, activity, selectedRowsArray);
            }

            // Reset selection mode
            setMergeSelectionMode(null);
            setSelectedMergeCells(new Set());
        };

        const handleCancel = () => {
            setMergeSelectionMode(null);
            setSelectedMergeCells(new Set());
        };

        const getMergeTypeColor = () => {
            return mergeSelectionMode === 'level'
                ? 'from-indigo-500 to-purple-600'
                : 'from-emerald-500 to-teal-600';
        };

        const getMergeIcon = () => {
            return mergeSelectionMode === 'level' ? Layers : BookOpen;
        };

        const MergeIcon = getMergeIcon();

        return (
            <div className="fixed bottom-4 right-6 z-50">
                <div className="bg-white/95 backdrop-blur-md border border-gray-200/50 rounded-2xl shadow-xl px-4 py-1 transition-all duration-300 hover:shadow-2xl hover:-translate-y-1">
                    <div className="flex items-center gap-4">
                        {/* Icon with gradient background */}
                        <div className={`p-1.5 bg-gradient-to-br ${getMergeTypeColor()} rounded-lg text-white shadow-lg`}>
                            <MergeIcon className="h-3.5 w-3.5" />
                        </div>

                        {/* Selection info */}
                        <div className="flex items-center gap-3">
                            <div className="flex items-center gap-2">
                                <span className={`inline-flex items-center justify-center w-6 h-6 text-xs font-bold text-white bg-gradient-to-r ${getMergeTypeColor()} rounded-full shadow-md`}>
                                    {selectedMergeCells.size}
                                </span>
                                <span className="text-gray-700 font-medium text-xs">
                                    cells selected for
                                </span>
                                <span className={`px-3 py-1 text-xs font-semibold bg-gradient-to-r ${getMergeTypeColor()} text-white rounded-full shadow-sm`}>
                                    {mergeSelectionMode === 'level' ? 'LEVEL' : 'PEDAGOGY'}
                                </span>
                                <span className="text-gray-700 font-medium text-xs">merging</span>
                            </div>
                        </div>

                        {/* Action buttons */}
                        <div className="flex items-center gap-2 ml-4 pl-4 border-l border-gray-200">
                            <button
                                onClick={handleMerge}
                                className={`inline-flex items-center text-sm gap-2 px-4 py-1 bg-gradient-to-r ${getMergeTypeColor()} hover:shadow-lg text-white font-semibold rounded-xl transition-all duration-200 hover:-translate-y-0.5 active:translate-y-0 group`}
                            >
                                <Merge className="h-3.5 w-3.5 group-hover:rotate-12 transition-transform duration-200" />
                                Merge
                            </button>

                            <button
                                onClick={handleCancel}
                                className="inline-flex items-center gap-1 px-3 py-2 bg-red-100 hover:bg-red-200 text-red-600 font-semibold rounded-xl transition-all duration-200 hover:-translate-y-0.5 active:translate-y-0 group"
                            >
                                <X className="h-3.5 w-3.5 group-hover:rotate-90 transition-transform duration-200" />
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        );
    };
    const updateMergedPedagogy = useMutation({
        mutationFn: (data: {
            type: "iDo" | "weDo" | "youDo";
            activity: string;
            value: number;
            mergeIndex: number;
            hierarchyIds?: any;
        }) => {
            // Handle backend merges (mergeIndex = -2)
            if (data.mergeIndex === -2) {
                // Find the backend pedagogy item that matches the hierarchy
                const matchingPedagogy = pedagogyViews?.[0]?.pedagogies.find(p => {
                    const levelModules = p.module || [];
                    const levelSubModules = p.subModule || [];
                    const levelTopics = p.topic || [];
                    const levelSubTopics = p.subTopic || [];

                    // Check if this matches the hierarchy pattern
                    return arraysEqual(levelModules, data.hierarchyIds?.modules || []) &&
                        arraysEqual(levelSubModules, data.hierarchyIds?.subModules || []) &&
                        arraysEqual(levelTopics, data.hierarchyIds?.topics || []) &&
                        arraysEqual(levelSubTopics, data.hierarchyIds?.subTopics || []);
                });

                if (matchingPedagogy && pedagogyViews?.length) {
                    // Update the specific activity in the matching pedagogy
                    const updatedPedagogies = pedagogyViews[0].pedagogies.map(p => {
                        if (p === matchingPedagogy) {
                            return {
                                ...p,
                                [data.type]: p[data.type].map((act: any) =>
                                    act.type === data.activity ? { ...act, duration: data.value } : act
                                )
                            };
                        }
                        return p;
                    });

                    return pedagogyViewApi.update(pedagogyViews[0]._id).mutationFn({
                        courses: selectedCourse?._id || '',
                        pedagogies: updatedPedagogies
                    });
                }
                throw new Error("Matching pedagogy not found");
            }

            // Handle frontend merges (existing logic)
            const columnKey = `${data.type}-${data.activity}`;
            const mergeData = mergedCells[columnKey][data.mergeIndex];

            const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];
            const pedagogyData: any = {
                iDo: data.type === "iDo" ? [{ type: data.activity, duration: data.value }] : [],
                weDo: data.type === "weDo" ? [{ type: data.activity, duration: data.value }] : [],
                youDo: data.type === "youDo" ? [{ type: data.activity, duration: data.value }] : [],
                ...(hierarchyLevels.includes('module') && { module: mergeData.hierarchyIds?.modules || [] }),
                ...(hierarchyLevels.includes('sub module') && { subModule: mergeData.hierarchyIds?.subModules || [] }),
                ...(hierarchyLevels.includes('topic') && { topic: mergeData.hierarchyIds?.topics || [] }),
                ...(hierarchyLevels.includes('sub topic') && { subTopic: mergeData.hierarchyIds?.subTopics || [] })
            };

            const existingPedagogyIndex = pedagogyViews?.[0]?.pedagogies.findIndex(p =>
                JSON.stringify(p.module) === JSON.stringify(pedagogyData.module) &&
                JSON.stringify(p.subModule) === JSON.stringify(pedagogyData.subModule) &&
                JSON.stringify(p.topic) === JSON.stringify(pedagogyData.topic) &&
                JSON.stringify(p.subTopic) === JSON.stringify(pedagogyData.subTopic)
            );

            let updatedPedagogies = pedagogyViews?.[0]?.pedagogies ? [...pedagogyViews[0].pedagogies] : [];

            if (existingPedagogyIndex !== undefined && existingPedagogyIndex !== -1) {
                updatedPedagogies[existingPedagogyIndex] = pedagogyData;
            } else {
                updatedPedagogies.push(pedagogyData);
            }

            if (pedagogyViews?.[0]?._id) {
                return pedagogyViewApi.update(pedagogyViews[0]._id).mutationFn({
                    courses: selectedCourse?._id || '',
                    pedagogies: updatedPedagogies
                });
            } else {
                return pedagogyViewApi.create().mutationFn({
                    courses: selectedCourse?._id || '',
                    pedagogies: updatedPedagogies
                });
            }
        },
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['pedagogyViews'] });
            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 2000);
        }
    });
    // Inside the PreviewTable component, add this function:
    const renderActivityCell = (
        type: "iDo" | "weDo" | "youDo",
        activity: string,
        row: any,
        index: number,
        mergeInfo: any,
        isPreview: boolean = false
    ) => {

        // Determine effective IDs based on hierarchy
        const effectiveTopicId = row.topicId || `${row.moduleId}-default-topic`;
        const effectiveSubtopicId = row.subtopicId ||
            (row.topicId ? `${row.topicId}-default-subtopic` : `${row.moduleId}-default-subtopic`);

        const hasValue = mergeInfo.isMerged ? mergeInfo.value > 0 :
            courseHours[row.moduleId]?.[effectiveTopicId]?.[effectiveSubtopicId]?.[type]?.[activity] > 0;

        const getCellValue = () => {
            // First check if this is a merged cell (backend or frontend)
            if (mergeInfo.isMerged) {
                return mergeInfo.value;
            }
            // Then check backend single cell data
            const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];

            // Find matching pedagogy data in backend
            if (pedagogyViews && pedagogyViews.length > 0) {
                for (const view of pedagogyViews) {
                    for (const pedagogy of view.pedagogies) {
                        const pedagogyModules = pedagogy.module || [];
                        const pedagogySubModules = pedagogy.subModule || [];
                        const pedagogyTopics = pedagogy.topic || [];
                        const pedagogySubTopics = pedagogy.subTopic || [];

                        // Skip merged pedagogies (already handled above)
                        const isMultiMerge = pedagogyModules.length > 1 || pedagogySubModules.length > 1 ||
                            pedagogyTopics.length > 1 || pedagogySubTopics.length > 1;
                        if (isMultiMerge) continue;

                        // Check exact match for single cell
                        const moduleMatch = pedagogyModules.length === 0 ||
                            (pedagogyModules.length === 1 && pedagogyModules[0] === row.moduleId);
                        const subModuleMatch = pedagogySubModules.length === 0 ||
                            (pedagogySubModules.length === 1 && pedagogySubModules[0] === row.subModuleId);
                        const topicMatch = pedagogyTopics.length === 0 ||
                            (pedagogyTopics.length === 1 && pedagogyTopics[0] === row.topicId);
                        const subtopicMatch = pedagogySubTopics.length === 0 ||
                            (pedagogySubTopics.length === 1 && pedagogySubTopics[0] === row.subtopicId);

                        if (moduleMatch && subModuleMatch && topicMatch && subtopicMatch) {
                            const activityData = pedagogy[type]?.find((a: any) => a.type === activity);
                            if (activityData) {
                                return activityData.duration;
                            }
                        }
                    }
                }
            }

            // Finally check frontend single cell data
            return courseHours[row.moduleId]?.[effectiveTopicId]?.[effectiveSubtopicId]?.[type]?.[activity] || 0;
        };

        const cellValue = getCellValue();
        const displayValue = cellValue === 0 ? "" : cellValue.toString();

        // Background colors based on type and merge state
        const bgColor = type === "iDo"
            ? mergeInfo.isMerged ? "bg-yellow-200" : "bg-yellow-50"
            : type === "weDo"
                ? mergeInfo.isMerged ? "bg-orange-200" : "bg-orange-50"
                : mergeInfo.isMerged ? "bg-green-200" : "bg-green-50";

        const hoverColor = type === "iDo"
            ? mergeInfo.isMerged ? "hover:bg-yellow-300" : "hover:bg-yellow-100"
            : type === "weDo"
                ? mergeInfo.isMerged ? "hover:bg-orange-300" : "hover:bg-orange-100"
                : mergeInfo.isMerged ? "hover:bg-green-300" : "hover:bg-green-100";

        const disabledClass = "cursor-pointer";
        const showCheckbox = mergeSelectionMode === 'pedagogy' && selectedMergeCells.size > 0;

        const selectionClass =
            (isSelectingCells && selectedCells.has(`${index}::${type}::${activity}`))
                ? "bg-blue-100 !border-blue-500 border-2 shadow-[0_0_0_2px_#3b82f6_inset]"
                : "";

        const handleDeleteCell = (row: any, type: "iDo" | "weDo" | "youDo", activity: string, mergeInfo: any) => {
            if (mergeInfo.isMerged) {
                unmergeCell(type, activity, mergeInfo.mergeIndex);
            } else {
                const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];

                // Determine effective IDs based on hierarchy
                const effectiveSubtopicId = hierarchyLevels.includes('sub topic')
                    ? row.subtopicId
                    : hierarchyLevels.includes('topic')
                        ? `${row.topicId}-default-subtopic`
                        : `${row.moduleId}-default-subtopic`;

                const effectiveTopicId = hierarchyLevels.includes('topic')
                    ? row.topicId
                    : `${row.moduleId}-default-topic`;

                // Set the cell to delete and show confirmation dialog
                setCellToDelete({
                    moduleId: row.moduleId,
                    topicId: effectiveTopicId,
                    subtopicId: effectiveSubtopicId,
                    subModuleId: row.subModuleId,
                    type,
                    activity
                });
                setShowDeleteCellDialog(true);
            }
        };

        if (mergeInfo.isMerged && !mergeInfo.isStart) return null;
        return (
            <motion.td
                initial={{ y: 20 }}
                animate={{ y: 0 }}
                exit={{ y: -20 }}
                transition={{ duration: 0.3, ease: "easeInOut" }}
                key={`${row.subtopicId}-${type}-${activity}`}
                className={`
                    border border-gray-400 text-center text-[10px] p-0.5 transition-colors
                    ${bgColor} ${hoverColor} ${mergeInfo.isMerged ? "font-bold" : ""}
                    min-w-[70px] h-[32px] ${disabledClass} ${selectionClass}
                `}

                rowSpan={mergeInfo.rowSpan}

            >
                <div className="relative w-full h-full flex items-center">
                    {/* Center - Value Display or Input */}
                    <div className="absolute inset-0 flex items-center justify-center">
                        <span>{displayValue}</span>
                    </div>

                    {/* Right End - Action Menu or Checkbox */}
                    {!isPreview && (
                        <div className="absolute right-0 top-1/2 transform -translate-y-1/2 z-10">
                            {showCheckbox ? (
                                <Checkbox
                                    checked={selectedMergeCells.has(`${type}::${activity}::${row.rowId}`)}
                                    onCheckedChange={() => {


                                        setSelectedMergeCells(prev => {
                                            const newSelection = new Set(prev);
                                            if (newSelection.has(`${type}::${activity}::${row.rowId}`)) {
                                                newSelection.delete(`${type}::${activity}::${row.rowId}`);
                                            } else {
                                                newSelection.add(`${type}::${activity}::${row.rowId}`);
                                            }
                                            return newSelection;
                                        });
                                    }}

                                    className="mr-1 h-5 w-5 rounded-sm border-1 border-gray-500
             data-[state=checked]:bg-gray-900 data-[state=checked]:border-gray-900
             data-[state=checked]:text-white shadow-sm transition-colors
             hover:border-gray-600 focus:outline-none"
                                />
                            ) : (
                                directActionsEnabled && (
                                    <CellActionMenu
                                        cellType="pedagogy"
                                        cellKey={`${type}-${activity}-${row.rowId}`}
                                        hasValue={hasValue}
                                        isMerged={mergeInfo.isMerged}

                                        onAdd={() => {
                                            handleCellClick(
                                                row.moduleId,
                                                effectiveTopicId,
                                                effectiveSubtopicId,
                                                type,
                                                activity,
                                                row.subModuleId, // Add subModuleId
                                            );
                                        }}
                                        onEdit={() => {
                                            if (mergeInfo.isMerged && mergeInfo.isStart) {
                                                setEditingMerge({
                                                    type,
                                                    activity,
                                                    mergeIndex: mergeInfo.mergeIndex,
                                                    value: mergeInfo.value,
                                                    hierarchyIds: mergeInfo.hierarchyIds // Add this line
                                                });
                                            } else {
                                                handleCellClick(
                                                    row.moduleId,
                                                    effectiveTopicId,
                                                    effectiveSubtopicId,
                                                    type,
                                                    activity,
                                                    row.subModuleId
                                                );
                                            }
                                        }}
                                        onDelete={() => handleDeleteCell(row, type, activity, mergeInfo)}
                                        onMerge={() => {
                                            setMergeSelectionMode('pedagogy');
                                            setSelectedMergeCells(new Set([`${type}::${activity}::${row.rowId}`]));
                                        }}
                                        onUnmerge={mergeInfo.isMerged ? () =>
                                            unmergeCell(
                                                type,
                                                activity,
                                                mergeInfo.mergeIndex,
                                                mergeInfo.hierarchyIds
                                            )
                                            : undefined}
                                    />
                                )
                            )}
                        </div>
                    )}
                </div>
            </motion.td>
        );
    };
    const PreviewTable = ({
        tableRows,
        courseHours,
        mergedCells,
        selectedCourse,
        activityTypes,
        selectedPedagogyTypes,
        moduleSpans,
        subModuleSpans,
        topicSpans,
        exportSelections,
        isPrinting = false,
    }: PreviewTableProps) => {
        const isCellMerged = (
            rowIndex: number,
            type: "iDo" | "weDo" | "youDo",
            activity: string
        ) => {
            const columnKey = `${type}-${activity}`;
            const merges = mergedCells[columnKey] || [];
            const row = tableRows[rowIndex];

            for (const merge of merges) {
                // Check if this row is part of the merge
                const rowIndices =
                    merge.rowIds
                        ?.map((rid: string) =>
                            tableRows.findIndex((r: any) => r.rowId === rid)
                        )
                        .filter((idx: number) => idx !== -1)
                        .sort((a: number, b: number) => a - b) || [];

                if (rowIndices.includes(rowIndex)) {
                    return {
                        isMerged: true,
                        isStart: rowIndex === rowIndices[0],
                        rowSpan: rowIndices.length,
                        value: merge.value,
                        mergeIndex: merges.indexOf(merge),
                        hierarchyIds: merge.hierarchyIds,
                        type: type,
                    };
                }
            }

            return {
                isMerged: false,
                isStart: false,
                rowSpan: 1,
                value: 0,
                mergeIndex: -1,
                hierarchyIds: null,
                type: type,
            };
        };
        const calculateTotalHours = (
            type: "iDo" | "weDo" | "youDo",
            activity: string
        ) => {
            const columnKey = `${type}-${activity}`;

            // Calculate merged values
            const mergedValue =
                mergedCells[columnKey]?.reduce((sum, merge) => sum + merge.value, 0) ||
                0;

            // Calculate unmerged values
            const unmergedValue = Object.entries(courseHours).reduce(
                (sum, [moduleId, moduleData]) => {
                    return (
                        sum +
                        Object.entries(moduleData).reduce(
                            (moduleSum, [topicId, topicData]) => {
                                return (
                                    moduleSum +
                                    Object.entries(topicData).reduce(
                                        (topicSum, [subtopicId, subtopicData]) => {
                                            // Check if this cell is part of any merge
                                            const isMerged = mergedCells[columnKey]?.some((merge) => {
                                                // Check hierarchy matches
                                                const matchesModule =
                                                    !merge.hierarchyIds?.modules.length ||
                                                    merge.hierarchyIds.modules.includes(moduleId);
                                                const matchesSubModule =
                                                    !merge.hierarchyIds?.subModules.length ||
                                                    !topicData.subModuleId ||
                                                    merge.hierarchyIds.subModules.includes(
                                                        topicData?.subModuleId as any
                                                    );
                                                const matchesTopic =
                                                    !merge.hierarchyIds?.topics.length ||
                                                    !topicId ||
                                                    merge.hierarchyIds.topics.includes(topicId);
                                                const matchesSubTopic =
                                                    !merge.hierarchyIds?.subTopics.length ||
                                                    !subtopicId ||
                                                    merge.hierarchyIds.subTopics.includes(subtopicId);

                                                return (
                                                    matchesModule &&
                                                    matchesSubModule &&
                                                    matchesTopic &&
                                                    matchesSubTopic
                                                );
                                            });

                                            // Only add if not part of a merge and has a value
                                            if (!isMerged && subtopicData[type]?.[activity]) {
                                                return topicSum + (subtopicData[type][activity] || 0);
                                            }
                                            return topicSum;
                                        },
                                        0
                                    )
                                );
                            },
                            0
                        )
                    );
                },
                0
            );

            return mergedValue + unmergedValue;
        };

        const getLevelColumnLeft = () => {
            if (!selectedCourse) return 0;

            // Calculate width based on hierarchy levels
            let left = 0;
            const hierarchyLevels = selectedCourse.courseHierarchy;

            // Add width for each hierarchy level (80px per column)
            left = hierarchyLevels.length * 0;

            // Add some extra spacing (20px) between last hierarchy and level column
            return left + 0;
        };

        const renderPreviewLevelCell = (row: any, rowIndex: number) => {
            const mergeInfo = isLevelMerged(rowIndex);

            // Skip rendering if this is part of a merged cell but not the first row
            if (mergeInfo.isMerged && !mergeInfo.isStart) return null;

            return (
                <td
                    key={`level-${row.rowId}`}
                    className={`border border-gray-400 text-center text-[10px] p-0.5 bg-blue-50 min-w-[80px] h-[32px]  bg-white z-0`}
                    style={{
                        left: `${getLevelColumnLeft()}px`,
                    }}
                    rowSpan={mergeInfo.rowSpan}
                >
                    <div
                        className={`min-h-[20px] flex items-center justify-center ${mergeInfo.isMerged ? "font-bold" : ""
                            }`}
                    >
                        {mergeInfo.value || "-"}
                    </div>
                </td>
            );
        };

        // Calculate total hours for a row
        const calculateRowTotal = (row: any) => {
            let total = 0;

            // Calculate for each selected activity type
            selectedIDoActivities.forEach((activity) => {
                const mergeInfo = isCellMerged(tableRows.indexOf(row), "iDo", activity);
                const cellValue = mergeInfo.isMerged
                    ? mergeInfo.isStart
                        ? mergeInfo.value
                        : 0
                    : getCellValueForRow(row, "iDo", activity);
                total += cellValue || 0;
            });

            selectedWeDoActivities.forEach((activity) => {
                const mergeInfo = isCellMerged(
                    tableRows.indexOf(row),
                    "weDo",
                    activity
                );
                const cellValue = mergeInfo.isMerged
                    ? mergeInfo.isStart
                        ? mergeInfo.value
                        : 0
                    : getCellValueForRow(row, "weDo", activity);
                total += cellValue || 0;
            });

            selectedYouDoActivities.forEach((activity) => {
                const mergeInfo = isCellMerged(
                    tableRows.indexOf(row),
                    "youDo",
                    activity
                );
                const cellValue = mergeInfo.isMerged
                    ? mergeInfo.isStart
                        ? mergeInfo.value
                        : 0
                    : getCellValueForRow(row, "youDo", activity);
                total += cellValue || 0;
            });

            return total;
        };

        // Get cell value for a specific row and activity
        const getCellValueForRow = (
            row: any,
            type: "iDo" | "weDo" | "youDo",
            activity: string
        ) => {
            // Determine effective IDs based on hierarchy
            const effectiveTopicId = row.topicId || `${row.moduleId}-default-topic`;
            const effectiveSubtopicId =
                row.subtopicId ||
                (row.topicId
                    ? `${row.topicId}-default-subtopic`
                    : `${row.moduleId}-default-subtopic`);

            // Check backend data first
            if (pedagogyViews && pedagogyViews.length > 0) {
                for (const view of pedagogyViews) {
                    for (const pedagogy of view.pedagogies) {
                        const pedagogyModules = pedagogy.module || [];
                        const pedagogySubModules = pedagogy.subModule || [];
                        const pedagogyTopics = pedagogy.topic || [];
                        const pedagogySubTopics = pedagogy.subTopic || [];

                        // Skip merged pedagogies
                        const isMultiMerge =
                            pedagogyModules.length > 1 ||
                            pedagogySubModules.length > 1 ||
                            pedagogyTopics.length > 1 ||
                            pedagogySubTopics.length > 1;
                        if (isMultiMerge) continue;

                        // Check exact match for single cell
                        const moduleMatch =
                            pedagogyModules.length === 0 ||
                            (pedagogyModules.length === 1 &&
                                pedagogyModules[0] === row.moduleId);
                        const subModuleMatch =
                            pedagogySubModules.length === 0 ||
                            (pedagogySubModules.length === 1 &&
                                pedagogySubModules[0] === row.subModuleId);
                        const topicMatch =
                            pedagogyTopics.length === 0 ||
                            (pedagogyTopics.length === 1 &&
                                pedagogyTopics[0] === row.topicId);
                        const subtopicMatch =
                            pedagogySubTopics.length === 0 ||
                            (pedagogySubTopics.length === 1 &&
                                pedagogySubTopics[0] === row.subtopicId);

                        if (moduleMatch && subModuleMatch && topicMatch && subtopicMatch) {
                            const activityData = pedagogy[type]?.find(
                                (a: any) => a.type === activity
                            );
                            if (activityData) {
                                return activityData.duration;
                            }
                        }
                    }
                }
            }

            // Fall back to frontend data
            return (
                courseHours[row.moduleId]?.[effectiveTopicId]?.[effectiveSubtopicId]?.[
                type
                ]?.[activity] || 0
            );
        };

        // Calculate merged totals for hierarchy levels

        const isFirstInMergedGroup = (
            row: {
                moduleId: string;
                subModuleId: string;
                topicId: string;
                subtopicId: string;
            },
            index: number
        ) => {
            // Find the highest priority hierarchy level that is selected
            let hierarchyKey = "";
            let hierarchyId = "";

            // Check in order of priority - use the first selected one
            if (exportSelections.hierarchy.module && row.moduleId) {
                hierarchyKey = "moduleId";
                hierarchyId = row.moduleId;
            } else if (exportSelections.hierarchy.subModule && row.subModuleId) {
                hierarchyKey = "subModuleId";
                hierarchyId = row.subModuleId;
            } else if (exportSelections.hierarchy.topic && row.topicId) {
                hierarchyKey = "topicId";
                hierarchyId = row.topicId;
            } else if (exportSelections.hierarchy.subTopic && row.subtopicId) {
                hierarchyKey = "subtopicId";
                hierarchyId = row.subtopicId;
            } else {
                // No hierarchy selected, treat each row individually
                return index === 0; // Only show total on first row
            }

            // Check if this is the first row with this hierarchy ID
            return (
                tableRows.findIndex((r) => r[hierarchyKey] === hierarchyId) === index
            );
        };

        const getTotalRowSpan = (row: {
            moduleId: string;
            subModuleId: string;
            topicId: string;
            subtopicId: string;
        }) => {
            let hierarchyKey = "";
            let hierarchyId = "";

            if (exportSelections.hierarchy.module && row.moduleId) {
                hierarchyKey = "moduleId";
                hierarchyId = row.moduleId;
            } else if (exportSelections.hierarchy.subModule && row.subModuleId) {
                hierarchyKey = "subModuleId";
                hierarchyId = row.subModuleId;
            } else if (exportSelections.hierarchy.topic && row.topicId) {
                hierarchyKey = "topicId";
                hierarchyId = row.topicId;
            } else if (exportSelections.hierarchy.subTopic && row.subtopicId) {
                hierarchyKey = "subtopicId";
                hierarchyId = row.subtopicId;
            } else {
                return tableRows.length; // Span all rows if no hierarchy
            }

            return tableRows.filter((r) => r[hierarchyKey] === hierarchyId).length;
        };

        // 4. Fix the merged total value calculation

        const getMergedTotalValue = (row: {
            moduleId: string;
            subModuleId: string;
            topicId: string;
            subtopicId: string;
        }) => {
            let hierarchyKey = "";
            let hierarchyId = "";

            if (exportSelections.hierarchy.module && row.moduleId) {
                hierarchyKey = "moduleId";
                hierarchyId = row.moduleId;
            } else if (exportSelections.hierarchy.subModule && row.subModuleId) {
                hierarchyKey = "subModuleId";
                hierarchyId = row.subModuleId;
            } else if (exportSelections.hierarchy.topic && row.topicId) {
                hierarchyKey = "topicId";
                hierarchyId = row.topicId;
            } else if (exportSelections.hierarchy.subTopic && row.subtopicId) {
                hierarchyKey = "subtopicId";
                hierarchyId = row.subtopicId;
            } else {
                // No hierarchy selected - calculate total for all rows
                return tableRows.reduce((total, r) => total + calculateRowTotal(r), 0);
            }

            // Get all rows in this hierarchy group
            const rowsInGroup = tableRows.filter(
                (r) => r[hierarchyKey] === hierarchyId
            );
            const rowIndicesInGroup = rowsInGroup.map((r) => tableRows.indexOf(r));

            // Check if any teaching elements are selected
            const hasSelectedTeachingElements =
                selectedIDoActivities.length > 0 ||
                selectedWeDoActivities.length > 0 ||
                selectedYouDoActivities.length > 0;

            let total = 0;
            const processedMerges = new Set();

            // Determine which activities to process
            const activitiesToProcess = hasSelectedTeachingElements
                ? {
                    iDo: selectedIDoActivities,
                    weDo: selectedWeDoActivities,
                    youDo: selectedYouDoActivities,
                }
                : {
                    iDo: activityTypes.iDo || [],
                    weDo: activityTypes.weDo || [],
                    youDo: activityTypes.youDo || [],
                };

            // Process each activity type
            ["iDo", "weDo", "youDo"].forEach((type) => {
                const activities =
                    activitiesToProcess[type as keyof typeof activitiesToProcess];

                activities.forEach((activity) => {
                    const columnKey = `${type}-${activity}`;
                    const merges = mergedCells[columnKey] || [];

                    // Check each merge for this column
                    merges.forEach((merge, mergeIndex) => {
                        const mergeId = `${columnKey}-${mergeIndex}`;

                        if (!processedMerges.has(mergeId)) {
                            // Get row indices for this merge
                            const mergeRowIndices =
                                merge.rowIds
                                    ?.map((rid: string) =>
                                        tableRows.findIndex((r: any) => r.rowId === rid)
                                    )
                                    .filter((idx: number) => idx !== -1) || [];

                            // Check if ANY row from this merge is in our hierarchy group
                            const hasMergeInGroup = mergeRowIndices.some((idx: number) =>
                                rowIndicesInGroup.includes(idx)
                            );

                            if (hasMergeInGroup) {
                                total += merge.value || 0;
                                processedMerges.add(mergeId);
                            }
                        }
                    });

                    // Process unmerged cells in this group
                    rowsInGroup.forEach((r) => {
                        const rowIndex = tableRows.indexOf(r);
                        const mergeInfo = isCellMerged(
                            rowIndex,
                            type as "iDo" | "weDo" | "youDo",
                            activity
                        );

                        if (!mergeInfo.isMerged) {
                            // Only add unmerged cell values
                            const cellValue = getCellValueForRow(
                                r,
                                type as "iDo" | "weDo" | "youDo",
                                activity
                            );
                            total += cellValue || 0;
                        }
                    });
                });
            });

            return total;
        };

        const getStickyLeftPositions = () => {
            const positions: { [key: string]: number } = {};
            let currentLeft = 0;

            if (
                exportSelections.hierarchy.module &&
                selectedCourse?.courseHierarchy.includes("Module")
            ) {
                positions["module"] = currentLeft;
                currentLeft += 80; // Fixed width for module column
            }

            if (
                exportSelections.hierarchy.subModule &&
                selectedCourse?.courseHierarchy.includes("Sub Module")
            ) {
                positions["subModule"] = currentLeft;
                currentLeft += 80; // Fixed width for submodule column
            }

            if (
                exportSelections.hierarchy.topic &&
                selectedCourse?.courseHierarchy.includes("Topic")
            ) {
                positions["topic"] = currentLeft;
                currentLeft += 80; // Fixed width for topic column
            }

            if (
                exportSelections.hierarchy.subTopic &&
                selectedCourse?.courseHierarchy.includes("Sub Topic")
            ) {
                positions["subTopic"] = currentLeft;
                currentLeft += 80; // Fixed width for subtopic column
            }

            if (exportSelections.hierarchy.level) {
                positions["level"] = currentLeft;
                currentLeft += 60; // Fixed width for level column
            }

            return positions;
        };

        const stickyPositions = getStickyLeftPositions();
        const getSelectedActivities = (type: "iDo" | "weDo" | "youDo") => {
            const exportKey = type as keyof typeof exportSelections.pedagogy;
            return selectedPedagogyTypes.includes(type) &&
                Array.isArray(exportSelections.pedagogy[exportKey])
                ? activityTypes[type].filter((activity) =>
                    (exportSelections.pedagogy[exportKey] as string[]).includes(
                        activity
                    )
                )
                : [];
        };

        const hasSelectedActivities = (type: "iDo" | "weDo" | "youDo") => {
            return getSelectedActivities(type).length > 0;
        };

        // Calculate selected activities for each type
        const selectedIDoActivities = getSelectedActivities("iDo");
        const selectedWeDoActivities = getSelectedActivities("weDo");
        const selectedYouDoActivities = getSelectedActivities("youDo");

        // Calculate if we should show teaching elements section
        const showTeachingElements =
            selectedPedagogyTypes.length > 0 &&
            (selectedIDoActivities.length > 0 ||
                selectedWeDoActivities.length > 0 ||
                selectedYouDoActivities.length > 0);

        // Calculate total selected activities count
        const totalSelectedActivities =
            selectedIDoActivities.length +
            selectedWeDoActivities.length +
            selectedYouDoActivities.length;
        // Count visible category headers (only those with selected activities)
        const visibleCategoryCount = [
            hasSelectedActivities("iDo"),
            hasSelectedActivities("weDo"),
            hasSelectedActivities("youDo"),
        ].filter(Boolean).length;

        // sarathi
        // Calculate summary activities
        const summaryActivities =
            exportSelections.showSummary && exportSelections.printPedagogy
                ? {
                    iDo: Array.isArray(exportSelections.printPedagogy.iDo)
                        ? exportSelections.printPedagogy.iDo
                        : [],
                    weDo: Array.isArray(exportSelections.printPedagogy.weDo)
                        ? exportSelections.printPedagogy.weDo
                        : [],
                    youDo: Array.isArray(exportSelections.printPedagogy.youDo)
                        ? exportSelections.printPedagogy.youDo
                        : [],
                }
                : {
                    iDo: [],
                    weDo: [],
                    youDo: [],
                };

        // Calculate merged value for a specific activity type
        const getMergedActivityValue = (
            row: any,
            type: "iDo" | "weDo" | "youDo",
            activity: string
        ) => {
            let hierarchyKey = "";
            let hierarchyId = "";

            if (exportSelections.hierarchy.module && row.moduleId) {
                hierarchyKey = "moduleId";
                hierarchyId = row.moduleId;
            } else if (exportSelections.hierarchy.subModule && row.subModuleId) {
                hierarchyKey = "subModuleId";
                hierarchyId = row.subModuleId;
            } else if (exportSelections.hierarchy.topic && row.topicId) {
                hierarchyKey = "topicId";
                hierarchyId = row.topicId;
            } else if (exportSelections.hierarchy.subTopic && row.subtopicId) {
                hierarchyKey = "subtopicId";
                hierarchyId = row.subtopicId;
            } else {
                // No hierarchy selected - calculate total for all rows
                return tableRows.reduce((total, r) => {
                    const mergeInfo = isCellMerged(tableRows.indexOf(r), type, activity);
                    const cellValue = mergeInfo.isMerged
                        ? mergeInfo.isStart
                            ? mergeInfo.value
                            : 0
                        : getCellValueForRow(r, type, activity);
                    return total + (cellValue || 0);
                }, 0);
            }

            // Calculate total for all rows with the same hierarchy ID
            const rowsInGroup = tableRows.filter(
                (r) => r[hierarchyKey] === hierarchyId
            );
            return rowsInGroup.reduce((total, r) => {
                const mergeInfo = isCellMerged(tableRows.indexOf(r), type, activity);
                const cellValue = mergeInfo.isMerged
                    ? mergeInfo.isStart
                        ? mergeInfo.value
                        : 0
                    : getCellValueForRow(r, type, activity);
                return total + (cellValue || 0);
            }, 0);
        };

        // Calculate total hierarchy columns
        const totalHierarchyColumns =
            (selectedCourse?.courseHierarchy.includes("Module") &&
                exportSelections.hierarchy.module
                ? 1
                : 0) +
            (selectedCourse?.courseHierarchy.includes("Sub Module") &&
                exportSelections.hierarchy.subModule
                ? 1
                : 0) +
            (selectedCourse?.courseHierarchy.includes("Topic") &&
                exportSelections.hierarchy.topic
                ? 1
                : 0) +
            (selectedCourse?.courseHierarchy.includes("Sub Topic") &&
                exportSelections.hierarchy.subTopic
                ? 1
                : 0) +
            (exportSelections.hierarchy.level ? 1 : 0);

        return (
            <div className="overflow-x-auto">
                {showTeachingElements ||
                    totalHierarchyColumns ||
                    exportSelections.showSummary > 0 ? (
                    <Table className="border-separate  border-spacing-0  w-full text-[8px]">
                        <TableHeader>
                            <TableRow className="bg-blue-100">
                                {/* Dynamic hierarchy columns */}
                                {exportSelections.hierarchy.module &&
                                    selectedCourse?.courseHierarchy.includes("Module") && (
                                        <TableHead
                                            className="border border-gray-400 text-center font-bold p-0.5 sticky bg-blue-100 z-10 min-w-[80px]"
                                            style={{ left: `${stickyPositions["module"]}px` }}
                                            rowSpan={3}
                                        >
                                            Module
                                        </TableHead>
                                    )}
                                {exportSelections.hierarchy.subModule &&
                                    selectedCourse?.courseHierarchy.includes("Sub Module") && (
                                        <TableHead
                                            className="border border-gray-400 text-center font-bold p-0.5  bg-blue-100 z-10 min-w-[80px]"
                                            style={{ left: `${stickyPositions["subModule"]}px` }}
                                            rowSpan={3}
                                        >
                                            Sub Module
                                        </TableHead>
                                    )}
                                {exportSelections.hierarchy.topic &&
                                    selectedCourse?.courseHierarchy.includes("Topic") && (
                                        <TableHead
                                            className="border border-gray-400 text-center font-bold p-0.5  bg-blue-100 z-10 min-w-[80px]"
                                            style={{ left: `${stickyPositions["topic"]}px` }}
                                            rowSpan={3}
                                        >
                                            Topic
                                        </TableHead>
                                    )}
                                {exportSelections.hierarchy.subTopic &&
                                    selectedCourse?.courseHierarchy.includes("Sub Topic") && (
                                        <TableHead
                                            className="border border-gray-400 text-center font-bold p-0.5  bg-blue-100 z-10 min-w-[80px]"
                                            style={{ left: `${stickyPositions["subTopic"]}px` }}
                                            rowSpan={3}
                                        >
                                            Sub Topic
                                        </TableHead>
                                    )}
                                {exportSelections.hierarchy.level && (
                                    <TableHead
                                        className="border border-gray-400 text-center font-bold p-0.5  bg-blue-100 z-10 min-w-[60px]"
                                        style={{ left: `${stickyPositions["level"]}px` }}
                                        rowSpan={3}
                                    >
                                        Level
                                    </TableHead>
                                )}

                                {/* Teaching Learning Elements header - only shown if any activities exist and are selected */}
                                {showTeachingElements && (
                                    <TableHead
                                        className="border border-gray-400 text-center bg-blue-100 font-bold p-0.5"
                                        style={{ width: "40%" }}
                                        colSpan={totalSelectedActivities}
                                    >
                                        {visibleCategoryCount === 3
                                            ? "All Teaching Elements"
                                            : [
                                                hasSelectedActivities("iDo")
                                                    ? "I Do Activities"
                                                    : null,
                                                hasSelectedActivities("weDo")
                                                    ? "We Do Activities"
                                                    : null,
                                                hasSelectedActivities("youDo")
                                                    ? "You Do Activities"
                                                    : null,
                                            ]
                                                .filter(Boolean)
                                                .join(" + ")}
                                    </TableHead>
                                )}

                                {exportSelections.includeTotalHours && (
                                    <TableHead
                                        className="border border-gray-400 text-center bg-blue-100 font-bold p-0.5"
                                        style={{ width: "10%" }}
                                        rowSpan={exportSelections.hierarchy.level ? 3 : 3}
                                    >
                                        Total Hours
                                    </TableHead>
                                )}
                            </TableRow>

                            {/* Activity Type Headers - only shown if multiple types are selected and have activities */}
                            {showTeachingElements && visibleCategoryCount > 1 && (
                                <TableRow className="bg-gray-100">
                                    {hasSelectedActivities("iDo") && (
                                        <TableHead
                                            colSpan={selectedIDoActivities.length}
                                            className="border border-gray-400 text-center font-medium text-[9px] p-0.5 bg-yellow-100"
                                        >
                                            I Do Activities
                                        </TableHead>
                                    )}
                                    {hasSelectedActivities("weDo") && (
                                        <TableHead
                                            colSpan={selectedWeDoActivities.length}
                                            className="border border-gray-400 text-center font-medium text-[9px] p-0.5 bg-orange-100"
                                        >
                                            We Do Activities
                                        </TableHead>
                                    )}
                                    {hasSelectedActivities("youDo") && (
                                        <TableHead
                                            colSpan={selectedYouDoActivities.length}
                                            className="border border-gray-400 text-center font-medium text-[9px] p-0.5 bg-green-100"
                                        >
                                            You Do Activities
                                        </TableHead>
                                    )}
                                </TableRow>
                            )}

                            {/* Activity Names - only shown if teaching elements are selected */}
                            {showTeachingElements &&
                                exportSelections.hoursOption !== "activity" && (
                                    <TableRow className="bg-gray-100">
                                        {selectedIDoActivities.map((activity) => (
                                            <TableHead
                                                key={`iDo-${activity}`}
                                                className="border border-gray-400 text-center font-medium p-0.5 bg-yellow-100 min-w-[50px]"
                                                title={activity}
                                                style={{ width: `${40 / totalSelectedActivities}%` }}
                                            >
                                                <span className="truncate block">{activity}</span>
                                            </TableHead>
                                        ))}
                                        {selectedWeDoActivities.map((activity) => (
                                            <TableHead
                                                key={`weDo-${activity}`}
                                                className="border border-gray-400 text-center font-medium p-0.5 bg-orange-100 min-w-[50px]"
                                                title={activity}
                                                style={{ width: `${40 / totalSelectedActivities}%` }}
                                            >
                                                <span className="truncate block">{activity}</span>
                                            </TableHead>
                                        ))}
                                        {selectedYouDoActivities.map((activity) => (
                                            <TableHead
                                                key={`youDo-${activity}`}
                                                className="border border-gray-400 text-center font-medium p-0.5 bg-green-100 min-w-[50px]"
                                                title={activity}
                                                style={{ width: `${40 / totalSelectedActivities}%` }}
                                            >
                                                <span className="truncate block">{activity}</span>
                                            </TableHead>
                                        ))}
                                    </TableRow>
                                )}
                        </TableHeader>

                        <TableBody>
                            {(() => {
                                const moduleRowTracker: { [key: string]: boolean } = {};
                                const subModuleRowTracker: { [key: string]: boolean } = {};
                                const topicRowTracker: { [key: string]: boolean } = {};
                                const subtopicRowTracker: { [key: string]: boolean } = {};

                                return tableRows.map((row, index) => {
                                    const isFirstSubtopicInModule =
                                        !moduleRowTracker[row.moduleId];
                                    const isFirstSubtopicInSubModule =
                                        !subModuleRowTracker[row.subModuleId];
                                    const isFirstSubtopicInTopic = !topicRowTracker[row.topicId];
                                    const isFirstSubtopicInSubtopic =
                                        !subtopicRowTracker[row.subtopicId];

                                    if (isFirstSubtopicInModule)
                                        moduleRowTracker[row.moduleId] = true;
                                    if (isFirstSubtopicInSubModule)
                                        subModuleRowTracker[row.subModuleId] = true;
                                    if (isFirstSubtopicInTopic)
                                        topicRowTracker[row.topicId] = true;
                                    if (isFirstSubtopicInSubtopic)
                                        subtopicRowTracker[row.subtopicId] = true;

                                    return (
                                        <TableRow
                                            key={`preview-${row.rowId}`}
                                            className="hover:bg-gray-50 h-6 z-0"
                                        >
                                            {/* Module Cell */}
                                            {exportSelections.hierarchy.module &&
                                                selectedCourse?.courseHierarchy.includes("Module") &&
                                                isFirstSubtopicInModule && (
                                                    <TableCell
                                                        rowSpan={moduleSpans[row.moduleId]}
                                                        className={`border border-gray-400 text-left text-[9px] font-medium p-0.5 bg-blue-50 text-center align-middle max-w-[80px] h-6 sticky`}
                                                        style={{ left: `${stickyPositions["module"]}px` }}
                                                    >
                                                        <span
                                                            className="whitespace-normal break-words px-4 text-center flex-1"
                                                            title={
                                                                row.moduleName === "Default Module"
                                                                    ? "-"
                                                                    : row.moduleName
                                                            }
                                                        >
                                                            {row.moduleName === "Default Module"
                                                                ? "-"
                                                                : row.moduleName}
                                                        </span>
                                                    </TableCell>
                                                )}

                                            {/* SubModule Cell */}
                                            {exportSelections.hierarchy.subModule &&
                                                selectedCourse?.courseHierarchy.includes(
                                                    "Sub Module"
                                                ) &&
                                                isFirstSubtopicInSubModule && (
                                                    <TableCell
                                                        rowSpan={subModuleSpans[row.subModuleId]}
                                                        className={`border border-gray-400 text-left p-0.5 bg-blue-50 text-[9px] font-medium text-center align-middle max-w-[80px] h-6  `}
                                                        style={{
                                                            left: `${stickyPositions["subModule"]}px`,
                                                        }}
                                                    >
                                                        <span
                                                            className="whitespace-nowrap overflow-hidden text-ellipsis block px-1"
                                                            title={
                                                                row.subModuleName === "Default Submodule"
                                                                    ? "-"
                                                                    : row.subModuleName
                                                            }
                                                        >
                                                            {row.subModuleName === "Default Submodule"
                                                                ? "-"
                                                                : row.subModuleName}
                                                        </span>
                                                    </TableCell>
                                                )}

                                            {/* Topic Cell */}
                                            {exportSelections.hierarchy.topic &&
                                                selectedCourse?.courseHierarchy.includes("Topic") &&
                                                isFirstSubtopicInTopic && (
                                                    <TableCell
                                                        rowSpan={topicSpans[row.topicId]}
                                                        className={`border border-gray-400 text-left p-0.5 bg-blue-50 text-[9px] font-medium text-center align-middle max-w-[80px] h-6  `}
                                                        style={{ left: `${stickyPositions["topic"]}px` }}
                                                    >
                                                        <span
                                                            className="whitespace-nowrap overflow-hidden text-ellipsis block px-1"
                                                            title={
                                                                row.topicName === "Default Topic"
                                                                    ? "-"
                                                                    : row.topicName
                                                            }
                                                        >
                                                            {row.topicName === "Default Topic"
                                                                ? "-"
                                                                : row.topicName}
                                                        </span>
                                                    </TableCell>
                                                )}

                                            {/* Subtopic Cell */}
                                            {exportSelections.hierarchy.subTopic &&
                                                selectedCourse?.courseHierarchy.includes(
                                                    "Sub Topic"
                                                ) && (
                                                    <TableCell
                                                        className={`border border-gray-400 text-left p-0.5 bg-blue-50 text-[9px] font-medium text-center align-middle max-w-[80px] h-6 `}
                                                        style={{ left: `${stickyPositions["subTopic"]}px` }}
                                                    >
                                                        <span
                                                            className="whitespace-nowrap overflow-hidden text-ellipsis block px-1"
                                                            title={
                                                                row.subtopicName === "Default Subtopic"
                                                                    ? "-"
                                                                    : row.subtopicName
                                                            }
                                                        >
                                                            {row.subtopicName === "Default Subtopic"
                                                                ? "-"
                                                                : row.subtopicName}
                                                        </span>
                                                    </TableCell>
                                                )}

                                            {/* Learning Level Cell */}
                                            {exportSelections.hierarchy.level && (
                                                <>{renderPreviewLevelCell(row, index)}</>
                                            )}

                                            {/* Activity Hours */}
                                            {showTeachingElements &&
                                                exportSelections.hoursOption !== "element" &&
                                                exportSelections.hoursOption !== "activity" && (
                                                    <>
                                                        {selectedIDoActivities.map((activity) => {
                                                            const mergeInfo = isCellMerged(
                                                                index,
                                                                "iDo",
                                                                activity
                                                            );
                                                            if (mergeInfo.isMerged && !mergeInfo.isStart)
                                                                return null;
                                                            return renderActivityCell(
                                                                "iDo",
                                                                activity,
                                                                row,
                                                                index,
                                                                mergeInfo,
                                                                true
                                                            );
                                                        })}
                                                        {selectedWeDoActivities.map((activity) => {
                                                            const mergeInfo = isCellMerged(
                                                                index,
                                                                "weDo",
                                                                activity
                                                            );
                                                            if (mergeInfo.isMerged && !mergeInfo.isStart)
                                                                return null;
                                                            return renderActivityCell(
                                                                "weDo",
                                                                activity,
                                                                row,
                                                                index,
                                                                mergeInfo,
                                                                true
                                                            );
                                                        })}
                                                        {selectedYouDoActivities.map((activity) => {
                                                            const mergeInfo = isCellMerged(
                                                                index,
                                                                "youDo",
                                                                activity
                                                            );
                                                            if (mergeInfo.isMerged && !mergeInfo.isStart)
                                                                return null;
                                                            return renderActivityCell(
                                                                "youDo",
                                                                activity,
                                                                row,
                                                                index,
                                                                mergeInfo,
                                                                true
                                                            );
                                                        })}
                                                    </>
                                                )}

                                            {/* Activity Hours */}
                                            {showTeachingElements &&
                                                exportSelections.hoursOption === "element" &&
                                                isFirstInMergedGroup(row, index) && (
                                                    <>
                                                        {/* Individual I Do Activities with hierarchy merging */}
                                                        {selectedIDoActivities.map((activity) => (
                                                            <TableCell
                                                                key={`element-ido-${activity}-${row.rowId}`}
                                                                className="border border-gray-400 text-center p-0.5 bg-yellow-100 min-w-[50px] h-6"
                                                                rowSpan={getTotalRowSpan(row)}
                                                            >
                                                                {getMergedActivityValue(row, "iDo", activity)}
                                                            </TableCell>
                                                        ))}

                                                        {/* Individual We Do Activities with hierarchy merging */}
                                                        {selectedWeDoActivities.map((activity) => (
                                                            <TableCell
                                                                key={`element-wedo-${activity}-${row.rowId}`}
                                                                className="border border-gray-400 text-center p-0.5 bg-orange-100 min-w-[50px] h-6"
                                                                rowSpan={getTotalRowSpan(row)}
                                                            >
                                                                {getMergedActivityValue(row, "weDo", activity)}
                                                            </TableCell>
                                                        ))}

                                                        {/* Individual You Do Activities with hierarchy merging */}
                                                        {selectedYouDoActivities.map((activity) => (
                                                            <TableCell
                                                                key={`element-youdo-${activity}-${row.rowId}`}
                                                                className="border border-gray-400 text-center p-0.5 bg-green-100 min-w-[50px] h-6"
                                                                rowSpan={getTotalRowSpan(row)}
                                                            >
                                                                {getMergedActivityValue(row, "youDo", activity)}
                                                            </TableCell>
                                                        ))}
                                                    </>
                                                )}

                                            {/* Activity Hours Totals (Category view) */}
                                            {showTeachingElements &&
                                                exportSelections.hoursOption === "activity" &&
                                                isFirstInMergedGroup(row, index) && (
                                                    <>
                                                        {/* I Do Total */}
                                                        {hasSelectedActivities("iDo") && (
                                                            <TableCell
                                                                className="border border-gray-400 text-center font-bold p-0.5 bg-yellow-100 min-w-[50px] h-6"
                                                                rowSpan={getTotalRowSpan(row)}
                                                                colSpan={selectedIDoActivities.length}
                                                            >
                                                                {selectedIDoActivities.reduce(
                                                                    (sum, activity) =>
                                                                        sum +
                                                                        getMergedActivityValue(
                                                                            row,
                                                                            "iDo",
                                                                            activity
                                                                        ),
                                                                    0
                                                                )}
                                                            </TableCell>
                                                        )}

                                                        {/* We Do Total */}
                                                        {hasSelectedActivities("weDo") && (
                                                            <TableCell
                                                                className="border border-gray-400 text-center font-bold p-0.5 bg-orange-100 min-w-[50px] h-6"
                                                                rowSpan={getTotalRowSpan(row)}
                                                                colSpan={selectedWeDoActivities.length}
                                                            >
                                                                {selectedWeDoActivities.reduce(
                                                                    (sum, activity) =>
                                                                        sum +
                                                                        getMergedActivityValue(
                                                                            row,
                                                                            "weDo",
                                                                            activity
                                                                        ),
                                                                    0
                                                                )}
                                                            </TableCell>
                                                        )}

                                                        {/* You Do Total */}
                                                        {hasSelectedActivities("youDo") && (
                                                            <TableCell
                                                                className="border border-gray-400 text-center font-bold p-0.5 bg-green-100 min-w-[50px] h-6"
                                                                rowSpan={getTotalRowSpan(row)}
                                                                colSpan={selectedYouDoActivities.length}
                                                            >
                                                                {selectedYouDoActivities.reduce(
                                                                    (sum, activity) =>
                                                                        sum +
                                                                        getMergedActivityValue(
                                                                            row,
                                                                            "youDo",
                                                                            activity
                                                                        ),
                                                                    0
                                                                )}
                                                            </TableCell>
                                                        )}
                                                    </>
                                                )}

                                            {/* // In the table row rendering, after the activity cells, add: */}
                                            {exportSelections.includeTotalHours &&
                                                (isFirstInMergedGroup(row, index) ? (
                                                    <TableCell
                                                        className="border border-gray-400 text-center font-bold p-0.5 bg-gray-100 min-w-[50px] h-6"
                                                        rowSpan={getTotalRowSpan(row)}
                                                    >
                                                        {getMergedTotalValue(row)}
                                                    </TableCell>
                                                ) : null)}
                                        </TableRow>
                                    );
                                });
                            })()}

                            {/* Total Hours Row */}
                            {(exportSelections.includeTotalHours || showTeachingElements) && (
                                <TableRow className="bg-gray-200 font-bold">
                                    {(() => {
                                        const totalHierarchyCols =
                                            (selectedCourse?.courseHierarchy.includes("Module") &&
                                                exportSelections.hierarchy.module
                                                ? 1
                                                : 0) +
                                            (selectedCourse?.courseHierarchy.includes("Sub Module") &&
                                                exportSelections.hierarchy.subModule
                                                ? 1
                                                : 0) +
                                            (selectedCourse?.courseHierarchy.includes("Topic") &&
                                                exportSelections.hierarchy.topic
                                                ? 1
                                                : 0) +
                                            (selectedCourse?.courseHierarchy.includes("Sub Topic") &&
                                                exportSelections.hierarchy.subTopic
                                                ? 1
                                                : 0) +
                                            (exportSelections.hierarchy.level ? 1 : 0);

                                        return totalHierarchyCols > 0 ? (
                                            <TableCell
                                                className={`border border-gray-400 text-center p-0.5 bg-gray-200 sticky z-10`}
                                                style={{ left: "0px" }}
                                                colSpan={totalHierarchyCols}
                                            >
                                                Total Hours
                                            </TableCell>
                                        ) : null;
                                    })()}

                                    {exportSelections.hoursOption === "element" ? (
                                        <>
                                            {selectedIDoActivities.map((activity) => (
                                                <TableCell
                                                    key={`preview-total-iDo-${activity}`}
                                                    className="border border-gray-400 text-center font-bold p-0.5 bg-yellow-100 min-w-[50px] h-6"
                                                >
                                                    {calculateTotalHours("iDo", activity) || "0"}
                                                </TableCell>
                                            ))}
                                            {selectedWeDoActivities.map((activity) => (
                                                <TableCell
                                                    key={`preview-total-weDo-${activity}`}
                                                    className="border border-gray-400 text-center font-bold p-0.5 bg-orange-100 min-w-[50px] h-6"
                                                >
                                                    {calculateTotalHours("weDo", activity) || "0"}
                                                </TableCell>
                                            ))}
                                            {selectedYouDoActivities.map((activity) => (
                                                <TableCell
                                                    key={`preview-total-youDo-${activity}`}
                                                    className="border border-gray-400 text-center font-bold p-0.5 bg-green-100 min-w-[50px] h-6"
                                                >
                                                    {calculateTotalHours("youDo", activity) || "0"}
                                                </TableCell>
                                            ))}
                                        </>
                                    ) : exportSelections.hoursOption === "activity" ? (
                                        <>
                                            {hasSelectedActivities("iDo") && (
                                                <TableCell
                                                    className="border border-gray-400 text-center font-bold p-0.5 bg-yellow-100 min-w-[50px] h-6"
                                                    colSpan={selectedIDoActivities.length}
                                                >
                                                    {selectedIDoActivities.reduce(
                                                        (sum, activity) =>
                                                            sum + calculateTotalHours("iDo", activity),
                                                        0
                                                    )}
                                                </TableCell>
                                            )}
                                            {hasSelectedActivities("weDo") && (
                                                <TableCell
                                                    className="border border-gray-400 text-center font-bold p-0.5 bg-orange-100 min-w-[50px] h-6"
                                                    colSpan={selectedWeDoActivities.length}
                                                >
                                                    {selectedWeDoActivities.reduce(
                                                        (sum, activity) =>
                                                            sum + calculateTotalHours("weDo", activity),
                                                        0
                                                    )}
                                                </TableCell>
                                            )}
                                            {hasSelectedActivities("youDo") && (
                                                <TableCell
                                                    className="border border-gray-400 text-center font-bold p-0.5 bg-green-100 min-w-[50px] h-6"
                                                    colSpan={selectedYouDoActivities.length}
                                                >
                                                    {selectedYouDoActivities.reduce(
                                                        (sum, activity) =>
                                                            sum + calculateTotalHours("youDo", activity),
                                                        0
                                                    )}
                                                </TableCell>
                                            )}
                                        </>
                                    ) : (
                                        // )}
                                        // Case 3: default - one total for everything
                                        <>
                                            {selectedIDoActivities.map((activity) => (
                                                <TableCell
                                                    key={`preview-total-iDo-${activity}`}
                                                    className="border border-gray-400 text-center font-bold p-0.5 bg-yellow-100 min-w-[50px] h-6"
                                                >
                                                    {calculateTotalHours("iDo", activity) || "0"}
                                                </TableCell>
                                            ))}
                                            {selectedWeDoActivities.map((activity) => (
                                                <TableCell
                                                    key={`preview-total-weDo-${activity}`}
                                                    className="border border-gray-400 text-center font-bold p-0.5 bg-orange-100 min-w-[50px] h-6"
                                                >
                                                    {calculateTotalHours("weDo", activity) || "0"}
                                                </TableCell>
                                            ))}
                                            {selectedYouDoActivities.map((activity) => (
                                                <TableCell
                                                    key={`preview-total-youDo-${activity}`}
                                                    className="border border-gray-400 text-center font-bold p-0.5 bg-green-100 min-w-[50px] h-6"
                                                >
                                                    {calculateTotalHours("youDo", activity) || "0"}
                                                </TableCell>
                                            ))}
                                        </>
                                    )}

                                    {((exportSelections.includeTotalHours &&
                                        showTeachingElements) ||
                                        exportSelections.includeTotalHours) && (
                                            <TableCell className="border border-gray-400 text-center font-bold p-0.5 bg-gray-100 min-w-[50px] h-6">
                                                {(() => {
                                                    let grandTotal = 0;

                                                    const calculateTypeTotal = (
                                                        type: "iDo" | "weDo" | "youDo",
                                                        activities: string[]
                                                    ) => {
                                                        return activities.reduce((total, activity) => {
                                                            return (
                                                                total + (calculateTotalHours(type, activity) || 0)
                                                            );
                                                        }, 0);
                                                    };

                                                    grandTotal += calculateTypeTotal(
                                                        "iDo",
                                                        activityTypes.iDo || []
                                                    );
                                                    grandTotal += calculateTypeTotal(
                                                        "weDo",
                                                        activityTypes.weDo || []
                                                    );
                                                    grandTotal += calculateTypeTotal(
                                                        "youDo",
                                                        activityTypes.youDo || []
                                                    );

                                                    return grandTotal;
                                                })()}
                                            </TableCell>
                                        )}
                                </TableRow>
                            )}
                            {/* Summary Section */}
                            {exportSelections.showSummary &&
                                isPrinting &&
                                (summaryActivities.iDo.length > 0 ||
                                    summaryActivities.weDo.length > 0 ||
                                    summaryActivities.youDo.length > 0) && (
                                    <TableRow>
                                        <TableCell
                                            colSpan={totalHierarchyColumns + totalSelectedActivities}
                                            className="p-2 bg-gray-50"
                                        >
                                            <div className="text-xs font-semibold text-center mb-2">
                                                Teaching Elements Summary
                                            </div>

                                            <div className="flex justify-center">
                                                <table className="w-full max-w-2xl border-collapse">
                                                    <thead>
                                                        <tr>
                                                            <th className="border border-gray-300 bg-blue-500 text-white p-1 text-xs">
                                                                Activity Type
                                                            </th>
                                                            <th className="border border-gray-300 bg-blue-500 text-white p-1 text-xs">
                                                                Elements
                                                            </th>
                                                            <th className="border border-gray-300 bg-blue-500 text-white p-1 text-xs">
                                                                Elements Total Hours
                                                            </th>
                                                            {exportSelections.summaryIncludeTotalHours && (
                                                                <th className="border border-gray-300 bg-blue-500 text-white p-1 text-xs">
                                                                    Activity Total Hours
                                                                </th>
                                                            )}

                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        {/* I Do Summary */}
                                                        {summaryActivities.iDo.length > 0 &&
                                                            summaryActivities.iDo.map(
                                                                (
                                                                    activity:
                                                                        | string
                                                                        | number
                                                                        | bigint
                                                                        | boolean
                                                                        | React.ReactElement<
                                                                            unknown,
                                                                            | string
                                                                            | React.JSXElementConstructor<any>
                                                                        >
                                                                        | Iterable<React.ReactNode>
                                                                        | Promise<
                                                                            | string
                                                                            | number
                                                                            | bigint
                                                                            | boolean
                                                                            | React.ReactPortal
                                                                            | React.ReactElement<
                                                                                unknown,
                                                                                | string
                                                                                | React.JSXElementConstructor<any>
                                                                            >
                                                                            | Iterable<React.ReactNode>
                                                                            | null
                                                                            | undefined
                                                                        >
                                                                        | null
                                                                        | undefined,
                                                                    index: number
                                                                ) => (
                                                                    <tr
                                                                        key={`summary-ido-${activity}`}
                                                                        className={
                                                                            index % 2 === 0
                                                                                ? "bg-yellow-50"
                                                                                : "bg-yellow-100"
                                                                        }
                                                                    >
                                                                        {index === 0 && (
                                                                            <td
                                                                                rowSpan={summaryActivities.iDo.length}
                                                                                className="border border-gray-300 p-1 text-xs font-medium text-center align-middle bg-yellow-200"
                                                                            >
                                                                                I Do Activities
                                                                            </td>
                                                                        )}
                                                                        <td className="border border-gray-300 p-1 text-xs">
                                                                            {activity}
                                                                        </td>
                                                                        <td className="border border-gray-300 p-1 text-xs text-center">
                                                                            {calculateTotalHours(
                                                                                "iDo",
                                                                                String(activity)
                                                                            )}
                                                                        </td>
                                                                        {exportSelections.summaryIncludeTotalHours && index === 0 && (
                                                                            <td
                                                                                rowSpan={summaryActivities.iDo.length}
                                                                                className="border border-gray-300 p-1 text-xs text-center font-bold bg-yellow-200"
                                                                            >
                                                                                {summaryActivities.iDo.reduce(
                                                                                    (sum: number, act: string) =>
                                                                                        sum + calculateTotalHours("iDo", act),
                                                                                    0
                                                                                )}
                                                                            </td>
                                                                        )}
                                                                    </tr>
                                                                )
                                                            )}

                                                        {/* We Do Summary */}
                                                        {summaryActivities.weDo.length > 0 &&
                                                            summaryActivities.weDo.map(
                                                                (
                                                                    activity:
                                                                        | string
                                                                        | number
                                                                        | bigint
                                                                        | boolean
                                                                        | React.ReactElement<
                                                                            unknown,
                                                                            | string
                                                                            | React.JSXElementConstructor<any>
                                                                        >
                                                                        | Iterable<React.ReactNode>
                                                                        | Promise<
                                                                            | string
                                                                            | number
                                                                            | bigint
                                                                            | boolean
                                                                            | React.ReactPortal
                                                                            | React.ReactElement<
                                                                                unknown,
                                                                                | string
                                                                                | React.JSXElementConstructor<any>
                                                                            >
                                                                            | Iterable<React.ReactNode>
                                                                            | null
                                                                            | undefined
                                                                        >
                                                                        | null
                                                                        | undefined,
                                                                    index: number
                                                                ) => (
                                                                    <tr
                                                                        key={`summary-wedo-${activity}`}
                                                                        className={
                                                                            index % 2 === 0
                                                                                ? "bg-orange-50"
                                                                                : "bg-orange-100"
                                                                        }
                                                                    >
                                                                        {index === 0 && (
                                                                            <td
                                                                                rowSpan={summaryActivities.weDo.length}
                                                                                className="border border-gray-300 p-1 text-xs font-medium text-center align-middle bg-orange-200"
                                                                            >
                                                                                We Do Activities
                                                                            </td>
                                                                        )}
                                                                        <td className="border border-gray-300 p-1 text-xs">
                                                                            {activity}
                                                                        </td>
                                                                        <td className="border border-gray-300 p-1 text-xs text-center">
                                                                            {calculateTotalHours(
                                                                                "weDo",
                                                                                String(activity)
                                                                            )}
                                                                        </td>
                                                                        {exportSelections.summaryIncludeTotalHours && index === 0 && (
                                                                            <td
                                                                                rowSpan={summaryActivities.weDo.length}
                                                                                className="border border-gray-300 p-1 text-xs text-center font-bold bg-orange-200"
                                                                            >
                                                                                {summaryActivities.weDo.reduce(
                                                                                    (sum: number, act: string) =>
                                                                                        sum + calculateTotalHours("weDo", act),
                                                                                    0
                                                                                )}
                                                                            </td>
                                                                        )}
                                                                    </tr>
                                                                )
                                                            )}

                                                        {/* You Do Summary */}
                                                        {summaryActivities.youDo.length > 0 &&
                                                            summaryActivities.youDo.map(
                                                                (
                                                                    activity:
                                                                        | string
                                                                        | number
                                                                        | bigint
                                                                        | boolean
                                                                        | React.ReactElement<
                                                                            unknown,
                                                                            | string
                                                                            | React.JSXElementConstructor<any>
                                                                        >
                                                                        | Iterable<React.ReactNode>
                                                                        | Promise<
                                                                            | string
                                                                            | number
                                                                            | bigint
                                                                            | boolean
                                                                            | React.ReactPortal
                                                                            | React.ReactElement<
                                                                                unknown,
                                                                                | string
                                                                                | React.JSXElementConstructor<any>
                                                                            >
                                                                            | Iterable<React.ReactNode>
                                                                            | null
                                                                            | undefined
                                                                        >
                                                                        | null
                                                                        | undefined,
                                                                    index: number
                                                                ) => (
                                                                    <tr
                                                                        key={`summary-youdo-${activity}`}
                                                                        className={
                                                                            index % 2 === 0
                                                                                ? "bg-green-50"
                                                                                : "bg-green-100"
                                                                        }
                                                                    >
                                                                        {index === 0 && (
                                                                            <td
                                                                                rowSpan={summaryActivities.youDo.length}
                                                                                className="border border-gray-300 p-1 text-xs font-medium text-center align-middle bg-green-200"
                                                                            >
                                                                                You Do Activities
                                                                            </td>
                                                                        )}
                                                                        <td className="border border-gray-300 p-1 text-xs">
                                                                            {activity}
                                                                        </td>
                                                                        <td className="border border-gray-300 p-1 text-xs text-center">
                                                                            {calculateTotalHours(
                                                                                "youDo",
                                                                                String(activity)
                                                                            )}
                                                                        </td>
                                                                        {exportSelections.summaryIncludeTotalHours && index === 0 && (
                                                                            <td
                                                                                rowSpan={summaryActivities.youDo.length}
                                                                                className="border border-gray-300 p-1 text-xs text-center font-bold bg-green-200"
                                                                            >
                                                                                {summaryActivities.youDo.reduce(
                                                                                    (sum: number, act: string) =>
                                                                                        sum + calculateTotalHours("youDo", act),
                                                                                    0
                                                                                )}
                                                                            </td>
                                                                        )}
                                                                    </tr>
                                                                )
                                                            )}

                                                        {/* Grand Total */}
                                                        <tr className="bg-blue-100 font-bold">
                                                            <td
                                                                colSpan={2}
                                                                className="border border-gray-300 p-1 text-xs text-right"
                                                            >
                                                                Total Hours
                                                            </td>
                                                            <td className="border border-gray-300 p-1 text-xs text-center">
                                                                {Object.entries(summaryActivities).reduce(
                                                                    (sum, [type, activities]) => {
                                                                        return (
                                                                            sum +
                                                                            activities.reduce(
                                                                                (typeSum: number, activity: string) => {
                                                                                    return (
                                                                                        typeSum +
                                                                                        calculateTotalHours(
                                                                                            type as "iDo" | "weDo" | "youDo",
                                                                                            String(activity)
                                                                                        )
                                                                                    );
                                                                                },
                                                                                0
                                                                            )
                                                                        );
                                                                    },
                                                                    0
                                                                )}
                                                            </td>
                                                            {exportSelections.summaryIncludeTotalHours && (
                                                                <td className="border border-gray-300 p-1 text-xs text-center">
                                                                    {Object.entries(summaryActivities).reduce(
                                                                        (sum, [type, activities]) => {
                                                                            return (
                                                                                sum +
                                                                                activities.reduce(
                                                                                    (typeSum: number, activity: string) => {
                                                                                        return (
                                                                                            typeSum +
                                                                                            calculateTotalHours(
                                                                                                type as "iDo" | "weDo" | "youDo",
                                                                                                String(activity)
                                                                                            )
                                                                                        );
                                                                                    },
                                                                                    0
                                                                                )
                                                                            );
                                                                        },
                                                                        0
                                                                    )}
                                                                </td>
                                                            )}
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                        </TableCell>
                                    </TableRow>
                                )}
                        </TableBody>
                    </Table>
                ) : (
                    // Show message when nothing is selected
                    <div className="flex items-center justify-center p-8 bg-gray-50 rounded-lg border border-dashed border-gray-300">
                        <div className="text-center">
                            <div className="mx-auto h-12 w-12 text-gray-400">
                                <FileText className="h-12 w-12" />
                            </div>
                            <h3 className="mt-2 text-sm font-medium text-gray-900">
                                Nothing to display
                            </h3>
                            <p className="mt-1 text-sm text-gray-500">
                                Please select at least one hierarchy column or teaching element
                                to see the preview.
                            </p>
                        </div>
                    </div>
                )}
            </div>
        );
    };
    const DuplicationPreviewTable = ({
        tableRows,
        selectedCourse,
        moduleSpans,
        subModuleSpans,
        topicSpans,
    }: {
        tableRows: any[];
        selectedCourse: Course | null;
        moduleSpans: { [key: string]: number };
        subModuleSpans: { [key: string]: number };
        topicSpans: { [key: string]: number };
    }) => {
        const getStickyLeftPositions = () => {
            const positions: { [key: string]: number } = {};
            let currentLeft = enableModuleSelection ? 40 : 0;

            // Only show hierarchy levels that are selected for duplication
            const selectedHierarchy = selectedDuplicateOptions.hierarchy.map(level =>
                level === 'SubModule' ? 'Sub Module' :
                    level === 'SubTopic' ? 'Sub Topic' : level
            );

            if (selectedHierarchy.includes('Module')) {
                positions['module'] = currentLeft;
                currentLeft += 80;
            }

            if (selectedHierarchy.includes('Sub Module')) {
                positions['subModule'] = currentLeft;
                currentLeft += 80;
            }

            if (selectedHierarchy.includes('Topic')) {
                positions['topic'] = currentLeft;
                currentLeft += 80;
            }

            if (selectedHierarchy.includes('Sub Topic')) {
                positions['subTopic'] = currentLeft;
                currentLeft += 80;
            }

            return positions;
        };

        const stickyPositions = getStickyLeftPositions();

        // Get the selected hierarchy levels for display
        const selectedHierarchy = selectedDuplicateOptions.hierarchy.map(level =>
            level === 'SubModule' ? 'Sub Module' :
                level === 'SubTopic' ? 'Sub Topic' : level
        );

        // Get unique modules for checkbox handling
        const uniqueModules = useMemo(() => {
            const modulesMap = new Map();
            tableRows.forEach(row => {
                if (!modulesMap.has(row.moduleId) && row.moduleId) {
                    modulesMap.set(row.moduleId, {
                        id: row.moduleId,
                        name: row.moduleName,
                        rowIndex: row.rowIndex
                    });
                }
            });
            return Array.from(modulesMap.values());
        }, [tableRows]);

        const handleModuleSelect = (moduleId: string, checked: boolean) => {
            setSelectedModulesForDuplication(prev => {
                const newSet = new Set(prev);
                if (checked) {
                    newSet.add(moduleId);
                } else {
                    newSet.delete(moduleId);
                }
                return newSet;
            });
        };

        const handleSelectAllModules = (checked: boolean) => {
            if (checked) {
                const allModuleIds = uniqueModules.map(module => module.id);
                setSelectedModulesForDuplication(new Set(allModuleIds));
            } else {
                setSelectedModulesForDuplication(new Set());
            }
        };

        const allModulesSelected = uniqueModules.length > 0 &&
            selectedModulesForDuplication.size === uniqueModules.length;

        return (
            <div className="overflow-x-auto">
                <Table className="border-separate border-spacing-0 w-full text-[8px]">
                    <TableHeader>
                        <TableRow className="bg-blue-100">
                            {/* Checkbox column header - only show if module selection is enabled AND Module is in selected hierarchy */}
                            {enableModuleSelection && selectedHierarchy.includes('Module') && (
                                <TableHead className="border border-gray-400 text-center font-bold p-0.5 sticky bg-blue-100 z-20 left-0">
                                    <div className="flex items-center justify-center">
                                        <Checkbox
                                            checked={allModulesSelected}
                                            onCheckedChange={handleSelectAllModules}
                                            className="h-3 border border-gray-400 w-3"
                                        />
                                    </div>
                                </TableHead>
                            )}

                            {/* Only show columns for selected hierarchy levels */}
                            {selectedHierarchy.includes('Module') && (
                                <TableHead
                                    className="border border-gray-400 text-center font-bold p-0.5 sticky bg-blue-100 z-10 min-w-[80px]"
                                    style={{ left: `${stickyPositions['module']}px` }}
                                >
                                    Module
                                </TableHead>
                            )}
                            {selectedHierarchy.includes('Sub Module') && (
                                <TableHead
                                    className="border border-gray-400 text-center font-bold p-0.5 sticky bg-blue-100 z-10 min-w-[80px]"
                                    style={{ left: `${stickyPositions['subModule']}px` }}
                                >
                                    Sub Module
                                </TableHead>
                            )}
                            {selectedHierarchy.includes('Topic') && (
                                <TableHead
                                    className="border border-gray-400 text-center font-bold p-0.5 sticky bg-blue-100 z-10 min-w-[80px]"
                                    style={{ left: `${stickyPositions['topic']}px` }}
                                >
                                    Topic
                                </TableHead>
                            )}
                            {selectedHierarchy.includes('Sub Topic') && (
                                <TableHead
                                    className="border border-gray-400 text-center font-bold p-0.5 sticky bg-blue-100 z-10 min-w-[80px]"
                                    style={{ left: `${stickyPositions['subTopic']}px` }}
                                >
                                    Sub Topic
                                </TableHead>
                            )}
                        </TableRow>
                    </TableHeader>
                    <TableBody>
                        {(() => {
                            const moduleRowTracker: { [key: string]: boolean } = {};
                            const subModuleRowTracker: { [key: string]: boolean } = {};
                            const topicRowTracker: { [key: string]: boolean } = {};
                            const subtopicRowTracker: { [key: string]: boolean } = {};

                            return tableRows.map((row, index) => {
                                const isFirstSubtopicInModule = !moduleRowTracker[row.moduleId];
                                const isFirstSubtopicInSubModule = !subModuleRowTracker[row.subModuleId];
                                const isFirstSubtopicInTopic = !topicRowTracker[row.topicId];
                                const isFirstSubtopicInSubtopic = !subtopicRowTracker[row.subtopicId];

                                if (isFirstSubtopicInModule) moduleRowTracker[row.moduleId] = true;
                                if (isFirstSubtopicInSubModule) subModuleRowTracker[row.subModuleId] = true;
                                if (isFirstSubtopicInTopic) topicRowTracker[row.topicId] = true;
                                if (isFirstSubtopicInSubtopic) subtopicRowTracker[row.subtopicId] = true;

                                const isModuleSelected = selectedModulesForDuplication.has(row.moduleId);

                                return (
                                    <TableRow
                                        key={`preview-${row.rowId}`}
                                        className={`hover:bg-gray-50 h-6`}
                                    >
                                        {/* Checkbox Cell - only show if module selection is enabled AND Module is in selected hierarchy */}
                                        {enableModuleSelection && selectedHierarchy.includes('Module') && isFirstSubtopicInModule && (
                                            <TableCell
                                                rowSpan={moduleSpans[row.moduleId]}
                                                className="border border-gray-400 text-center p-0.5 bg-blue-50 sticky z-20 left-0"
                                            >
                                                <div className="flex items-center justify-center">
                                                    <Checkbox
                                                        checked={isModuleSelected}
                                                        onCheckedChange={(checked) =>
                                                            handleModuleSelect(row.moduleId, checked as boolean)
                                                        }
                                                        className="h-3 border border-gray-400 w-3"
                                                    />
                                                </div>
                                            </TableCell>
                                        )}

                                        {/* Module Cell - only show if Module is in selected hierarchy */}
                                        {selectedHierarchy.includes('Module') && isFirstSubtopicInModule && (
                                            <TableCell
                                                rowSpan={moduleSpans[row.moduleId]}
                                                className="border border-gray-400 text-left text-[9px] font-medium p-0.5 bg-blue-50 text-center align-middle max-w-[80px] h-6 sticky z-10"
                                                style={{ left: `${stickyPositions['module']}px` }}
                                            >
                                                <span
                                                    className="whitespace-normal break-words px-4 text-center flex-1"
                                                    title={row.moduleName === "Default Module" ? "-" : row.moduleName}
                                                >
                                                    {row.moduleName === "Default Module" ? "-" : row.moduleName}
                                                </span>
                                            </TableCell>
                                        )}

                                        {/* SubModule Cell - only show if Sub Module is in selected hierarchy */}
                                        {selectedHierarchy.includes('Sub Module') && isFirstSubtopicInSubModule && (
                                            <TableCell
                                                rowSpan={subModuleSpans[row.subModuleId]}
                                                className="border border-gray-400 text-left p-0.5 bg-blue-50 text-[9px] font-medium text-center align-middle max-w-[80px] h-6 sticky z-10"
                                                style={{ left: `${stickyPositions['subModule']}px` }}
                                            >
                                                <span
                                                    className="whitespace-nowrap overflow-hidden text-ellipsis block px-1"
                                                    title={row.subModuleName === "Default Submodule" ? "-" : row.subModuleName}
                                                >
                                                    {row.subModuleName === "Default Submodule" ? "-" : row.subModuleName}
                                                </span>
                                            </TableCell>
                                        )}

                                        {/* Topic Cell - only show if Topic is in selected hierarchy */}
                                        {selectedHierarchy.includes("Topic") && isFirstSubtopicInTopic && (
                                            <TableCell
                                                rowSpan={topicSpans[row.topicId]}
                                                className="border border-gray-400 text-left p-0.5 bg-blue-50 text-[9px] font-medium text-center align-middle max-w-[80px] h-6 sticky z-10"
                                                style={{ left: `${stickyPositions['topic']}px` }}
                                            >
                                                <span
                                                    className="whitespace-nowrap overflow-hidden text-ellipsis block px-1"
                                                    title={row.topicName === "Default Topic" ? "-" : row.topicName}
                                                >
                                                    {row.topicName === "Default Topic" ? "-" : row.topicName}
                                                </span>
                                            </TableCell>
                                        )}

                                        {/* Subtopic Cell - only show if Sub Topic is in selected hierarchy */}
                                        {selectedHierarchy.includes("Sub Topic") && (
                                            <TableCell
                                                className="border border-gray-400 text-left p-0.5 bg-blue-50 text-[9px] font-medium text-center align-middle max-w-[80px] h-6 sticky z-10"
                                                style={{ left: `${stickyPositions['subTopic']}px` }}
                                            >
                                                <span
                                                    className="whitespace-nowrap overflow-hidden text-ellipsis block px-1"
                                                    title={row.subtopicName === "Default Subtopic" ? "-" : row.subtopicName}
                                                >
                                                    {row.subtopicName === "Default Subtopic" ? "-" : row.subtopicName}
                                                </span>
                                            </TableCell>
                                        )}
                                    </TableRow>
                                );
                            });
                        })()}
                    </TableBody>
                </Table>
            </div>
        );
    };
    const exportToExcel = async () => {
        if (!selectedCourse) return;

        // Helper functions (same as preview table)
        const getMergedActivityValue = (row: { moduleId: string; subModuleId: string; topicId: string; subtopicId: string; }, type: PedagogyType, activity: string) => {
            let hierarchyKey = '';
            let hierarchyId = '';

            if (exportSelections.hierarchy.module && row.moduleId) {
                hierarchyKey = 'moduleId';
                hierarchyId = row.moduleId;
            } else if (exportSelections.hierarchy.subModule && row.subModuleId) {
                hierarchyKey = 'subModuleId';
                hierarchyId = row.subModuleId;
            } else if (exportSelections.hierarchy.topic && row.topicId) {
                hierarchyKey = 'topicId';
                hierarchyId = row.topicId;
            } else if (exportSelections.hierarchy.subTopic && row.subtopicId) {
                hierarchyKey = 'subtopicId';
                hierarchyId = row.subtopicId;
            } else {
                // No hierarchy selected - calculate total for all rows
                return tableRows.reduce((total, r) => {
                    const mergeInfo = isCellMerged(tableRows.indexOf(r), type, activity);
                    const cellValue = mergeInfo.isMerged ? (mergeInfo.isStart ? mergeInfo.value : 0) : getCellValueForRow(r, type, activity);
                    return total + (cellValue || 0);
                }, 0);
            }

            // Calculate total for all rows with the same hierarchy ID
            const rowsInGroup = tableRows.filter(r => r[hierarchyKey] === hierarchyId);
            return rowsInGroup.reduce((total, r) => {
                const mergeInfo = isCellMerged(tableRows.indexOf(r), type, activity);
                const cellValue = mergeInfo.isMerged ? (mergeInfo.isStart ? mergeInfo.value : 0) : getCellValueForRow(r, type, activity);
                return total + (cellValue || 0);
            }, 0);
        };

        const isCellMerged = (rowIndex: number, type: string, activity: string) => {
            const columnKey = `${type}-${activity}`;
            const merges = mergedCells[columnKey] || [];
            const row = tableRows[rowIndex];

            for (const merge of merges) {
                const rowIndices = merge.rowIds
                    ?.map((rid) => tableRows.findIndex((r) => r.rowId === rid))
                    .filter((idx) => idx !== -1)
                    .sort((a, b) => a - b) || [];

                if (rowIndices.includes(rowIndex)) {
                    return {
                        isMerged: true,
                        isStart: rowIndex === rowIndices[0],
                        rowSpan: rowIndices.length,
                        value: merge.value,
                        mergeIndex: merges.indexOf(merge),
                        hierarchyIds: merge.hierarchyIds,
                        type: type
                    };
                }
            }

            return {
                isMerged: false,
                isStart: false,
                rowSpan: 1,
                value: 0,
                mergeIndex: -1,
                hierarchyIds: null,
                type: type
            };
        };

        const calculateTotalHours = (type: "iDo" | "weDo" | "youDo", activity: string) => {
            const columnKey = `${type}-${activity}`;

            // Calculate merged values
            const mergedValue = mergedCells[columnKey]?.reduce((sum, merge) => sum + merge.value, 0) || 0;

            // Calculate unmerged values
            const unmergedValue = Object.entries(courseHours).reduce((sum, [moduleId, moduleData]) => {
                return sum + Object.entries(moduleData).reduce((moduleSum, [topicId, topicData]) => {
                    return moduleSum + Object.entries(topicData).reduce((topicSum, [subtopicId, subtopicData]) => {
                        // Check if this cell is part of any merge
                        const isMerged = mergedCells[columnKey]?.some(merge => {
                            // Check hierarchy matches
                            const matchesModule = !merge.hierarchyIds?.modules.length ||
                                merge.hierarchyIds.modules.includes(moduleId);
                            const matchesSubModule = !merge.hierarchyIds?.subModules.length ||
                                (!topicData.subModuleId || merge.hierarchyIds.subModules.includes(topicData.subModuleId as any));
                            const matchesTopic = !merge.hierarchyIds?.topics.length ||
                                (!topicId || merge.hierarchyIds.topics.includes(topicId));
                            const matchesSubTopic = !merge.hierarchyIds?.subTopics.length ||
                                (!subtopicId || merge.hierarchyIds.subTopics.includes(subtopicId));

                            return matchesModule && matchesSubModule && matchesTopic && matchesSubTopic;
                        });

                        // Only add if not part of a merge and has a value
                        if (!isMerged && subtopicData[type]?.[activity]) {
                            return topicSum + (subtopicData[type][activity] || 0);
                        }
                        return topicSum;
                    }, 0);
                }, 0);
            }, 0);

            return mergedValue + unmergedValue;
        };

        const getSelectedActivities = (type: "iDo" | "weDo" | "youDo") => {
            const exportKey = type;

            return selectedPedagogyTypes.includes(type) &&
                Array.isArray(exportSelections.pedagogy[exportKey])
                ? activityTypes[type].filter(activity =>
                    Array.isArray(exportSelections.pedagogy[exportKey]) &&
                    exportSelections.pedagogy[exportKey].includes(activity)
                )
                : [];

        };

        const selectedIDoActivities = getSelectedActivities("iDo");
        const selectedWeDoActivities = getSelectedActivities("weDo");
        const selectedYouDoActivities = getSelectedActivities("youDo");

        // Calculate total hours for a row
        const calculateRowTotal = (row: any) => {
            let total = 0;

            // Calculate for each selected activity type
            selectedIDoActivities.forEach((activity: string) => {
                const mergeInfo = isCellMerged(tableRows.indexOf(row), "iDo", activity);
                const cellValue = mergeInfo.isMerged ? (mergeInfo.isStart ? mergeInfo.value : 0) : getCellValueForRow(row, "iDo", activity);
                total += cellValue || 0;
            });

            selectedWeDoActivities.forEach((activity: string) => {
                const mergeInfo = isCellMerged(tableRows.indexOf(row), "weDo", activity);
                const cellValue = mergeInfo.isMerged ? (mergeInfo.isStart ? mergeInfo.value : 0) : getCellValueForRow(row, "weDo", activity);
                total += cellValue || 0;
            });

            selectedYouDoActivities.forEach((activity: string) => {
                const mergeInfo = isCellMerged(tableRows.indexOf(row), "youDo", activity);
                const cellValue = mergeInfo.isMerged ? (mergeInfo.isStart ? mergeInfo.value : 0) : getCellValueForRow(row, "youDo", activity);
                total += cellValue || 0;
            });

            return total;
        };

        // Get cell value for a specific row and activity
        const getCellValueForRow = (row: any, type: "iDo" | "weDo" | "youDo", activity: any) => {
            // Determine effective IDs based on hierarchy
            const effectiveTopicId = row.topicId || `${row.moduleId}-default-topic`;
            const effectiveSubtopicId = row.subtopicId ||
                (row.topicId ? `${row.topicId}-default-subtopic` : `${row.moduleId}-default-subtopic`);

            // Check backend data first
            if (pedagogyViews && pedagogyViews.length > 0) {
                for (const view of pedagogyViews) {
                    for (const pedagogy of view.pedagogies) {
                        const pedagogyModules = pedagogy.module || [];
                        const pedagogySubModules = pedagogy.subModule || [];
                        const pedagogyTopics = pedagogy.topic || [];
                        const pedagogySubTopics = pedagogy.subTopic || [];

                        // Skip merged pedagogies
                        const isMultiMerge = pedagogyModules.length > 1 || pedagogySubModules.length > 1 ||
                            pedagogyTopics.length > 1 || pedagogySubTopics.length > 1;
                        if (isMultiMerge) continue;

                        // Check exact match for single cell
                        const moduleMatch = pedagogyModules.length === 0 ||
                            (pedagogyModules.length === 1 && pedagogyModules[0] === row.moduleId);
                        const subModuleMatch = pedagogySubModules.length === 0 ||
                            (pedagogySubModules.length === 1 && pedagogySubModules[0] === row.subModuleId);
                        const topicMatch = pedagogyTopics.length === 0 ||
                            (pedagogyTopics.length === 1 && pedagogyTopics[0] === row.topicId);
                        const subtopicMatch = pedagogySubTopics.length === 0 ||
                            (pedagogySubTopics.length === 1 && pedagogySubTopics[0] === row.subtopicId);

                        if (moduleMatch && subModuleMatch && topicMatch && subtopicMatch) {
                            const activityData = pedagogy[type]?.find((a) => a.type === activity);
                            if (activityData) {
                                return activityData.duration;
                            }
                        }
                    }
                }
            }

            // Fall back to frontend data
            return courseHours[row.moduleId]?.[effectiveTopicId]?.[effectiveSubtopicId]?.[type]?.[activity] || 0;
        };

        const isFirstInMergedGroup = (row: any, index: any) => {
            // Find the highest priority hierarchy level that is selected
            let hierarchyKey = '';
            let hierarchyId = '';

            // Check in order of priority - use the first selected one
            if (exportSelections.hierarchy.module && row.moduleId) {
                hierarchyKey = 'moduleId';
                hierarchyId = row.moduleId;
            } else if (exportSelections.hierarchy.subModule && row.subModuleId) {
                hierarchyKey = 'subModuleId';
                hierarchyId = row.subModuleId;
            } else if (exportSelections.hierarchy.topic && row.topicId) {
                hierarchyKey = 'topicId';
                hierarchyId = row.topicId;
            } else if (exportSelections.hierarchy.subTopic && row.subtopicId) {
                hierarchyKey = 'subtopicId';
                hierarchyId = row.subtopicId;
            } else {
                // No hierarchy selected, treat each row individually
                return index === 0; // Only show total on first row
            }

            // Check if this is the first row with this hierarchy ID
            return tableRows.findIndex(r => r[hierarchyKey] === hierarchyId) === index;
        };


        const getMergedTotalValue = (row: any) => {
            let hierarchyKey = '';
            let hierarchyId = '';

            if (exportSelections.hierarchy.module && row.moduleId) {
                hierarchyKey = 'moduleId';
                hierarchyId = row.moduleId;
            } else if (exportSelections.hierarchy.subModule && row.subModuleId) {
                hierarchyKey = 'subModuleId';
                hierarchyId = row.subModuleId;
            } else if (exportSelections.hierarchy.topic && row.topicId) {
                hierarchyKey = 'topicId';
                hierarchyId = row.topicId;
            } else if (exportSelections.hierarchy.subTopic && row.subtopicId) {
                hierarchyKey = 'subtopicId';
                hierarchyId = row.subtopicId;
            } else {
                // No hierarchy selected - calculate total for all rows
                return tableRows.reduce((total, r) => total + calculateRowTotal(r), 0);
            }

            // Calculate total for all rows with the same hierarchy ID
            const rowsInGroup = tableRows.filter(r => r[hierarchyKey] === hierarchyId);
            return rowsInGroup.reduce((total, r) => total + calculateRowTotal(r), 0);
        };




        // Filter activities based on selections (for main table)
        const filteredActivities = {
            iDo: Array.isArray(exportSelections.pedagogy.iDo) ? exportSelections.pedagogy.iDo : [],
            weDo: Array.isArray(exportSelections.pedagogy.weDo) ? exportSelections.pedagogy.weDo : [],
            youDo: Array.isArray(exportSelections.pedagogy.youDo) ? exportSelections.pedagogy.youDo : [],
        };
        // sarathi
        const summaryActivities = exportSelections.showSummary && exportSelections.printPedagogy
            ? {
                iDo: Array.isArray(exportSelections.printPedagogy.iDo) ? exportSelections.printPedagogy.iDo : [],
                weDo: Array.isArray(exportSelections.printPedagogy.weDo) ? exportSelections.printPedagogy.weDo : [],
                youDo: Array.isArray(exportSelections.printPedagogy.youDo) ? exportSelections.printPedagogy.youDo : [],
            }
            : {
                iDo: [],
                weDo: [],
                youDo: [],
            };
        // Calculate if we should show teaching elements section
        const showTeachingElements = selectedPedagogyTypes.length > 0 &&
            (filteredActivities.iDo.length > 0 || filteredActivities.weDo.length > 0 || filteredActivities.youDo.length > 0);

        // Calculate total selected activities count
        const totalSelectedActivities = filteredActivities.iDo.length + filteredActivities.weDo.length + filteredActivities.youDo.length;

        // Count visible category headers (only those with selected activities)
        const visibleCategoryCount = [
            filteredActivities.iDo.length > 0,
            filteredActivities.weDo.length > 0,
            filteredActivities.youDo.length > 0
        ].filter(Boolean).length;

        // DEFAULT BEHAVIOR: If hoursOption is empty or not set, default to 'element' (individual activities)
        const effectiveHoursOption = exportSelections.hoursOption || 'element';

        // Create a new workbook
        const workbook = new ExcelJS.Workbook();
        const worksheet = workbook.addWorksheet("Pedagogy");

        // Calculate hierarchy columns count
        const hierarchyColumns = [
            exportSelections.hierarchy.module && selectedCourse.courseHierarchy.includes('Module'),
            exportSelections.hierarchy.subModule && selectedCourse.courseHierarchy.includes('Sub Module'),
            exportSelections.hierarchy.topic && selectedCourse.courseHierarchy.includes('Topic'),
            exportSelections.hierarchy.subTopic && selectedCourse.courseHierarchy.includes('Sub Topic'),
        ].filter(Boolean).length;

        const levelColumnIncluded = exportSelections.hierarchy.level;
        const totalHierarchyColumns = hierarchyColumns + (levelColumnIncluded ? 1 : 0);

        // Add headers based on effectiveHoursOption (uses default if not set)
        const header1 = [];
        const header2 = [];
        const header3 = [];

        // Add hierarchy headers
        if (exportSelections.hierarchy.module && selectedCourse.courseHierarchy.includes('Module')) {
            header1.push('Module');
            header2.push('');
            header3.push('');
        }
        if (exportSelections.hierarchy.subModule && selectedCourse.courseHierarchy.includes('Sub Module')) {
            header1.push('Sub Module');
            header2.push('');
            header3.push('');
        }
        if (exportSelections.hierarchy.topic && selectedCourse.courseHierarchy.includes('Topic')) {
            header1.push('Topic');
            header2.push('');
            header3.push('');
        }
        if (exportSelections.hierarchy.subTopic && selectedCourse.courseHierarchy.includes('Sub Topic')) {
            header1.push('Sub Topic');
            header2.push('');
            header3.push('');
        }
        if (exportSelections.hierarchy.level) {
            header1.push('Level');
            header2.push('');
            header3.push('');
        }

        // Add teaching elements headers based on effectiveHoursOption
        if (showTeachingElements) {
            if (effectiveHoursOption === 'element') {
                // Individual activities view (DEFAULT)
                header1.push('Teaching Learning Elements');
                header1.push(...Array(totalSelectedActivities - 1).fill(''));

                // Second row - activity type headers (only if multiple types)
                if (visibleCategoryCount > 1) {
                    if (filteredActivities.iDo.length > 0) {
                        header2.push('I Do');
                        header2.push(...Array(filteredActivities.iDo.length - 1).fill(''));
                    }
                    if (filteredActivities.weDo.length > 0) {
                        header2.push('We Do');
                        header2.push(...Array(filteredActivities.weDo.length - 1).fill(''));
                    }
                    if (filteredActivities.youDo.length > 0) {
                        header2.push('You Do');
                        header2.push(...Array(filteredActivities.youDo.length - 1).fill(''));
                    }
                } else {
                    header2.push(...Array(totalSelectedActivities).fill(''));
                }

                // Third row - individual activity names
                filteredActivities.iDo.forEach((activity: any) => header3.push(activity));
                filteredActivities.weDo.forEach((activity: any) => header3.push(activity));
                filteredActivities.youDo.forEach((activity: any) => header3.push(activity));

            } else if (effectiveHoursOption === 'activity') {
                // Activity type totals view
                const activeTypes = visibleCategoryCount;

                header1.push('Teaching Learning Elements');
                header1.push(...Array(activeTypes - 1).fill(''));

                // Second row - just activity type names
                if (filteredActivities.iDo.length > 0) {
                    header2.push('I Do');
                }
                if (filteredActivities.weDo.length > 0) {
                    header2.push('We Do');
                }
                if (filteredActivities.youDo.length > 0) {
                    header2.push('You Do');
                }

                // Third row - empty for activity totals
                header3.push(...Array(activeTypes).fill(''));
            }
        }

        // Add Total Hours column if included
        if (showTeachingElements || exportSelections.includeTotalHours) {
            header1.push('Total Hours');
            header2.push('');
            header3.push('');
        }

        // Add headers to worksheet
        worksheet.addRow(header1);
        worksheet.addRow(header2);
        worksheet.addRow(header3);

        // Apply header styling and merging
        const applyHeaderStyling = () => {
            // First row styling and merging
            const headerRow1 = worksheet.getRow(1);
            headerRow1.eachCell((cell) => {
                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF4472C4' } };
                cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
                cell.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
                cell.border = {
                    top: { style: 'thin' }, left: { style: 'thin' },
                    bottom: { style: 'thin' }, right: { style: 'thin' }
                };
            });

            // Merge hierarchy columns (rows 1-3)
            let colIndex = 1;
            if (exportSelections.hierarchy.module && selectedCourse.courseHierarchy.includes('Module')) {
                worksheet.mergeCells(1, colIndex, 3, colIndex);
                colIndex++;
            }
            if (exportSelections.hierarchy.subModule && selectedCourse.courseHierarchy.includes('Sub Module')) {
                worksheet.mergeCells(1, colIndex, 3, colIndex);
                colIndex++;
            }
            if (exportSelections.hierarchy.topic && selectedCourse.courseHierarchy.includes('Topic')) {
                worksheet.mergeCells(1, colIndex, 3, colIndex);
                colIndex++;
            }
            if (exportSelections.hierarchy.subTopic && selectedCourse.courseHierarchy.includes('Sub Topic')) {
                worksheet.mergeCells(1, colIndex, 3, colIndex);
                colIndex++;
            }
            if (exportSelections.hierarchy.level) {
                worksheet.mergeCells(1, colIndex, 3, colIndex);
                colIndex++;
            }

            // Merge Teaching Learning Elements header
            if (showTeachingElements) {
                const teachingElementsSpan = effectiveHoursOption === 'activity'
                    ? visibleCategoryCount
                    : totalSelectedActivities;

                if (teachingElementsSpan > 1) {
                    worksheet.mergeCells(1, colIndex, 1, colIndex + teachingElementsSpan - 1);
                }

                // Merge activity type headers for element view
                if (effectiveHoursOption === 'element' && visibleCategoryCount > 1) {
                    if (filteredActivities.iDo.length > 1) {
                        worksheet.mergeCells(2, colIndex, 2, colIndex + filteredActivities.iDo.length - 1);
                    }
                    colIndex += filteredActivities.iDo.length;

                    if (filteredActivities.weDo.length > 1) {
                        worksheet.mergeCells(2, colIndex, 2, colIndex + filteredActivities.weDo.length - 1);
                    }
                    colIndex += filteredActivities.weDo.length;

                    if (filteredActivities.youDo.length > 1) {
                        worksheet.mergeCells(2, colIndex, 2, colIndex + filteredActivities.youDo.length - 1);
                    }
                }
            }

            // Merge Total Hours header if included
            if (showTeachingElements || exportSelections.includeTotalHours) {
                const totalHoursCol = totalHierarchyColumns + 1 + (effectiveHoursOption === 'activity' ? visibleCategoryCount : totalSelectedActivities);
                worksheet.mergeCells(1, totalHoursCol, 3, totalHoursCol);
            }

            // Second and third row styling
            [2, 3].forEach(rowNum => {
                const row = worksheet.getRow(rowNum);
                row.eachCell((cell) => {
                    if (cell.value === 'I Do' || cell.value === 'We Do' || cell.value === 'You Do') {
                        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF70AD47' } };
                    } else {
                        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF4472C4' } };
                    }
                    cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
                    cell.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
                    cell.border = {
                        top: { style: 'thin' }, left: { style: 'thin' },
                        bottom: { style: 'thin' }, right: { style: 'thin' }
                    };
                });
            });
        };

        applyHeaderStyling();


        // Add data rows with hierarchy merging logic - FIXED VERSION
        const addDataRows = () => {


            const moduleRowTracker: Record<string, boolean> = {};
            const subModuleRowTracker: Record<string, boolean> = {};
            const topicRowTracker: Record<string, boolean> = {};
            const subtopicRowTracker: Record<string, boolean> = {};


            // Track hierarchy-based merges for activities
            const hierarchyMerges = {};
            const activityMergeTracker = {};

            tableRows.forEach((row, rowIndex) => {
                const dataRow = [];

                // Add hierarchy data
                const isFirstInModule = !moduleRowTracker[row.moduleId];
                const isFirstInSubModule = !subModuleRowTracker[row.subModuleId];
                const isFirstInTopic = !topicRowTracker[row.topicId];
                const isFirstInSubtopic = !subtopicRowTracker[row.subtopicId];

                if (isFirstInModule) moduleRowTracker[row.moduleId] = true;
                if (isFirstInSubModule) subModuleRowTracker[row.subModuleId] = true;
                if (isFirstInTopic) topicRowTracker[row.topicId] = true;
                if (isFirstInSubtopic) subtopicRowTracker[row.subtopicId] = true;

                // Add hierarchy columns based on selection
                if (exportSelections.hierarchy.module && selectedCourse.courseHierarchy.includes('Module')) {
                    dataRow.push(isFirstInModule ? (row.moduleName === "Default Module" ? "-" : row.moduleName) : '');
                }
                if (exportSelections.hierarchy.subModule && selectedCourse.courseHierarchy.includes('Sub Module')) {
                    dataRow.push(isFirstInSubModule ? (row.subModuleName === "Default Submodule" ? "-" : row.subModuleName) : '');
                }
                if (exportSelections.hierarchy.topic && selectedCourse.courseHierarchy.includes('Topic')) {
                    dataRow.push(isFirstInTopic ? (row.topicName === "Default Topic" ? "-" : row.topicName) : '');
                }
                if (exportSelections.hierarchy.subTopic && selectedCourse.courseHierarchy.includes('Sub Topic')) {
                    dataRow.push(row.subtopicName === "Default Subtopic" ? "-" : row.subtopicName);
                }

                // Add level data
                if (exportSelections.hierarchy.level) {
                    const levelInfo = isLevelMerged(rowIndex);
                    if (levelInfo.isMerged && !levelInfo.isStart) {
                        dataRow.push('');
                    } else {
                        dataRow.push(levelInfo.value || '-');
                    }
                }



                // Add activity data based on effectiveHoursOption - FIXED VERSION
                if (showTeachingElements) {
                    if (effectiveHoursOption === 'element') {
                        // Individual activities view - use same logic as preview table
                        filteredActivities.iDo.forEach((activity: string) => {
                            const mergeInfo = isCellMerged(rowIndex, "iDo", activity);
                            if (mergeInfo.isMerged && !mergeInfo.isStart) {
                                dataRow.push('');
                            } else {
                                const value = mergeInfo.isMerged ? mergeInfo.value : getCellValueForRow(row, "iDo", activity);
                                dataRow.push(value || 0);
                            }
                        });

                        filteredActivities.weDo.forEach((activity: string) => {
                            const mergeInfo = isCellMerged(rowIndex, "weDo", activity);
                            if (mergeInfo.isMerged && !mergeInfo.isStart) {
                                dataRow.push('');
                            } else {
                                const value = mergeInfo.isMerged ? mergeInfo.value : getCellValueForRow(row, "weDo", activity);
                                dataRow.push(value || 0);
                            }
                        });

                        filteredActivities.youDo.forEach((activity: string) => {
                            const mergeInfo = isCellMerged(rowIndex, "youDo", activity);
                            if (mergeInfo.isMerged && !mergeInfo.isStart) {
                                dataRow.push('');
                            } else {
                                const value = mergeInfo.isMerged ? mergeInfo.value : getCellValueForRow(row, "youDo", activity);
                                dataRow.push(value || 0);
                            }
                        });

                    } else if (effectiveHoursOption === 'activity') {
                        // Activity type totals view - check if this is the first row in merged group
                        const isFirstInGroup = isFirstInMergedGroup(row, rowIndex);

                        if (filteredActivities.iDo.length > 0) {
                            if (isFirstInGroup) {
                                const total = filteredActivities.iDo.reduce((sum: any, activity: string) =>
                                    sum + getMergedActivityValue(row, "iDo", activity), 0);
                                dataRow.push(total);
                            } else {
                                dataRow.push('');
                            }
                        }

                        if (filteredActivities.weDo.length > 0) {
                            if (isFirstInGroup) {
                                const total = filteredActivities.weDo.reduce((sum: any, activity: string) =>
                                    sum + getMergedActivityValue(row, "weDo", activity), 0);
                                dataRow.push(total);
                            } else {
                                dataRow.push('');
                            }
                        }

                        if (filteredActivities.youDo.length > 0) {
                            if (isFirstInGroup) {
                                const total = filteredActivities.youDo.reduce((sum: any, activity: string) =>
                                    sum + getMergedActivityValue(row, "youDo", activity), 0);
                                dataRow.push(total);
                            } else {
                                dataRow.push('');
                            }
                        }
                    }

                    // Add total hours column if included
                    if (exportSelections.includeTotalHours) {
                        const isFirstInGroup = isFirstInMergedGroup(row, rowIndex);
                        if (isFirstInGroup) {
                            dataRow.push(getMergedTotalValue(row));
                        } else {
                            dataRow.push('');
                        }
                    }
                }

                const excelRow = worksheet.addRow(dataRow);

                // Apply styling to data rows
                excelRow.eachCell((cell, colNumber) => {
                    cell.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
                    cell.border = {
                        top: { style: 'thin' }, left: { style: 'thin' },
                        bottom: { style: 'thin' }, right: { style: 'thin' }
                    };

                    // Style hierarchy columns
                    if (colNumber <= hierarchyColumns) {
                        // cell.alignment.horizontal = 'left';
                        cell.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
                        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'eff6ff' } };
                    } else if (colNumber === hierarchyColumns + 1 && levelColumnIncluded) {
                        // Level column
                        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'eff6ff' } };
                    } else if (showTeachingElements && colNumber > totalHierarchyColumns) {
                        // Activity columns - apply colors based on activity type
                        const activityColIndex = colNumber - totalHierarchyColumns - 1;

                        if (effectiveHoursOption === 'activity') {
                            // Color based on activity type position
                            if (filteredActivities.iDo.length > 0 && activityColIndex === 0) {
                                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFFFCC' } }; // Light yellow
                            } else if (filteredActivities.weDo.length > 0 &&
                                activityColIndex === (filteredActivities.iDo.length > 0 ? 1 : 0)) {
                                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFE5CC' } }; // Light orange
                            } else if (filteredActivities.youDo.length > 0) {
                                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE6FFCC' } }; // Light green
                            }
                        } else {
                            // Individual activity colors
                            if (activityColIndex < filteredActivities.iDo.length) {
                                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFFFCC' } }; // Light yellow
                            } else if (activityColIndex < filteredActivities.iDo.length + filteredActivities.weDo.length) {
                                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFE5CC' } }; // Light orange
                            } else {
                                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE6FFCC' } }; // Light green
                            }
                        }
                    }
                });
            });
        };

        addDataRows();

        // FIXED: Process merged cells for Excel - Updated to match preview table logic
        const processMergedCells = () => {
            // const mergedRanges = [];
            const mergedRanges: any[] = [];

            // Process pedagogy merged cells for 'element' view
            if (effectiveHoursOption === 'element') {
                Object.entries(mergedCells).forEach(([columnKey, merges]) => {
                    const [type, activity] = columnKey.split('-');

                    // Check if this activity type is selected for export
                    if (!selectedPedagogyTypes.includes(type as "iDo" | "weDo" | "youDo" | "all")) return;

                    // Check if this specific activity is selected
                    const selectedActivities = exportSelections.pedagogy[type as PedagogyType];
                    if (!Array.isArray(selectedActivities) || !selectedActivities.includes(activity)) return;

                    merges.forEach(merge => {
                        const firstRowIndex = tableRows.findIndex(row => row.rowId === merge.rowIds[0]);
                        const lastRowIndex = tableRows.findIndex(row => row.rowId === merge.rowIds[merge.rowIds.length - 1]);

                        if (firstRowIndex !== -1 && lastRowIndex !== -1) {
                            // Calculate the column index for this activity
                            let activityCol = totalHierarchyColumns + 1; // Start after hierarchy columns

                            // Find the specific activity column
                            if (type === 'iDo') {
                                const activityIndex = filteredActivities.iDo.indexOf(activity);
                                if (activityIndex !== -1) {
                                    activityCol += activityIndex;
                                }
                            } else if (type === 'weDo') {
                                activityCol += filteredActivities.iDo.length;
                                const activityIndex = filteredActivities.weDo.indexOf(activity);
                                if (activityIndex !== -1) {
                                    activityCol += activityIndex;
                                }
                            } else if (type === 'youDo') {
                                activityCol += filteredActivities.iDo.length + filteredActivities.weDo.length;
                                const activityIndex = filteredActivities.youDo.indexOf(activity);
                                if (activityIndex !== -1) {
                                    activityCol += activityIndex;
                                }
                            }

                            // Add to Excel row numbers (add 4 for headers)
                            mergedRanges.push({
                                start: firstRowIndex + 4,
                                end: lastRowIndex + 4,
                                col: activityCol
                            });
                        }
                    });
                });
            }

            // Process hierarchy-based merges for 'activity' view and total hours
            if (effectiveHoursOption === 'activity' || exportSelections.includeTotalHours) {
                // Group rows by hierarchy
                // const hierarchyGroups = {};
                const hierarchyGroups: Record<string, number[]> = {};

                tableRows.forEach((row, index) => {
                    let hierarchyKey = '';
                    let hierarchyId = '';

                    // Determine hierarchy key/id (same logic as isFirstInMergedGroup)
                    if (exportSelections.hierarchy.module && row.moduleId) {
                        hierarchyKey = 'moduleId';
                        hierarchyId = row.moduleId;
                    } else if (exportSelections.hierarchy.subModule && row.subModuleId) {
                        hierarchyKey = 'subModuleId';
                        hierarchyId = row.subModuleId;
                    } else if (exportSelections.hierarchy.topic && row.topicId) {
                        hierarchyKey = 'topicId';
                        hierarchyId = row.topicId;
                    } else if (exportSelections.hierarchy.subTopic && row.subtopicId) {
                        hierarchyKey = 'subtopicId';
                        hierarchyId = row.subtopicId;
                    } else {
                        hierarchyKey = 'all';
                        hierarchyId = 'all';
                    }

                    const groupKey = `${hierarchyKey}-${hierarchyId}`;
                    if (!hierarchyGroups[groupKey]) {
                        hierarchyGroups[groupKey] = [];
                    }
                    hierarchyGroups[groupKey].push(index);
                });

                // Create merges for each hierarchy group
                Object.values(hierarchyGroups).forEach(rowIndices => {
                    if (rowIndices.length > 1) {
                        const startRow = Math.min(...rowIndices) + 4; // +4 for headers
                        const endRow = Math.max(...rowIndices) + 4;

                        if (effectiveHoursOption === 'activity') {
                            // Merge activity type columns
                            let colIndex = totalHierarchyColumns + 1;

                            if (filteredActivities.iDo.length > 0) {
                                mergedRanges.push({ start: startRow, end: endRow, col: colIndex });
                                colIndex++;
                            }
                            if (filteredActivities.weDo.length > 0) {
                                mergedRanges.push({ start: startRow, end: endRow, col: colIndex });
                                colIndex++;
                            }
                            if (filteredActivities.youDo.length > 0) {
                                mergedRanges.push({ start: startRow, end: endRow, col: colIndex });
                                colIndex++;
                            }
                        }

                        // Merge total hours column if included
                        if (exportSelections.includeTotalHours) {
                            const totalHoursCol = totalHierarchyColumns + 1 +
                                (effectiveHoursOption === 'activity' ? visibleCategoryCount : totalSelectedActivities);
                            mergedRanges.push({ start: startRow, end: endRow, col: totalHoursCol });
                        }
                    }
                });
            }

            // Process hierarchy merges (existing code for Module, Sub Module, Topic)
            const processHierarchyMerges = () => {
                const hierarchyMerges: HierarchyMerges = { module: {}, subModule: {}, topic: {} };

                tableRows.forEach((row, rowIndex) => {
                    if (!hierarchyMerges.module[row.moduleId]) {
                        hierarchyMerges.module[row.moduleId] = { startRow: rowIndex + 4, endRow: rowIndex + 4 };
                    } else {
                        hierarchyMerges.module[row.moduleId].endRow = rowIndex + 4;
                    }

                    if (row.subModuleId && !hierarchyMerges.subModule[row.subModuleId]) {
                        hierarchyMerges.subModule[row.subModuleId] = { startRow: rowIndex + 4, endRow: rowIndex + 4 };
                    } else if (row.subModuleId) {
                        hierarchyMerges.subModule[row.subModuleId].endRow = rowIndex + 4;
                    }

                    if (row.topicId && !hierarchyMerges.topic[row.topicId]) {
                        hierarchyMerges.topic[row.topicId] = { startRow: rowIndex + 4, endRow: rowIndex + 4 };
                    } else if (row.topicId) {
                        hierarchyMerges.topic[row.topicId].endRow = rowIndex + 4;
                    }
                });

                let colIndex = 1;
                if (exportSelections.hierarchy.module && selectedCourse?.courseHierarchy.includes('Module')) {
                    Object.values(hierarchyMerges.module).forEach(({ startRow, endRow }) => {
                        if (endRow > startRow) {
                            mergedRanges.push({ start: startRow, end: endRow, col: colIndex });
                        }
                    });
                    colIndex++;
                }

                if (exportSelections.hierarchy.subModule && selectedCourse?.courseHierarchy.includes('Sub Module')) {
                    Object.values(hierarchyMerges.subModule).forEach(({ startRow, endRow }) => {
                        if (endRow > startRow) {
                            mergedRanges.push({ start: startRow, end: endRow, col: colIndex });
                        }
                    });
                    colIndex++;
                }

                if (exportSelections.hierarchy.topic && selectedCourse?.courseHierarchy.includes('Topic')) {
                    Object.values(hierarchyMerges.topic).forEach(({ startRow, endRow }) => {
                        if (endRow > startRow) {
                            mergedRanges.push({ start: startRow, end: endRow, col: colIndex });
                        }
                    });
                }

                // Process level merges if level column is included
                if (exportSelections.hierarchy.level) {
                    const levelCol = totalHierarchyColumns; // Level is the last hierarchy column

                    // Check for level merges in mergedCells object
                    Object.entries(mergedCells).forEach(([columnKey, merges]) => {
                        if (columnKey === 'level' || columnKey.includes('level')) {
                            merges.forEach(merge => {
                                if (merge.rowIds && merge.rowIds.length > 1) {
                                    const rowIndices = merge.rowIds
                                        .map(rowId => tableRows.findIndex(row => row.rowId === rowId))
                                        .filter(idx => idx !== -1)
                                        .sort((a, b) => a - b);

                                    if (rowIndices.length > 1) {
                                        mergedRanges.push({
                                            start: rowIndices[0] + 4, // +4 for headers
                                            end: rowIndices[rowIndices.length - 1] + 4,
                                            col: levelCol
                                        });
                                    }
                                }
                            });
                        }
                    });

                    // Also check for level merges using the isLevelMerged function pattern
                    const levelMergeGroups: Record<string, number[]> = {};
                    tableRows.forEach((row, index) => {
                        const levelInfo = isLevelMerged(index);
                        if (levelInfo.isMerged) {
                            const mergeKey = `${levelInfo.value}-${levelInfo.mergeIndex}`;
                            if (!levelMergeGroups[mergeKey]) {
                                levelMergeGroups[mergeKey] = [];
                            }
                            levelMergeGroups[mergeKey].push(index);
                        }
                    });

                    // Process level merge groups
                    Object.values(levelMergeGroups).forEach(rowIndices => {
                        if (rowIndices.length > 1) {
                            const sortedIndices = rowIndices.sort((a, b) => a - b);
                            mergedRanges.push({
                                start: sortedIndices[0] + 4,
                                end: sortedIndices[sortedIndices.length - 1] + 4,
                                col: levelCol
                            });
                        }
                    });
                }
            };

            processHierarchyMerges();
            return mergedRanges;
        };

        const mergedRanges = processMergedCells();
        mergedRanges.forEach(({ start, end, col }) => {
            try {
                worksheet.mergeCells(start, col, end, col);

                // Center the value in merged cells
                const cell = worksheet.getCell(start, col);
                cell.alignment = cell.alignment || {};
                cell.alignment.vertical = 'middle';
                cell.alignment.horizontal = 'center';
            } catch (error) {
                console.warn('Failed to merge cells:', error);
            }
        });

        // Add Total Hours Row
        if (showTeachingElements) {
            const totalRow = [];

            // Add hierarchy columns
            totalRow.push(...Array(hierarchyColumns).fill(''));

            if (exportSelections.hierarchy.level) {
                totalRow.push('Total Hours');
            } else if (hierarchyColumns > 0) {
                totalRow[totalRow.length - 1] = 'Total Hours';
            } else {
                totalRow.push('Total Hours');
            }

            // Add activity totals based on effectiveHoursOption
            if (effectiveHoursOption === 'element') {
                // Individual activity totals (DEFAULT)
                filteredActivities.iDo.forEach((activity: string) => {
                    totalRow.push(calculateTotalHours("iDo", activity));
                });
                filteredActivities.weDo.forEach((activity: string) => {
                    totalRow.push(calculateTotalHours("weDo", activity));
                });
                filteredActivities.youDo.forEach((activity: string) => {
                    totalRow.push(calculateTotalHours("youDo", activity));
                });
            } else if (effectiveHoursOption === 'activity') {
                // Activity type totals
                if (filteredActivities.iDo.length > 0) {
                    const iDoTotal = filteredActivities.iDo.reduce((sum: number, activity: string) =>
                        sum + calculateTotalHours("iDo", activity), 0);
                    totalRow.push(iDoTotal);
                }
                if (filteredActivities.weDo.length > 0) {
                    const weDoTotal = filteredActivities.weDo.reduce((sum: number, activity: string) =>
                        sum + calculateTotalHours("weDo", activity), 0);
                    totalRow.push(weDoTotal);
                }
                if (filteredActivities.youDo.length > 0) {
                    const youDoTotal = filteredActivities.youDo.reduce((sum: number, activity: string) =>
                        sum + calculateTotalHours("youDo", activity), 0);
                    totalRow.push(youDoTotal);
                }
            }

            // Add grand total if includeTotalHours is enabled
            if (exportSelections.includeTotalHours) {
                const grandTotal =
                    filteredActivities.iDo.reduce((sum: number, activity: string) => sum + calculateTotalHours("iDo", activity), 0) +
                    filteredActivities.weDo.reduce((sum: number, activity: string) => sum + calculateTotalHours("weDo", activity), 0) +
                    filteredActivities.youDo.reduce((sum: number, activity: string) => sum + calculateTotalHours("youDo", activity), 0);
                totalRow.push(grandTotal);
            }

            const totalExcelRow = worksheet.addRow(totalRow);

            // Style total row
            totalExcelRow.eachCell((cell) => {
                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFE699' } };
                cell.font = { bold: true };
                cell.alignment = { vertical: 'middle', horizontal: 'center' };
                cell.border = {
                    top: { style: 'medium' }, bottom: { style: 'medium' },
                    left: { style: 'thin' }, right: { style: 'thin' }
                };
            });

            // Left-align the "Total Hours" label
            const labelColNumber = hierarchyColumns + (exportSelections.hierarchy.level ? 1 : 0);
            if (labelColNumber > 0) {
                totalExcelRow.getCell(labelColNumber).alignment = {
                    vertical: 'middle', horizontal: 'center'
                };
            }
        }

        // Add Summary Section (rest of the code remains the same)
        // sarathi
        if (exportSelections.showSummary && exportSelections.printPedagogy) {
            // Add empty row before summary
            worksheet.addRow([]);

            // Calculate total columns for centering
            const totalColumns = totalHierarchyColumns +
                (effectiveHoursOption === 'activity' ? visibleCategoryCount : totalSelectedActivities) +
                (exportSelections.includeTotalHours ? 1 : 0);

            const summaryStartCol = Math.floor((totalColumns - 3) / 2) + 1;

            // Set column widths for summary
            worksheet.getColumn(summaryStartCol).width = 20;
            worksheet.getColumn(summaryStartCol + 1).width = 25;
            worksheet.getColumn(summaryStartCol + 2).width = 15;

            // Add summary header
            const summaryHeaderRow = worksheet.addRow([]);
            summaryHeaderRow.getCell(summaryStartCol).value = 'Teaching Elements Summary';

            // Style and merge header
            for (let col = summaryStartCol; col <= summaryStartCol + 2; col++) {
                const cell = summaryHeaderRow.getCell(col);
                cell.font = { bold: true, size: 14, color: { argb: 'FFFFFFFF' } };
                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF4472C4' } };
                cell.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
                cell.border = {
                    top: { style: 'thin' }, left: { style: 'thin' },
                    bottom: { style: 'thin' }, right: { style: 'thin' }
                };
            }

            worksheet.mergeCells(summaryHeaderRow.number, summaryStartCol, summaryHeaderRow.number, summaryStartCol + 2);

            // Add column headers
            const summaryColumns = worksheet.addRow([]);
            const columnHeaders = ['Activity Type', 'Elements', 'Hours'];

            columnHeaders.forEach((header, index) => {
                const cell = summaryColumns.getCell(summaryStartCol + index);
                cell.value = header;
                cell.font = { bold: true, color: { argb: 'FFFFFFFF' } };
                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF70AD47' } };
                cell.border = {
                    top: { style: 'thin' }, left: { style: 'thin' },
                    bottom: { style: 'thin' }, right: { style: 'thin' }
                };
                cell.alignment = { vertical: 'middle', horizontal: 'center', wrapText: true };
            });

            // Add activity sections
            const addActivitySection = (activityType: PedagogyType, backgroundColor: string) => {
                const activities = summaryActivities[activityType];
                if (!activities || activities.length === 0) return;

                const displayName = activityType === 'iDo' ? 'I Do' : activityType === 'weDo' ? 'We Do' : 'You Do';
                const sectionStartRow = worksheet.rowCount + 1;

                activities.forEach((activity: any, index: any) => {
                    const activityRow = worksheet.addRow([]);

                    if (index === 0) {
                        activityRow.getCell(summaryStartCol).value = displayName;
                    }

                    activityRow.getCell(summaryStartCol + 1).value = activity;
                    const total = calculateTotalHours(activityType, activity);
                    activityRow.getCell(summaryStartCol + 2).value = total;

                    // Style cells
                    for (let col = summaryStartCol; col <= summaryStartCol + 2; col++) {
                        const cell = activityRow.getCell(col);
                        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: backgroundColor } };
                        cell.border = {
                            top: { style: 'thin' }, left: { style: 'thin' },
                            bottom: { style: 'thin' }, right: { style: 'thin' }
                        };
                        cell.alignment = {
                            vertical: 'middle',
                            horizontal: 'center',
                            wrapText: false
                        };

                        if (col === summaryStartCol && index === 0) {
                            cell.font = { bold: true };
                        }
                    }
                });

                // Merge activity type column
                if (activities.length > 1) {
                    const sectionEndRow = worksheet.rowCount;
                    try {
                        worksheet.mergeCells(sectionStartRow, summaryStartCol, sectionEndRow, summaryStartCol);
                    } catch (error) {
                        console.warn('Failed to merge activity section cells:', error);
                    }
                }
            };

            // Add sections for each activity type
            if (summaryActivities.iDo.length > 0) {
                addActivitySection("iDo", "FFFFFFCC"); // Light yellow
            }
            if (summaryActivities.weDo.length > 0) {
                addActivitySection("weDo", "FFFFE5CC"); // Light orange
            }
            if (summaryActivities.youDo.length > 0) {
                addActivitySection("youDo", "FFE6FFCC"); // Light green
            }

            // Add Grand Total row
            const grandTotalRow = worksheet.addRow([]);
            grandTotalRow.getCell(summaryStartCol).value = 'Total Hours';

            const grandTotal = Object.entries(summaryActivities).reduce((sum, [type, activities]) => {
                return sum + (activities || []).reduce((typeSum: any, activity: any) => {
                    return typeSum + calculateTotalHours(type as PedagogyType, activity);
                }, 0);
            }, 0);

            grandTotalRow.getCell(summaryStartCol + 2).value = grandTotal;

            // Style grand total row
            for (let col = summaryStartCol; col <= summaryStartCol + 2; col++) {
                const cell = grandTotalRow.getCell(col);
                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFE699' } };
                cell.font = { bold: true, color: { argb: 'FF000000' } };
                cell.border = {
                    top: { style: 'medium' }, bottom: { style: 'medium' },
                    left: { style: 'thin' }, right: { style: 'thin' }
                };
                cell.alignment = {
                    vertical: 'middle',
                    horizontal: 'center',
                    wrapText: true
                };
            }

            // Merge first two cells of grand total row
            worksheet.mergeCells(grandTotalRow.number, summaryStartCol, grandTotalRow.number, summaryStartCol + 1);
        }

        // Set column widths
        let colIndex = 1;
        if (exportSelections.hierarchy.module && selectedCourse.courseHierarchy.includes('Module')) {
            worksheet.getColumn(colIndex).width = 25;
            colIndex++;
        }
        if (exportSelections.hierarchy.subModule && selectedCourse.courseHierarchy.includes('Sub Module')) {
            worksheet.getColumn(colIndex).width = 25;
            colIndex++;
        }
        if (exportSelections.hierarchy.topic && selectedCourse.courseHierarchy.includes('Topic')) {
            worksheet.getColumn(colIndex).width = 25;
            colIndex++;
        }
        if (exportSelections.hierarchy.subTopic && selectedCourse.courseHierarchy.includes('Sub Topic')) {
            worksheet.getColumn(colIndex).width = 25;
            colIndex++;
        }
        if (exportSelections.hierarchy.level) {
            worksheet.getColumn(colIndex).width = 12;
            colIndex++;
        }

        // Set activity column widths
        const totalActivityCols = effectiveHoursOption === 'activity' ? visibleCategoryCount : totalSelectedActivities;
        for (let i = 0; i < totalActivityCols; i++) {
            worksheet.getColumn(colIndex).width = 20;
            colIndex++;
        }

        // Set total hours column width
        if (exportSelections.includeTotalHours) {
            worksheet.getColumn(colIndex).width = 15;
        }

        // Set row heights
        worksheet.getRow(1).height = 30;
        worksheet.getRow(2).height = 25;
        worksheet.getRow(3).height = 25;

        for (let i = 4; i <= worksheet.rowCount; i++) {
            worksheet.getRow(i).height = 20;
        }

        // Generate and save Excel file
        const buffer = await workbook.xlsx.writeBuffer();
        const blob = new Blob([buffer], {
            type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
        });

        saveAs(blob, `${selectedCourse.courseName.replace(/[^a-z0-9]/gi, '_')}_pedagogy_${new Date().toISOString().slice(0, 10)}.xlsx`);

        // Reset export selections
        setExportSelections({
            printPedagogy: null,
            hierarchy: {
                module: true,
                subModule: true,
                topic: true,
                subTopic: true,
                level: true
            },
            pedagogy: {
                iDo: selectedPedagogyTypes.includes("iDo") ? activityTypes["iDo"] : [],
                weDo: selectedPedagogyTypes.includes("weDo") ? activityTypes["weDo"] : [],
                youDo: selectedPedagogyTypes.includes("youDo") ? activityTypes["youDo"] : [],
            },
            showSummary: false,
            includeTotalHours: false,
            hoursOption: ''
        });
        setShowPreviewDialog(false);
    };

    const deletePedagogyMerges = async (hierarchyIds: {
        modules?: string[],
        subModules?: string[],
        topics?: string[],
        subTopics?: string[]
    }) => {
        if (!pedagogyViews?.[0] || !token) return;

        try {
            // Filter out pedagogies that match any of the hierarchy IDs
            const updatedPedagogies = pedagogyViews[0].pedagogies.filter(pedagogy => {
                const moduleMatch = hierarchyIds.modules && pedagogy.module?.some(m => hierarchyIds.modules?.includes(m));
                const subModuleMatch = hierarchyIds.subModules && pedagogy.subModule?.some(sm => hierarchyIds.subModules?.includes(sm));
                const topicMatch = hierarchyIds.topics && pedagogy.topic?.some(t => hierarchyIds.topics?.includes(t));
                const subTopicMatch = hierarchyIds.subTopics && pedagogy.subTopic?.some(st => hierarchyIds.subTopics?.includes(st));

                // Keep if doesn't match any of the hierarchy IDs
                return !(moduleMatch || subModuleMatch || topicMatch || subTopicMatch);
            });

            // Update backend if changes were made
            if (updatedPedagogies.length !== pedagogyViews[0].pedagogies.length) {
                await pedagogyMutation.mutateAsync({
                    courses: selectedCourse?._id || '',
                    pedagogies: updatedPedagogies
                });
                queryClient.invalidateQueries({ queryKey: ['pedagogyViews'] });
            }
        } catch (error) {
            console.error("Failed to delete pedagogy merges:", error);
            throw error;
        }
    };

    const confirmCellDelete = async () => {
        if (!cellToDelete) return;

        const { moduleId, topicId, subtopicId, subModuleId, type, activity } = cellToDelete;
        setIsPedagogyDeleteConfirm(true);
        try {


            // Find the pedagogy item to delete
            const pedagogyToUpdate = pedagogyViews?.[0];
            if (!pedagogyToUpdate) {
                throw new Error("Pedagogy data not found");
            }

            // Find the matching pedagogy item
            const matchingPedagogy = pedagogyToUpdate.pedagogies.find(p => {
                const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];

                // Determine effective IDs based on hierarchy
                const effectiveSubtopicId = hierarchyLevels.includes('sub topic')
                    ? subtopicId
                    : hierarchyLevels.includes('topic')
                        ? `${topicId}-default-subtopic`
                        : `${moduleId}-default-subtopic`;

                const effectiveTopicId = hierarchyLevels.includes('topic')
                    ? topicId
                    : `${moduleId}-default-topic`;

                // Check if this pedagogy matches the hierarchy
                const matchesModule = !p.module?.length || p.module.includes(moduleId);
                const matchesSubModule = !p.subModule?.length ||
                    (hierarchyLevels.includes('sub module') && p.subModule.includes(subModuleId));
                const matchesTopic = !p.topic?.length ||
                    (!topicId || p.topic.includes(effectiveTopicId));
                const matchesSubTopic = !p.subTopic?.length ||
                    (!subtopicId || p.subTopic.includes(effectiveSubtopicId));

                // Check if it matches the activity type
                const matchesType =
                    (type === "iDo" && p.iDo.some(i => i.type === activity)) ||
                    (type === "weDo" && p.weDo.some(w => w.type === activity)) ||
                    (type === "youDo" && p.youDo.some(y => y.type === activity));

                return matchesModule && matchesSubModule && matchesTopic && matchesSubTopic && matchesType;
            });

            if (matchingPedagogy) {
                // Find the specific activity to delete
                let activityToDelete;

                if (type === "iDo") {
                    activityToDelete = matchingPedagogy.iDo.find(i => i.type === activity);
                } else if (type === "weDo") {
                    activityToDelete = matchingPedagogy.weDo.find(w => w.type === activity);
                } else {
                    activityToDelete = matchingPedagogy.youDo.find(y => y.type === activity);
                }

                if (activityToDelete && activityToDelete._id) {
                    // Call the delete API
                    await deletePedagogyMutation.mutateAsync({
                        activityType: type,
                        itemId: activityToDelete._id
                    });
                    queryClient.invalidateQueries({ queryKey: ['pedagogyViews'] });
                    // Update local state after successful deletion
                    setCourseHours(prev => ({
                        ...prev,
                        [moduleId]: {
                            ...prev[moduleId],
                            [topicId]: {
                                ...prev[moduleId]?.[topicId],
                                [subtopicId]: {
                                    ...prev[moduleId]?.[topicId]?.[subtopicId],
                                    [type]: {
                                        ...prev[moduleId]?.[topicId]?.[subtopicId]?.[type],
                                        [activity]: 0
                                    }
                                }
                            }
                        }
                    }));
                }
            }
            setShowSuccessMessage(true);
        } catch (error) {
            console.error("Error deleting cell value:", error);
            setErrorMessage(error instanceof Error ? error.message : "Failed to delete cell value");
            setShowErrorDialog(true);
        } finally {
            setShowDeleteCellDialog(false);
            setIsPedagogyDeleteConfirm(false);
            setCellToDelete(null);
        }
    };

    const isCellMovable = (type: string, id: string) => {
        return movableCell?.type === type && movableCell?.id === id;
    };
    const getTargetParentId = (targetId: string, type: string) => {
        switch (type) {
            case 'submodule':
                const subModule = subModules.find(sm => sm._id === targetId);
                return subModule?.moduleId;
            case 'topic':
                const topic = topics.find(t => t._id === targetId);
                const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];
                const hasSubModules = hierarchyLevels.includes('sub module');
                return hasSubModules ? topic?.subModuleId : topic?.moduleId;
            case 'subtopic':
                const subtopic = subTopics.find(st => st._id === targetId);
                return subtopic?.topicId;
            default:
                return null;
        }
    };
    // Module drag handlers
    const handleModuleDragStart = (e: React.DragEvent, moduleId: string) => {

        if (!isCellMovable('module', moduleId)) {
            e.preventDefault();
            return;
        }

        e.dataTransfer.setData('text/plain', moduleId);
        setDraggingModuleId(moduleId);
        e.dataTransfer.effectAllowed = 'move';

    };
    const handleModuleDragEnd = () => {
        setDraggingModuleId(null);
        setDragOverId(null);
        setMovableCell(null);
        setIsMoveModeActive(false);
    };
    const handleModuleDrop = async (e: React.DragEvent, targetModuleId: string) => {
        e.preventDefault();
        const draggedModuleId = e.dataTransfer.getData('text/plain');
        setDraggingModuleId(null);
        setDragOverId(null);

        if (draggedModuleId === targetModuleId || !token || !selectedCourse) return;

        try {
            // 1. Optimistically update local state first for instant UI response
            const currentModules = [...modules];
            const draggedModule = currentModules.find(m => m._id === draggedModuleId);
            const targetModule = currentModules.find(m => m._id === targetModuleId);

            if (!draggedModule || !targetModule) return;

            // Create new array with updated order
            const reorderedModules = [...modules];
            const draggedIndex = reorderedModules.findIndex(m => m._id === draggedModuleId);
            const targetIndex = reorderedModules.findIndex(m => m._id === targetModuleId);

            // Remove dragged module and insert at target position
            const [removed] = reorderedModules.splice(draggedIndex, 1);
            reorderedModules.splice(targetIndex, 0, removed);

            // Update indexes for all modules
            const updatedModules = reorderedModules.map((module, index) => ({
                ...module,
                index: index
            }));

            // Immediately update state for instant UI update
            // setModules(updatedModules);

            // 2. Clear any merged cells/pedagogy data containing this module
            const updatedMergedCells = { ...mergedCells };
            Object.keys(updatedMergedCells).forEach(key => {
                updatedMergedCells[key] = updatedMergedCells[key].filter(merge =>
                    !merge.hierarchyIds?.modules.includes(draggedModuleId)
                );
            });
            setMergedCells(updatedMergedCells);

            const updatedMergedLevels = mergedLevels.filter(merge =>
                !merge.hierarchyIds.modules.includes(draggedModuleId)
            );
            setMergedLevels(updatedMergedLevels);

            // 3. Delete backend pedagogy data for this module
            const pedagogyToUpdate = pedagogyViews?.[0];
            if (pedagogyToUpdate) {
                const pedagogiesToDelete = pedagogyToUpdate.pedagogies.filter(pedagogy =>
                    pedagogy.module?.includes(draggedModuleId)
                );

                // Delete each pedagogy from backend
                for (const pedagogy of pedagogiesToDelete) {
                    // Delete I Do activities
                    for (const activity of pedagogy.iDo) {
                        await deletePedagogyMutation.mutateAsync({
                            activityType: "iDo",
                            itemId: activity._id
                        });
                    }
                    // Delete We Do activities
                    for (const activity of pedagogy.weDo) {
                        await deletePedagogyMutation.mutateAsync({
                            activityType: "weDo",
                            itemId: activity._id
                        });
                    }
                    // Delete You Do activities
                    for (const activity of pedagogy.youDo) {
                        await deletePedagogyMutation.mutateAsync({
                            activityType: "youDo",
                            itemId: activity._id
                        });
                    }
                }
            }

            // 4. Delete level data from backend for this module
            if (levelViewId) {
                const levelsToDelete = levelsData.filter((level: { module: string | string[]; }) =>
                    level.module?.includes(draggedModuleId)
                );

                for (const level of levelsToDelete) {
                    if (level._id) {
                        await deleteLevelMutation.mutateAsync(level._id);
                    }
                }


            }
            queryClient.setQueryData(moduleApi.getAll().queryKey, updatedModules);
            // 5. Update module order in backend
            const updates = updatedModules.map(module =>
                updateModuleMutation.mutateAsync({
                    id: module._id,
                    data: {
                        title: module.title,
                        description: module.description,
                        level: module.level,
                        courses: module.courses,
                        index: module.index,
                        duration: module.duration
                    }
                })
            );


            await Promise.all(updates);

            // 6. Refresh queries to ensure consistency
            queryClient.invalidateQueries({ queryKey: ['pedagogyViews'] });
            queryClient.invalidateQueries({ queryKey: ['levelViews'] });

            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 2000);

        } catch (error) {
            console.error("Failed to reorder modules:", error);

            // Rollback on error - refetch original data
            try {
                refetchModules();


            } catch (fetchError) {
                console.error("Failed to rollback:", fetchError);
            }

            setErrorMessage(error instanceof Error ? error.message : "Failed to reorder modules");
            setShowErrorDialog(true);
        }
    };
    // SubModule drag handlers
    const handleSubModuleDragStart = (e: React.DragEvent, subModuleId: string) => {
        if (!isCellMovable('submodule', subModuleId)) {
            e.preventDefault();
            return;
        }

        const subModule = subModules.find(sm => sm._id === subModuleId);
        e.dataTransfer.setData('application/json', JSON.stringify({
            id: subModuleId,
            type: 'submodule',
            currentIndex: subModule?.index || 0,
            currentParent: subModule?.moduleId // Current parent module
        }));
        setDraggingSubModuleId(subModuleId);
        e.dataTransfer.effectAllowed = 'move';
    };
    const handleSubModuleDragEnd = () => {
        setDraggingSubModuleId(null);
        setDragOverId(null);
        setMovableCell(null);
        setIsMoveModeActive(false);
    };
    const handleSubModuleDrop = async (e: React.DragEvent, targetSubModuleId: string) => {
        e.preventDefault();
        const dragData = JSON.parse(e.dataTransfer.getData('application/json'));
        const draggedSubModuleId = dragData.id;
        setDraggingSubModuleId(null);
        setDragOverId(null);

        if (!token || !selectedCourse) return;

        try {
            // 1. Optimistically update local state first (like handleModuleDrop)
            const currentSubModules = [...subModules];
            const draggedSubModule = subModules.find(sm => sm._id === draggedSubModuleId);
            const targetSubModule = subModules?.find(sm => sm._id === targetSubModuleId);
            const targetParentId = targetSubModule?.moduleId;
            if (!draggedSubModule) return;
            const isChangingModule = draggedSubModule.moduleId !== targetParentId;
            const isDroppingOnEmptyCell = targetSubModuleId.includes('placeholder') || targetSubModuleId.includes('none') || targetSubModuleId.includes('default');

            if (isDroppingOnEmptyCell) {
                // For empty cells, we need to find the parent module
                const moduleId = targetSubModuleId.split('-')[0]; // Extract module ID from empty cell ID

                if (!moduleId) {
                    setErrorMessage("Cannot determine parent module for this empty cell");
                    setShowErrorDialog(true);
                    return;
                }

                const targetModule = modules.find(m => m._id === moduleId);
                if (!targetModule) {
                    setErrorMessage("Parent module not found for this empty cell");
                    setShowErrorDialog(true);
                    return;
                }

                // Get all submodules in the target module to calculate new index
                const targetModuleSubModules = subModules
                    .filter(sm => sm.moduleId === moduleId)
                    .sort((a, b) => (a.index || 0) - (b.index || 0));

                const newIndex = targetModuleSubModules.length > 0
                    ? Math.max(...targetModuleSubModules.map(sm => sm.index || 0)) + 1
                    : 0;

                const updatedSubModule = {
                    ...draggedSubModule,
                    moduleId: moduleId,
                    index: newIndex
                };

                // Update backend
                await updateSubModuleMutation.mutateAsync({
                    id: draggedSubModuleId,
                    data: updatedSubModule
                });

                // Clean up pedagogy and level data (same as before)
                // ... (rest of the cleanup code)
                const updatedMergedCells = { ...mergedCells };
                Object.keys(updatedMergedCells).forEach(key => {
                    updatedMergedCells[key] = updatedMergedCells[key].filter(merge =>
                        !merge.hierarchyIds?.subModules.includes(draggedSubModuleId)
                    );
                });
                setMergedCells(updatedMergedCells);

                const updatedMergedLevels = mergedLevels.filter(merge =>
                    !merge.hierarchyIds.subModules.includes(draggedSubModuleId)
                );
                setMergedLevels(updatedMergedLevels);

                // Delete backend pedagogy data
                const pedagogyToUpdate = pedagogyViews?.[0];
                if (pedagogyToUpdate) {
                    const pedagogiesToDelete = pedagogyToUpdate.pedagogies.filter(pedagogy =>
                        pedagogy.subModule?.includes(draggedSubModuleId)
                    );

                    for (const pedagogy of pedagogiesToDelete) {
                        for (const activity of pedagogy.iDo) {
                            await deletePedagogyMutation.mutateAsync({
                                activityType: "iDo",
                                itemId: activity._id
                            });
                        }
                        for (const activity of pedagogy.weDo) {
                            await deletePedagogyMutation.mutateAsync({
                                activityType: "weDo",
                                itemId: activity._id
                            });
                        }
                        for (const activity of pedagogy.youDo) {
                            await deletePedagogyMutation.mutateAsync({
                                activityType: "youDo",
                                itemId: activity._id
                            });
                        }
                    }
                }

                // Delete level data from backend
                if (levelViewId) {
                    const levelsToDelete = levelsData.filter((level: { subModule: string | string[]; }) =>
                        level.subModule?.includes(draggedSubModuleId)
                    );

                    for (const level of levelsToDelete) {
                        if (level._id) {
                            await deleteLevelMutation.mutateAsync(level._id);
                        }
                    }
                }

                // Refresh data
                await refetchSubModules();

            } else {
                if (isChangingModule) {
                    // Moving to a different module - update the moduleId

                    // Get all submodules in the target module to calculate new index
                    const targetModuleSubModules = subModules
                        .filter(sm => sm.moduleId === targetParentId)
                        .sort((a, b) => (a.index || 0) - (b.index || 0));

                    const newIndex = targetModuleSubModules.length > 0
                        ? Math.max(...targetModuleSubModules.map(sm => sm.index || 0)) + 1
                        : 0;

                    const updatedSubModule = {
                        ...draggedSubModule,
                        moduleId: targetParentId,
                        index: newIndex
                    };

                    // Update backend
                    await updateSubModuleMutation.mutateAsync({
                        id: draggedSubModuleId,
                        data: updatedSubModule
                    });

                    // Clean up pedagogy and level data for the moved submodule
                    // (Same cleanup as in your original same-parent logic)
                    const updatedMergedCells = { ...mergedCells };
                    Object.keys(updatedMergedCells).forEach(key => {
                        updatedMergedCells[key] = updatedMergedCells[key].filter(merge =>
                            !merge.hierarchyIds?.subModules.includes(draggedSubModuleId)
                        );
                    });
                    setMergedCells(updatedMergedCells);

                    const updatedMergedLevels = mergedLevels.filter(merge =>
                        !merge.hierarchyIds.subModules.includes(draggedSubModuleId)
                    );
                    setMergedLevels(updatedMergedLevels);

                    // Delete backend pedagogy data
                    const pedagogyToUpdate = pedagogyViews?.[0];
                    if (pedagogyToUpdate) {
                        const pedagogiesToDelete = pedagogyToUpdate.pedagogies.filter(pedagogy =>
                            pedagogy.subModule?.includes(draggedSubModuleId)
                        );

                        for (const pedagogy of pedagogiesToDelete) {
                            for (const activity of pedagogy.iDo) {
                                await deletePedagogyMutation.mutateAsync({
                                    activityType: "iDo",
                                    itemId: activity._id
                                });
                            }
                            for (const activity of pedagogy.weDo) {
                                await deletePedagogyMutation.mutateAsync({
                                    activityType: "weDo",
                                    itemId: activity._id
                                });
                            }
                            for (const activity of pedagogy.youDo) {
                                await deletePedagogyMutation.mutateAsync({
                                    activityType: "youDo",
                                    itemId: activity._id
                                });
                            }
                        }
                    }

                    // Delete level data from backend
                    if (levelViewId) {
                        const levelsToDelete = levelsData.filter((level: { subModule: string | string[]; }) =>
                            level.subModule?.includes(draggedSubModuleId)
                        );

                        for (const level of levelsToDelete) {
                            if (level._id) {
                                await deleteLevelMutation.mutateAsync(level._id);
                            }
                        }
                    }

                    // Refresh data
                    await refetchSubModules();
                } else {
                    // Reorder submodules (optimistic update)
                    const moduleSubModules = currentSubModules
                        .filter(sm => sm.moduleId === draggedSubModule.moduleId)
                        .sort((a, b) => (a.index || 0) - (b.index || 0));

                    const draggedIndex = moduleSubModules.findIndex(sm => sm._id === draggedSubModuleId);
                    const targetIndex = moduleSubModules.findIndex(sm => sm._id === targetSubModuleId);

                    const reorderedSubModules = [...moduleSubModules];
                    const [removed] = reorderedSubModules.splice(draggedIndex, 1);
                    reorderedSubModules.splice(targetIndex, 0, removed);

                    const updatedSubModules = reorderedSubModules.map((subModule, index) => ({
                        ...subModule,
                        index: index
                    }));

                    // Merge with existing submodules outside this module (if any)
                    const finalSubModules = currentSubModules.map(sm => {
                        const updated = updatedSubModules.find(usm => usm._id === sm._id);
                        return updated || sm;
                    });

                    // 2. Clean up merged cells & pedagogy data (now happens after UI update)
                    const updatedMergedCells = { ...mergedCells };
                    Object.keys(updatedMergedCells).forEach(key => {
                        updatedMergedCells[key] = updatedMergedCells[key].filter(merge =>
                            !merge.hierarchyIds?.subModules.includes(draggedSubModuleId)
                        );
                    });
                    setMergedCells(updatedMergedCells);

                    const updatedMergedLevels = mergedLevels.filter(merge =>
                        !merge.hierarchyIds.subModules.includes(draggedSubModuleId)
                    );
                    setMergedLevels(updatedMergedLevels);

                    // 3. Delete backend pedagogy data
                    const pedagogyToUpdate = pedagogyViews?.[0];
                    if (pedagogyToUpdate) {
                        const pedagogiesToDelete = pedagogyToUpdate.pedagogies.filter(pedagogy =>
                            pedagogy.subModule?.includes(draggedSubModuleId)
                        );

                        for (const pedagogy of pedagogiesToDelete) {
                            for (const activity of pedagogy.iDo) {
                                await deletePedagogyMutation.mutateAsync({
                                    activityType: "iDo",
                                    itemId: activity._id
                                });
                            }
                            for (const activity of pedagogy.weDo) {
                                await deletePedagogyMutation.mutateAsync({
                                    activityType: "weDo",
                                    itemId: activity._id
                                });
                            }
                            for (const activity of pedagogy.youDo) {
                                await deletePedagogyMutation.mutateAsync({
                                    activityType: "youDo",
                                    itemId: activity._id
                                });
                            }
                        }
                    }

                    // 4. Delete level data from backend
                    if (levelViewId) {
                        const levelsToDelete = levelsData.filter((level: { subModule: string | string[]; }) =>
                            level.subModule?.includes(draggedSubModuleId)
                        );

                        for (const level of levelsToDelete) {
                            if (level._id) {
                                await deleteLevelMutation.mutateAsync(level._id);
                            }
                        }


                    }
                    queryClient.setQueryData(subModuleApi.getAll().queryKey, finalSubModules);
                    // 5. Update backend with new order
                    const updates = updatedSubModules.map(subModule =>
                        updateSubModuleMutation.mutateAsync({
                            id: subModule._id,
                            data: {
                                title: subModule.title,
                                description: subModule.description,
                                level: subModule.level,
                                moduleId: subModule.moduleId,
                                courses: subModule.courses,
                                index: subModule.index,
                                duration: subModule.duration
                            }
                        })
                    );

                    await Promise.all(updates);
                }
            }
            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 2000);
        } catch (error) {
            console.error("Failed to reorder submodules:", error);
            setErrorMessage(error instanceof Error ? error.message : "Failed to reorder submodules");
            setShowErrorDialog(true);

            // Rollback: Refetch original data
            queryClient.invalidateQueries({ queryKey: subModuleApi.getAll().queryKey });
        }
    };
    // Topic drag handlers (similar to SubModule)
    const handleTopicDragStart = (e: React.DragEvent, topicId: string) => {
        if (!isCellMovable('topic', topicId)) {
            e.preventDefault();
            return;
        }

        const topic = topics.find(t => t._id === topicId);
        e.dataTransfer.setData('application/json', JSON.stringify({
            id: topicId,
            type: 'topic',
            currentIndex: topic?.index || 0,
            currentParent: topic?.subModuleId || topic?.moduleId // Current parent
        }));
        setDraggingTopicId(topicId);
        e.dataTransfer.effectAllowed = 'move';
    };
    const handleTopicDragEnd = () => {
        setDraggingTopicId(null);
        setDragOverId(null);
        setMovableCell(null);
        setIsMoveModeActive(false);
    };
    const handleTopicDrop = async (e: React.DragEvent, targetTopicId: string) => {
        e.preventDefault();
        const dragData = JSON.parse(e.dataTransfer.getData('application/json'));
        const draggedTopicId = dragData.id;
        setDraggingTopicId(null);
        setDragOverId(null);

        if (!token || !selectedCourse) return;

        try {
            // 1. Optimistically update local state first (like handleSubModuleDrop)
            const currentTopics = queryClient.getQueryData<Topic[]>(topicApi.getAll().queryKey) || [];
            const draggedTopic = topics.find(t => t._id === draggedTopicId);
            const targetTopic = topics.find(t => t._id === targetTopicId);

            if (!draggedTopic) return;

            // Can only reorder within same submodule (or module if no submodules)
            const hierarchyLevels = selectedCourse.courseHierarchy.map(l => l.toLowerCase());
            const hasSubModules = hierarchyLevels.includes('sub module');

            const isDroppingOnEmptyCell = targetTopicId.includes('default') || targetTopicId.includes('none') || !targetTopic;
            const targetParentId = hasSubModules ? targetTopic?.subModuleId : targetTopic?.moduleId;

            // Determine current parent ID
            const currentParentId = hasSubModules ? draggedTopic.subModuleId : draggedTopic.moduleId;

            // Check if we're moving to a different parent
            const isChangingParent = currentParentId !== targetParentId;
            if (isDroppingOnEmptyCell) {
                // For empty cells, we need to find the parent module or submodule
                let parentId: string | undefined;
                let parentType: 'module' | 'submodule' = 'module';
                const row = tableRows.find(r =>
                    r.topicId === targetTopicId ||
                    (r.subModuleId && r.subModuleId === targetTopicId.replace('-default', '')) ||
                    (r.moduleId && r.moduleId === targetTopicId.replace('-default', ''))
                );

                if (!row) {
                    setErrorMessage("Cannot determine parent for this empty cell");
                    setShowErrorDialog(true);
                    return;
                }
                if (hasSubModules) {
                    // If submodule is in course hierarchy, use submodule as parent
                    if (row.subModuleId && !row.subModuleId.includes('none') && !row.subModuleId.includes('default')) {
                        parentId = row.subModuleId;
                        parentType = 'submodule';

                        // Validate submodule exists
                        const parentSubModule = subModules.find(sm => sm._id === parentId);
                        if (!parentSubModule) {
                            setErrorMessage("Parent submodule not found for this empty cell");
                            setShowErrorDialog(true);
                            return;
                        }
                    } else {
                        setErrorMessage("Cannot add topic here - no submodule available in this hierarchy position");
                        setShowErrorDialog(true);
                        return;
                    }
                } else {
                    // If submodule is NOT in course hierarchy, use module as parent
                    if (row.moduleId && !row.moduleId.includes('none') && !row.moduleId.includes('default')) {
                        parentId = row.moduleId;
                        parentType = 'module';

                        // Validate module exists
                        const parentModule = modules.find(m => m._id === parentId);
                        if (!parentModule) {
                            setErrorMessage("Parent module not found for this empty cell");
                            setShowErrorDialog(true);
                            return;
                        }
                    } else {
                        setErrorMessage("Cannot add topic here - no module available in this hierarchy position");
                        setShowErrorDialog(true);
                        return;
                    }
                }


                // Get all topics in the target parent to calculate new index
                const targetParentTopics = topics
                    .filter(t =>
                        parentType === 'submodule'
                            ? t.subModuleId === parentId
                            : t.moduleId === parentId
                    )
                    .sort((a, b) => (a.index || 0) - (b.index || 0));

                const newIndex = targetParentTopics.length > 0
                    ? Math.max(...targetParentTopics.map(t => t.index || 0)) + 1
                    : 0;

                const updatedTopic = {
                    ...draggedTopic,
                    moduleId: parentType === 'submodule' ? draggedTopic.moduleId : parentId,
                    subModuleId: parentType === 'submodule' ? parentId : undefined,
                    index: newIndex
                };

                // Update backend
                await updateTopicMutation.mutateAsync({
                    id: draggedTopicId,
                    data: updatedTopic
                });

                const updatedMergedCells = { ...mergedCells };
                Object.keys(updatedMergedCells).forEach(key => {
                    updatedMergedCells[key] = updatedMergedCells[key].filter(merge =>
                        !merge.hierarchyIds?.topics.includes(draggedTopicId)
                    );
                });
                setMergedCells(updatedMergedCells);

                const updatedMergedLevels = mergedLevels.filter(merge =>
                    !merge.hierarchyIds.topics.includes(draggedTopicId)
                );
                setMergedLevels(updatedMergedLevels);

                // Delete backend pedagogy data
                const pedagogyToUpdate = pedagogyViews?.[0];
                if (pedagogyToUpdate) {
                    const pedagogiesToDelete = pedagogyToUpdate.pedagogies.filter(pedagogy =>
                        pedagogy.topic?.includes(draggedTopicId)
                    );

                    for (const pedagogy of pedagogiesToDelete) {
                        for (const activity of pedagogy.iDo) {
                            await deletePedagogyMutation.mutateAsync({
                                activityType: "iDo",
                                itemId: activity._id
                            });
                        }
                        for (const activity of pedagogy.weDo) {
                            await deletePedagogyMutation.mutateAsync({
                                activityType: "weDo",
                                itemId: activity._id
                            });
                        }
                        for (const activity of pedagogy.youDo) {
                            await deletePedagogyMutation.mutateAsync({
                                activityType: "youDo",
                                itemId: activity._id
                            });
                        }
                    }
                }

                // Delete level data from backend
                if (levelViewId) {
                    const levelsToDelete = levelsData.filter((level: { topic: string | string[]; }) =>
                        level.topic?.includes(draggedTopicId)
                    );

                    for (const level of levelsToDelete) {
                        if (level._id) {
                            await deleteLevelMutation.mutateAsync(level._id);
                        }
                    }
                }

                // Refresh data
                await refetchTopics();

            } else {
                if (isChangingParent) {
                    // Moving to a different parent - update parent references

                    // Get all topics in the target parent to calculate new index
                    const targetParentTopics = topics
                        .filter(t =>
                            hasSubModules
                                ? t.subModuleId === targetParentId
                                : t.moduleId === targetParentId
                        )
                        .sort((a, b) => (a.index || 0) - (b.index || 0));

                    const newIndex = targetParentTopics.length > 0
                        ? Math.max(...targetParentTopics.map(t => t.index || 0)) + 1
                        : 0;

                    const updatedTopic = {
                        ...draggedTopic,
                        moduleId: hasSubModules ? targetTopic?.moduleId : targetParentId,
                        subModuleId: hasSubModules ? targetParentId : undefined,
                        index: newIndex
                    };

                    // Update backend
                    await updateTopicMutation.mutateAsync({
                        id: draggedTopicId,
                        data: updatedTopic
                    });

                    // Clean up pedagogy and level data for the moved topic
                    // (Same cleanup as in your original same-parent logic)
                    const updatedMergedCells = { ...mergedCells };
                    Object.keys(updatedMergedCells).forEach(key => {
                        updatedMergedCells[key] = updatedMergedCells[key].filter(merge =>
                            !merge.hierarchyIds?.topics.includes(draggedTopicId)
                        );
                    });
                    setMergedCells(updatedMergedCells);

                    const updatedMergedLevels = mergedLevels.filter(merge =>
                        !merge.hierarchyIds.topics.includes(draggedTopicId)
                    );
                    setMergedLevels(updatedMergedLevels);

                    // Delete backend pedagogy data
                    const pedagogyToUpdate = pedagogyViews?.[0];
                    if (pedagogyToUpdate) {
                        const pedagogiesToDelete = pedagogyToUpdate.pedagogies.filter(pedagogy =>
                            pedagogy.topic?.includes(draggedTopicId)
                        );

                        for (const pedagogy of pedagogiesToDelete) {
                            for (const activity of pedagogy.iDo) {
                                await deletePedagogyMutation.mutateAsync({
                                    activityType: "iDo",
                                    itemId: activity._id
                                });
                            }
                            for (const activity of pedagogy.weDo) {
                                await deletePedagogyMutation.mutateAsync({
                                    activityType: "weDo",
                                    itemId: activity._id
                                });
                            }
                            for (const activity of pedagogy.youDo) {
                                await deletePedagogyMutation.mutateAsync({
                                    activityType: "youDo",
                                    itemId: activity._id
                                });
                            }
                        }
                    }

                    // Delete level data from backend
                    if (levelViewId) {
                        const levelsToDelete = levelsData.filter((level: { topic: string | string[]; }) =>
                            level.topic?.includes(draggedTopicId)
                        );

                        for (const level of levelsToDelete) {
                            if (level._id) {
                                await deleteLevelMutation.mutateAsync(level._id);
                            }
                        }
                    }

                    // Refresh data
                    await refetchTopics();
                } else {
                    const parentId = hasSubModules ? draggedTopic.subModuleId : draggedTopic.moduleId;
                    const moduleTopics = currentTopics
                        .filter(t => hasSubModules ? t.subModuleId === parentId : t.moduleId === parentId)
                        .sort((a, b) => (a.index || 0) - (b.index || 0));

                    const draggedIndex = moduleTopics.findIndex(t => t._id === draggedTopicId);
                    const targetIndex = moduleTopics.findIndex(t => t._id === targetTopicId);

                    const reorderedTopics = [...moduleTopics];
                    const [removed] = reorderedTopics.splice(draggedIndex, 1);
                    reorderedTopics.splice(targetIndex, 0, removed);

                    const updatedTopics = reorderedTopics.map((topic, index) => ({
                        ...topic,
                        index: index
                    }));

                    // Merge with existing topics outside this module/submodule (if any)
                    const finalTopics = currentTopics.map(t => {
                        const updated = updatedTopics.find(ut => ut._id === t._id);
                        return updated || t;
                    });

                    // 2. Clean up merged cells & pedagogy data (now happens after UI update)
                    const updatedMergedCells = { ...mergedCells };
                    Object.keys(updatedMergedCells).forEach(key => {
                        updatedMergedCells[key] = updatedMergedCells[key].filter(merge =>
                            !merge.hierarchyIds?.topics.includes(draggedTopicId)
                        );
                    });
                    setMergedCells(updatedMergedCells);

                    const updatedMergedLevels = mergedLevels.filter(merge =>
                        !merge.hierarchyIds.topics.includes(draggedTopicId)
                    );
                    setMergedLevels(updatedMergedLevels);

                    // 3. Delete pedagogy data from backend
                    const pedagogyToUpdate = pedagogyViews?.[0];
                    if (pedagogyToUpdate) {
                        const pedagogiesToDelete = pedagogyToUpdate.pedagogies.filter(pedagogy =>
                            pedagogy.topic?.includes(draggedTopicId)
                        );

                        for (const pedagogy of pedagogiesToDelete) {
                            for (const activity of pedagogy.iDo) {
                                await deletePedagogyMutation.mutateAsync({
                                    activityType: "iDo",
                                    itemId: activity._id
                                });
                            }
                            for (const activity of pedagogy.weDo) {
                                await deletePedagogyMutation.mutateAsync({
                                    activityType: "weDo",
                                    itemId: activity._id
                                });
                            }
                            for (const activity of pedagogy.youDo) {
                                await deletePedagogyMutation.mutateAsync({
                                    activityType: "youDo",
                                    itemId: activity._id
                                });
                            }
                        }
                    }

                    // 4. Delete level data from backend
                    if (levelViewId) {
                        const levelsToDelete = levelsData.filter((level: { topic: string | string[]; }) =>
                            level.topic?.includes(draggedTopicId)
                        );

                        for (const level of levelsToDelete) {
                            if (level._id) {
                                await deleteLevelMutation.mutateAsync(level._id);
                            }
                        }


                    }

                    // 5. Delete pedagogy merges specifically for topics
                    await deletePedagogyMerges({
                        topics: [draggedTopicId]
                    });

                    // 6. Update backend with new order
                    await Promise.all(
                        updatedTopics.map(topic =>
                            updateTopicMutation.mutateAsync({
                                id: topic._id,
                                data: {
                                    title: topic.title,
                                    description: topic.description,
                                    level: topic.level,
                                    moduleId: topic.moduleId,
                                    subModuleId: topic.subModuleId,
                                    courses: topic.courses,
                                    index: topic.index,
                                    duration: topic.duration
                                }
                            })
                        )
                    );

                    refetchTopics();
                }
            }
            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 2000);
        } catch (error) {
            console.error("Failed to reorder topics:", error);
            setErrorMessage(error instanceof Error ? error.message : "Failed to reorder topics");
            setShowErrorDialog(true);

            // Rollback: Refetch original data
            refetchTopics();
        }
    };
    // Subtopic drag handlers (existing implementation)
    const handleSubtopicDragStart = (e: React.DragEvent, subtopicId: string) => {
        if (!isCellMovable('subtopic', subtopicId)) {
            e.preventDefault();
            return;
        }

        const subtopic = subTopics.find(st => st._id === subtopicId);
        e.dataTransfer.setData('application/json', JSON.stringify({
            id: subtopicId,
            type: 'subtopic',
            currentIndex: subtopic?.index || 0,
            currentParent: subtopic?.topicId // Current parent topic
        }));
        setDraggingSubtopicId(subtopicId);
        e.dataTransfer.effectAllowed = 'move';
    };
    const handleSubtopicDragEnd = () => {
        setDraggingSubtopicId(null);
        setDragOverId(null);
        setMovableCell(null);
        setIsMoveModeActive(false);
    };
    const handleSubtopicDrop = async (e: React.DragEvent, targetSubtopicId: string) => {
        e.preventDefault();
        const dragData = JSON.parse(e.dataTransfer.getData('application/json'));
        const draggedSubtopicId = dragData.id;
        setDraggingSubtopicId(null);
        setDragOverId(null);

        if (!token || !selectedCourse) return;

        try {
            // 1. Optimistically update local state first
            const currentSubTopics = queryClient.getQueryData<SubTopic[]>(subTopicApi.getAll().queryKey) || [];
            const draggedSubtopic = subTopics.find(st => st._id === draggedSubtopicId);
            const targetSubtopic = subTopics.find(st => st._id === targetSubtopicId);

            if (!draggedSubtopic) return;
            const isChangingTopic = draggedSubtopic.topicId !== targetSubtopic?.topicId;

            const isDroppingOnEmptyCell = targetSubtopicId.includes('placeholder') || targetSubtopicId.includes('default') || targetSubtopicId.includes('none');

            if (isDroppingOnEmptyCell) {
                // For empty cells, we need to find the parent topic
                // Extract topic ID from empty cell ID (format: "topicId-placeholder" or "topicId-placeholder-sub")
                let topicId = targetSubtopicId.split('-')[0];

                // Handle different empty cell ID formats
                if (topicId === 'placeholder' && targetSubtopicId.includes('-placeholder-topic')) {
                    // Format: "moduleId-placeholder-topic-placeholder-sub"
                    const parts = targetSubtopicId.split('-');
                    topicId = parts[0]; // This should be the module ID, but we need to find the actual topic

                    // For this case, we need to find or create the actual topic
                    const moduleId = parts[0];
                    const moduleTopics = topics.filter(t => t.moduleId === moduleId);

                    if (moduleTopics.length > 0) {
                        topicId = moduleTopics[0]._id; // Use first topic in module
                    } else {
                        setErrorMessage("No topics found in this module to attach the subtopic to");
                        setShowErrorDialog(true);
                        return;
                    }
                }

                if (!topicId || topicId === 'placeholder') {
                    setErrorMessage("Cannot determine parent topic for this empty cell");
                    setShowErrorDialog(true);
                    return;
                }

                const targetTopic = topics.find(t => t._id === topicId);
                if (!targetTopic) {
                    setErrorMessage("Parent topic not found for this empty cell");
                    setShowErrorDialog(true);
                    return;
                }

                // Get all subtopics in the target topic to calculate new index
                const targetTopicSubTopics = subTopics
                    .filter(st => st.topicId === topicId)
                    .sort((a, b) => (a.index || 0) - (b.index || 0));

                const newIndex = targetTopicSubTopics.length > 0
                    ? Math.max(...targetTopicSubTopics.map(st => st.index || 0)) + 1
                    : 0;

                // Update the subtopic with new parent topic and index
                const updatedSubtopic = {
                    ...draggedSubtopic,
                    topicId: topicId, // Change parent topic
                    index: newIndex
                };

                // Update backend
                await updateSubTopicMutation.mutateAsync({
                    id: draggedSubtopicId,
                    data: updatedSubtopic
                });

                // Clean up pedagogy and level data from old position
                const updatedMergedCells = { ...mergedCells };
                Object.keys(updatedMergedCells).forEach(key => {
                    updatedMergedCells[key] = updatedMergedCells[key].filter(merge =>
                        !merge.hierarchyIds?.subTopics.includes(draggedSubtopicId)
                    );
                });
                setMergedCells(updatedMergedCells);

                const updatedMergedLevels = mergedLevels.filter(merge =>
                    !merge.hierarchyIds.subTopics.includes(draggedSubtopicId)
                );
                setMergedLevels(updatedMergedLevels);

                // Delete backend pedagogy data from old position
                const pedagogyToUpdate = pedagogyViews?.[0];
                if (pedagogyToUpdate) {
                    const pedagogiesToDelete = pedagogyToUpdate.pedagogies.filter(pedagogy =>
                        pedagogy.subTopic?.includes(draggedSubtopicId)
                    );

                    for (const pedagogy of pedagogiesToDelete) {
                        for (const activity of pedagogy.iDo) {
                            await deletePedagogyMutation.mutateAsync({
                                activityType: "iDo",
                                itemId: activity._id
                            });
                        }
                        for (const activity of pedagogy.weDo) {
                            await deletePedagogyMutation.mutateAsync({
                                activityType: "weDo",
                                itemId: activity._id
                            });
                        }
                        for (const activity of pedagogy.youDo) {
                            await deletePedagogyMutation.mutateAsync({
                                activityType: "youDo",
                                itemId: activity._id
                            });
                        }
                    }

                    // Update pedagogy view
                    const updatedPedagogies = pedagogyToUpdate.pedagogies.filter(pedagogy =>
                        !pedagogy.subTopic?.includes(draggedSubtopicId)
                    );

                    await pedagogyMutation.mutateAsync({
                        courses: selectedCourse?._id || '',
                        pedagogies: updatedPedagogies
                    });
                }

                // Delete level data from backend from old position
                if (levelViewId) {
                    const levelsToDelete = levelsData.filter((level: { subTopic: string | string[]; }) =>
                        level.subTopic?.includes(draggedSubtopicId)
                    );

                    for (const level of levelsToDelete) {
                        if (level._id) {
                            await deleteLevelMutation.mutateAsync(level._id);
                        }
                    }
                }

                // Refresh data
                await refetchSubTopics();
                if (targetTopic._id) {
                    await refetchTopicSubTopics();
                }

                setShowSuccessMessage(true);
                setTimeout(() => setShowSuccessMessage(false), 2000);

            } else {
                if (isChangingTopic) {
                    // Moving to a different topic - update the topicId
                    const targetTopicSubTopics = subTopics
                        .filter(st => st.topicId === targetSubtopic?.topicId)
                        .sort((a, b) => (a.index || 0) - (b.index || 0));

                    const newIndex = targetTopicSubTopics.length > 0
                        ? Math.max(...targetTopicSubTopics.map(st => st.index || 0)) + 1
                        : 0;

                    const updatedSubtopic = {
                        ...draggedSubtopic,
                        topicId: targetSubtopic?.topicId,
                        index: newIndex
                    };

                    // Update backend
                    await updateSubTopicMutation.mutateAsync({
                        id: draggedSubtopicId,
                        data: updatedSubtopic
                    });

                    // Clean up pedagogy and level data for the moved subtopic
                    // (Same cleanup as in your original same-parent logic)
                    const updatedMergedCells = { ...mergedCells };
                    Object.keys(updatedMergedCells).forEach(key => {
                        updatedMergedCells[key] = updatedMergedCells[key].filter(merge =>
                            !merge.hierarchyIds?.subTopics.includes(draggedSubtopicId)
                        );
                    });
                    setMergedCells(updatedMergedCells);

                    const updatedMergedLevels = mergedLevels.filter(merge =>
                        !merge.hierarchyIds.subTopics.includes(draggedSubtopicId)
                    );
                    setMergedLevels(updatedMergedLevels);

                    // Delete backend pedagogy data
                    const pedagogyToUpdate = pedagogyViews?.[0];
                    if (pedagogyToUpdate) {
                        const pedagogiesToDelete = pedagogyToUpdate.pedagogies.filter(pedagogy =>
                            pedagogy.subTopic?.includes(draggedSubtopicId)
                        );

                        for (const pedagogy of pedagogiesToDelete) {
                            for (const activity of pedagogy.iDo) {
                                await deletePedagogyMutation.mutateAsync({
                                    activityType: "iDo",
                                    itemId: activity._id
                                });
                            }
                            for (const activity of pedagogy.weDo) {
                                await deletePedagogyMutation.mutateAsync({
                                    activityType: "weDo",
                                    itemId: activity._id
                                });
                            }
                            for (const activity of pedagogy.youDo) {
                                await deletePedagogyMutation.mutateAsync({
                                    activityType: "youDo",
                                    itemId: activity._id
                                });
                            }
                        }

                        // Update pedagogy view
                        const updatedPedagogies = pedagogyToUpdate.pedagogies.filter(pedagogy =>
                            !pedagogy.subTopic?.includes(draggedSubtopicId)
                        );

                        await pedagogyMutation.mutateAsync({
                            courses: selectedCourse?._id || '',
                            pedagogies: updatedPedagogies
                        });
                    }

                    // Delete level data from backend
                    if (levelViewId) {
                        const levelsToDelete = levelsData.filter((level: { subTopic: string | string[]; }) =>
                            level.subTopic?.includes(draggedSubtopicId)
                        );

                        for (const level of levelsToDelete) {
                            if (level._id) {
                                await deleteLevelMutation.mutateAsync(level._id);
                            }
                        }
                    }

                    // Refresh data
                    await refetchSubTopics();
                    if (targetSubtopic?.topicId) {
                        await refetchTopicSubTopics();
                    }
                } else {

                    // Get all subtopics for this topic and sort by index
                    const topicSubTopics = currentSubTopics
                        .filter(st => st.topicId === draggedSubtopic.topicId)
                        .sort((a, b) => (a.index || 0) - (b.index || 0));

                    // Find positions of dragged and target subtopics
                    const draggedIndex = topicSubTopics.findIndex(st => st._id === draggedSubtopicId);
                    const targetIndex = topicSubTopics.findIndex(st => st._id === targetSubtopicId);

                    // Reorder the array
                    const reorderedSubTopics = [...topicSubTopics];
                    const [removed] = reorderedSubTopics.splice(draggedIndex, 1);
                    reorderedSubTopics.splice(targetIndex, 0, removed);

                    // Update indexes
                    const updatedSubTopics = reorderedSubTopics.map((subtopic, index) => ({
                        ...subtopic,
                        index: index
                    }));

                    // Merge with existing subtopics outside this topic (if any)
                    const finalSubTopics = currentSubTopics.map(st => {
                        const updated = updatedSubTopics.find(ust => ust._id === st._id);
                        return updated || st;
                    });


                    queryClient.setQueryData(subTopicApi.getAll().queryKey, finalSubTopics);
                    // 2. Clean up merged cells & pedagogy data
                    const updatedMergedCells = { ...mergedCells };
                    Object.keys(updatedMergedCells).forEach(key => {
                        updatedMergedCells[key] = updatedMergedCells[key].filter(merge =>
                            !merge.hierarchyIds?.subTopics.includes(draggedSubtopicId)
                        );
                    });
                    setMergedCells(updatedMergedCells);

                    const updatedMergedLevels = mergedLevels.filter(merge =>
                        !merge.hierarchyIds.subTopics.includes(draggedSubtopicId)
                    );
                    setMergedLevels(updatedMergedLevels);

                    // 3. Delete pedagogy data from backend
                    const pedagogyToUpdate = pedagogyViews?.[0];
                    if (pedagogyToUpdate) {
                        const pedagogiesToDelete = pedagogyToUpdate.pedagogies.filter(pedagogy =>
                            pedagogy.subTopic?.includes(draggedSubtopicId)
                        );

                        for (const pedagogy of pedagogiesToDelete) {
                            for (const activity of pedagogy.iDo) {
                                await deletePedagogyMutation.mutateAsync({
                                    activityType: "iDo",
                                    itemId: activity._id
                                });
                            }
                            for (const activity of pedagogy.weDo) {
                                await deletePedagogyMutation.mutateAsync({
                                    activityType: "weDo",
                                    itemId: activity._id
                                });
                            }
                            for (const activity of pedagogy.youDo) {
                                await deletePedagogyMutation.mutateAsync({
                                    activityType: "youDo",
                                    itemId: activity._id
                                });
                            }
                        }

                        // Update pedagogy view
                        const updatedPedagogies = pedagogyToUpdate.pedagogies.filter(pedagogy =>
                            !pedagogy.subTopic?.includes(draggedSubtopicId)
                        );

                        await pedagogyMutation.mutateAsync({
                            courses: selectedCourse?._id || '',
                            pedagogies: updatedPedagogies
                        });
                    }

                    // 4. Delete level data from backend
                    if (levelViewId) {
                        const levelsToDelete = levelsData.filter((level: { subTopic: string | string[]; }) =>
                            level.subTopic?.includes(draggedSubtopicId)
                        );

                        for (const level of levelsToDelete) {
                            if (level._id) {
                                await deleteLevelMutation.mutateAsync(level._id);
                            }
                        }


                    }

                    // 5. Update backend with new order
                    await Promise.all(
                        updatedSubTopics.map(subtopic =>
                            updateSubTopicMutation.mutateAsync({
                                id: subtopic._id,
                                data: {
                                    title: subtopic.title,
                                    description: subtopic.description,
                                    level: subtopic.level,
                                    topicId: subtopic.topicId,
                                    courses: subtopic.courses,
                                    index: subtopic.index,
                                    duration: subtopic.duration
                                }
                            })
                        )
                    );
                    await refetchSubTopics();
                    if (draggedSubtopic.topicId) {
                        await refetchTopicSubTopics();
                    }
                }
            }

            setShowSuccessMessage(true);
            setTimeout(() => setShowSuccessMessage(false), 2000);
        } catch (error) {
            console.error("Failed to reorder subtopics:", error);
            setErrorMessage(error instanceof Error ? error.message : "Failed to reorder subtopics");
            setShowErrorDialog(true);

            // Rollback: Refetch original data
            queryClient.invalidateQueries({ queryKey: subTopicApi.getAll().queryKey });
            if (selectedTopicForSubTopic?.id) {
                queryClient.invalidateQueries({
                    queryKey: subTopicApi.getByTopicId(selectedTopicForSubTopic.id).queryKey
                });
            }
        }
    };
    const handleDragOver = (e: React.DragEvent, id: string, type: string) => {
        e.preventDefault();

        try {
            const dragData = JSON.parse(e.dataTransfer.getData('application/json'));

            // Check if this is a cross-parent drag operation
            const isCrossParent = dragData.currentParent &&
                dragData.currentParent !== getTargetParentId(id, type);

            // Provide visual feedback for cross-parent drag operations
            if (isCrossParent) {
                // Highlight with a different style for cross-parent moves
                setDragOverId(id);
                e.dataTransfer.dropEffect = 'copy'; // Visual indicator for cross-parent move
            } else {
                // Regular same-parent move
                setDragOverId(id);
                e.dataTransfer.dropEffect = 'move';
            }
        } catch (error) {
            // Fallback for legacy drag events
            setDragOverId(id);
        }
    };

    const CellActionsMenu = ({
        row,
        type,
        onEdit,
        onAdd,
        onDelete,
        onEnableDrag,
        onMultipleDelete,
        addLabel // Add this new prop
    }: {
        row: any,
        type: 'module' | 'submodule' | 'topic' | 'subtopic',
        onEdit: () => void,
        onAdd?: () => void,
        onDelete: () => void,
        onEnableDrag: () => void,
        onMultipleDelete?: () => void,
        addLabel?: string // New prop for the add button label
    }) => {
        return (
            <DropdownMenu>
                <DropdownMenuTrigger asChild>
                    <button
                        className="p-1 rounded-full cursor-pointer hover:bg-blue-100 hover:shadow-md transition-all duration-200 ease-in-out transform hover:scale-110"
                        onClick={(e) => e.stopPropagation()}
                    >
                        <MoreVertical className="w-4 h-4 text-blue-600" />
                    </button>
                </DropdownMenuTrigger>
                <DropdownMenuContent className="w-48 text-xs bg-white border border-gray-200 shadow-xl rounded-lg p-1 animate-in slide-in-from-top-2 duration-200">
                    {/* Add option with hierarchy label */}
                    {onAdd && (
                        <DropdownMenuItem
                            onClick={onAdd}
                            className="flex items-center px-3 py-2.5 rounded-md cursor-pointer transition-all duration-150 hover:bg-blue-50 hover:text-blue-700 group"
                        >
                            <Plus className="mr-3 h-3.5 w-3.5 text-blue-500 group-hover:text-blue-600 transition-colors duration-150 flex-shrink-0" />
                            <div className="flex flex-col">
                                <span className="font-medium">Add <span className="text-[10px] text-blue-600">({addLabel})</span></span>
                            </div>
                        </DropdownMenuItem>
                    )}

                    <DropdownMenuItem onClick={onEdit} className="flex items-center px-3 py-2.5 rounded-md cursor-pointer transition-all duration-150 hover:bg-blue-50 hover:text-blue-700">
                        <Pencil className="mr-3 h-3.5 w-3.5 text-blue-500 hover:text-blue-600 transition-colors duration-150 flex-shrink-0" />
                        <span className="font-medium">Edit</span>
                    </DropdownMenuItem>

                    <DropdownMenuItem
                        onClick={onDelete}
                        className="flex items-center px-3 py-2.5 rounded-md cursor-pointer transition-all duration-150 hover:bg-red-50 hover:text-red-700"
                    >
                        <Trash className="mr-3 h-3.5 w-3.5 text-red-500 hover:text-red-600 transition-colors duration-150 flex-shrink-0" />
                        <span className="font-medium">Delete</span>
                    </DropdownMenuItem>
                    {/* Multiple Delete Option */}
                    {onMultipleDelete && (
                        <DropdownMenuItem
                            onClick={onMultipleDelete}
                            className="flex items-center px-3 py-2.5 rounded-md cursor-pointer transition-all duration-150 hover:bg-orange-50 hover:text-orange-700"
                        >
                            <Trash2 className="mr-3 h-3.5 w-3.5 text-orange-500 hover:text-orange-600 transition-colors duration-150 flex-shrink-0" />
                            <span className="font-medium">Multiple Delete</span>
                        </DropdownMenuItem>
                    )}
                    <DropdownMenuItem
                        onClick={onEnableDrag}
                        className="flex items-center px-3 py-2.5 rounded-md cursor-pointer transition-all duration-150 hover:bg-green-100 hover:text-green-700"
                    >
                        <Move className="mr-3 h-3.5 w-3.5 text-green-500 hover:text-green-600 transition-colors duration-150 flex-shrink-0" />
                        <span className="font-medium">Move</span>
                    </DropdownMenuItem>
                </DropdownMenuContent>
            </DropdownMenu>
        );
    };

    const CellActionMenu = ({
        cellType,
        cellKey,
        hasValue,
        isMerged,

        onAdd,
        onEdit,
        onDelete,
        onMerge,
        onUnmerge
    }: {
        cellType: 'level' | 'pedagogy';
        cellKey: string;
        hasValue: boolean;
        isMerged: boolean;

        onAdd: () => void;
        onEdit: () => void;
        onDelete: () => void;
        onMerge: () => void;
        onUnmerge?: () => void;
    }) => {


        return (
            <DropdownMenu>
                <DropdownMenuTrigger asChild>
                    <Button variant="ghost" size="sm" className="h-6 w-6 p-0">
                        <MoreVertical className="h-4 w-4" />
                    </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                    {!hasValue && !isMerged && (
                        <DropdownMenuItem onSelect={onAdd} className="flex items-center cursor-pointer">
                            <Plus className="mr-2 h-4 w-4" />
                            Add
                        </DropdownMenuItem>
                    )}
                    {(hasValue || isMerged) && (
                        <DropdownMenuItem onSelect={onEdit} className="flex items-center cursor-pointer">
                            <Pencil className="mr-2 h-4 w-4" />
                            {isMerged ? 'Edit Merged' : 'Edit'}
                        </DropdownMenuItem>
                    )}
                    {(hasValue || isMerged) && (
                        <DropdownMenuItem
                            onSelect={isMerged ? onUnmerge : onDelete}
                            className="flex items-center text-red-600 cursor-pointer"
                        >
                            {isMerged ? (
                                <>
                                    <Split className="mr-2 h-4 w-4" />
                                    Unmerge
                                </>
                            ) : (
                                <>
                                    <Trash className="mr-2 h-4 w-4" />
                                    Delete
                                </>
                            )}
                        </DropdownMenuItem>
                    )}
                    {!hasValue && !isMerged && (
                        <DropdownMenuItem onSelect={onMerge} className="flex items-center cursor-pointer">
                            <Merge className="mr-2 h-4 w-4" />
                            Merge
                        </DropdownMenuItem>
                    )}
                </DropdownMenuContent>
            </DropdownMenu>
        );
    };

    const AddCellButton = ({
        onClick,
        label
    }: {
        onClick: () => void,
        label: string
    }) => {
        return (
            <button
                onClick={onClick}
                className="flex items-center cursor-pointer justify-center w-full h-full p-1.5 rounded-md bg-transparent hover:bg-blue-50 transition-colors duration-150 group"
                title={`Add New ${label}`}
            >
                <div className="flex items-center justify-center w-6 h-6 rounded-full bg-blue-100 text-blue-600 group-hover:bg-blue-200 group-hover:text-blue-700 transition-colors duration-150">
                    <Plus className="w-3.5 h-3.5" />
                </div>
                <span className="ml-2 text-xs font-medium text-blue-600">Add New {label}</span>
            </button>
        );
    };

    const handlePrint = () => {
        if (printRef.current) {
            printRef.current.handlePrint();
        }
    };

    const renderAddFirstMessages = () => {
        if (!selectedCourse) return null;

        return (
            <div className="bg-white rounded-lg border border-gray-200 p-6 text-center">
                <div className="text-gray-600 mb-4">
                    <Info className="w-12 h-12 mx-auto text-blue-500 mb-2" />
                    <h3 className="text-lg font-medium mb-2">Add Content to Get Started</h3>
                    <p className="text-sm">
                        Please add content to the{" "}
                        <span className="font-semibold text-blue-600">
                            {nameOfMessage.toLowerCase()}
                        </span>{" "}
                        first
                    </p>
                </div>
            </div>
        );
    };

    return (
        <DashboardLayoutProgramcoordinator>
            <div className={`bg-gray-50 `}>
                <div className="space-y-2">
                    {/* Success Message */}
                    {showSuccessMessage && (
                        <div className="fixed top-4 right-4 z-50 bg-green-500 text-white px-3 py-1.5 rounded-md shadow flex items-center gap-1 text-xs">
                            <CheckCircle2 className="w-3 h-3" />
                            <span>Operation completed successfully!</span>
                        </div>
                    )}
                    {selectedCourse && (
                        <DraggableZoomControls
                            zoomLevel={tableZoomLevel}
                            onZoomIn={zoomTableIn}
                            onZoomOut={zoomTableOut}
                            onResetZoom={resetTableZoom}

                        />
                    )}
                    {/* Breadcrumbs */}
                    <Breadcrumb>
                        <BreadcrumbList className="text-xs">
                            <BreadcrumbItem>
                                <BreadcrumbLink
                                    href="/programcoordinator/pages/dashboardprogramcoordinator"
                                    className="text-slate-500 hover:text-indigo-600 transition-colors"
                                >
                                    Dashboard
                                </BreadcrumbLink>
                            </BreadcrumbItem>
                            <BreadcrumbSeparator className="text-slate-400" />
                            <BreadcrumbItem>
                                <BreadcrumbLink
                                    href="/programcoordinator/pages/coursestructure"
                                    className="text-slate-500 hover:text-indigo-600 transition-colors"
                                >
                                    Course Structure
                                </BreadcrumbLink>
                            </BreadcrumbItem>
                            <BreadcrumbSeparator className="text-slate-400" />
                            <BreadcrumbItem>
                                <BreadcrumbLink
                                    href="/programcoordinator/pages/pedagogy"
                                    className="text-slate-500 hover:text-indigo-600 transition-colors"
                                >
                                    Pedagogy
                                </BreadcrumbLink>
                            </BreadcrumbItem>
                            <BreadcrumbSeparator className="text-slate-400" />
                            <BreadcrumbItem>
                                <BreadcrumbPage className="text-slate-700 font-medium">{selectedCourse?.courseName}</BreadcrumbPage>
                            </BreadcrumbItem>
                        </BreadcrumbList>
                    </Breadcrumb>

                    {selectedCourse && (
                        <motion.div
                            initial={{ opacity: 0, y: -4, scale: 0.98 }}
                            animate={{ opacity: 1, y: 0, scale: 1 }}
                            exit={{ opacity: 0, y: -4, scale: 0.98 }}
                            transition={{ duration: 0.2, ease: "easeOut" }}
                            className="bg-white rounded-md border border-gray-200 shadow-sm hover:shadow-md transition-all duration-200 p-2"
                        >
                            <div className="flex flex-wrap items-center gap-1.5 text-xs">
                                {/* Course name with label */}
                                <div className="flex items-center gap-1 bg-indigo-50 px-2 py-0.5 rounded-md border border-indigo-200">
                                    <span className="text-indigo-600 font-medium">Course:</span>
                                    <span
                                        className="text-gray-900 font-semibold truncate max-w-[160px]"
                                        title={selectedCourse.courseName}
                                    >
                                        {selectedCourse.courseName}
                                    </span>
                                </div>

                                {/* Course Code */}
                                <div className="flex items-center gap-1 bg-blue-50 px-2 py-0.5 rounded-md border border-blue-200">
                                    <span className="text-blue-600 font-medium">Code:</span>
                                    <span className="text-gray-900 font-semibold">
                                        {selectedCourse.courseCode || "N/A"}
                                    </span>
                                </div>

                                {/* Client */}
                                <div className="flex items-center gap-1 bg-green-50 px-2 py-0.5 rounded-md border border-green-200 max-w-[140px]">
                                    <span className="text-green-600 font-medium">Client:</span>
                                    <span
                                        className="text-gray-900 font-semibold truncate"
                                        title={selectedCourse.clientName}
                                    >
                                        {selectedCourse.clientName || "N/A"}
                                    </span>
                                </div>

                                {/* Level */}
                                <div className="flex items-center gap-1 bg-teal-50 px-2 py-0.5 rounded-md border border-teal-200">
                                    <span className="text-teal-600 font-medium">Level:</span>
                                    <span className="text-gray-900 font-semibold">
                                        {selectedCourse.courseLevel || "N/A"}
                                    </span>
                                </div>
                            </div>
                        </motion.div>
                    )}

                    {selectedCourse ? (
                        <div className="flex flex-col gap-2 min-h-fit">

                            {/* Fullscreen Container - includes controls card and table */}
                            <div
                                ref={fullscreenContainerRef}
                                className={`flex flex-col gap-2`}
                                style={{
                                    height: 'auto',
                                    minHeight: 'fit-content'
                                }}
                            >
                                {/* Custom Merge Hours Modal - positioned inside fullscreen container */}
                                {showMergeDialog && (
                                    <div
                                        className="fixed inset-0 flex items-center justify-center z-[9999]"
                                        style={{ position: "fixed", top: 0, left: 0, right: 0, bottom: 0 }}
                                    >
                                        {/* Backdrop */}
                                        <div
                                            className="absolute inset-0 bg-black/50 bg-opacity-50"
                                            onClick={() => {
                                                setShowMergeDialog(false)
                                                setPendingMerge(null)
                                                setMergeHours("")
                                            }}
                                        />

                                        {/* Modal Content */}
                                        <motion.div
                                            initial="hidden"
                                            animate="visible"
                                            exit="exit"
                                            variants={popupVariants}
                                            className="relative bg-white rounded-lg shadow-xl border max-w-md w-full mx-4 p-6 z-[10000]">
                                            <div className="mb-4">
                                                <h3 className="text-lg font-semibold text-gray-900">Set Merge Hours</h3>
                                            </div>

                                            <div className="space-y-4">
                                                <div>
                                                    <p className="text-sm text-gray-600 mb-2">
                                                        You are merging {pendingMerge?.selectedRows.length} rows for{" "}
                                                        <strong>{pendingMerge?.activity}</strong> in <strong>{pendingMerge?.type.toUpperCase()}</strong>.
                                                    </p>
                                                    <p className="text-sm text-gray-600 mb-4">Enter the total hours for all merged items:</p>
                                                    <Input
                                                        type="number"
                                                        value={mergeHours}
                                                        onChange={(e) => setMergeHours(e.target.value)}
                                                        placeholder="Enter total hours (e.g., 2)"
                                                        step="0.5"
                                                        min="0"
                                                        className="w-full"
                                                        autoFocus
                                                    />
                                                </div>

                                                <div className="flex justify-end gap-2 pt-4">
                                                    <Button
                                                        variant="outline"
                                                        onClick={() => {
                                                            setShowMergeDialog(false)

                                                            setPendingMerge(null)
                                                            setMergeHours("")

                                                        }}
                                                    >
                                                        Cancel
                                                    </Button>
                                                    <Button onClick={confirmMerge} disabled={!mergeHours}>
                                                        {(isMergeConfirm ? "Merging..." : 'Merge Cells')}
                                                    </Button>
                                                </div>
                                            </div>
                                        </motion.div>
                                    </div>
                                )}

                                {/* Controls Card */}
                                <div className="bg-white rounded-lg border border-gray-200 p-2 sm:p-3">
                                    <div className="flex flex-wrap items-center gap-1 sm:gap-2">
                                        {/* Always visible controls - First Row Priority */}
                                        <div className="flex flex-wrap items-center gap-1 sm:gap-2 flex-1 min-w-0">
                                            {/* Help button */}
                                            <button
                                                onClick={() => setShowInstructions(!showInstructions)}
                                                className="p-1 hover:bg-gray-100 cursor-pointer rounded flex-shrink-0"
                                                title="Click to view instructions"
                                            >
                                                <HelpCircle className="w-3 sm:w-4 h-3 sm:h-4 text-gray-600" />
                                            </button>
                                            <MergeButton />
                                            <ValidationFeedback />

                                            <div className="relative inline-block text-left sm:pl-2">
                                                {/* Dropdown Trigger */}
                                                <button
                                                    onClick={() => setIsOpen(!isOpen)}
                                                    disabled={shouldDisableControls}
                                                    className={`group relative inline-flex items-center gap-1.5 px-2.5 py-1.5 text-[11px] sm:text-xs rounded-xl transition-all duration-200 ease-out
    ${shouldDisableControls ? "opacity-50 cursor-not-allowed" : "cursor-pointer"}
    ${isOpen
                                                            ? "bg-gradient-to-r from-indigo-600 via-purple-600 to-indigo-700 text-white shadow-[0_0_6px_rgba(109,40,217,0.3)] ring-1 ring-indigo-400/40"
                                                            : "bg-gradient-to-r from-indigo-500 to-purple-600 text-white hover:shadow-[0_0_8px_rgba(147,51,234,0.25)] focus:ring-1 focus:ring-indigo-300"
                                                        }`}
                                                >
                                                    {/* Soft Border Pulse */}
                                                    <div
                                                        className="absolute inset-0 rounded-lg p-[1px] bg-gradient-to-r from-purple-500/40 to-indigo-500/40 opacity-0 group-hover:opacity-100 blur-[1px] transition-all duration-300"
                                                    />

                                                    {/* Inner Soft Glow */}
                                                    <div className="absolute inset-0 rounded-lg bg-indigo-400/5 group-hover:bg-indigo-500/10 transition-all duration-200" />

                                                    {/* Content */}
                                                    <div className="relative flex items-center gap-1.5 z-10">
                                                        <Settings
                                                            className={`w-3.5 h-3.5 transition-transform duration-300 ${isOpen ? "rotate-[20deg]" : "rotate-0"
                                                                }`}
                                                        />
                                                        <span className="hidden sm:inline tracking-tight">More</span>
                                                        <div
                                                            className={`transition-transform duration-200 ${isOpen ? "rotate-180" : "rotate-0"
                                                                }`}
                                                        >
                                                            <ChevronDownIcon size={12} className="sm:size-3.5" />
                                                        </div>
                                                    </div>
                                                </button>



                                                {/* Dropdown Menu */}
                                                {isOpen && (
                                                    <div className="absolute mt-2 w-56 sm:w-64 bg-white rounded-lg shadow-xl border border-gray-200 z-30 overflow-hidden text-sm">
                                                        {/* Header */}
                                                        <div className="bg-gradient-to-r from-indigo-50 to-white px-3 py-2 border-b border-gray-200">
                                                            <div className="flex items-center gap-1.5">
                                                                <Settings className="w-3.5 h-3.5 text-indigo-600" />
                                                                <h3 className="text-xs font-semibold text-indigo-800">Action Settings</h3>
                                                            </div>
                                                        </div>

                                                        {/* Menu Items */}
                                                        <div className="p-1.5 space-y-1">

                                                            {/* Actions Toggle */}
                                                            <div className={`group p-2 rounded-md hover:bg-green-50 transition-colors duration-150 ${shouldDisableControls ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'} `}>
                                                                <label className={`flex items-center justify-between ${shouldDisableControls ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'} `}>
                                                                    <div className="flex items-center gap-2">
                                                                        <div
                                                                            className={`w-7 h-7 rounded-md flex items-center justify-center transition-colors duration-200 ${actionsEnabled
                                                                                ? "bg-green-100 text-green-600"
                                                                                : "bg-gray-100 text-gray-500"
                                                                                }`}
                                                                        >
                                                                            {actionsEnabled ? (
                                                                                <Check className="w-3.5 h-3.5" />
                                                                            ) : (
                                                                                <Sliders className="w-3.5 h-3.5" />
                                                                            )}
                                                                        </div>
                                                                        <div>
                                                                            <span className="text-xs font-medium text-gray-900">
                                                                                Hierarchy Actions
                                                                            </span>
                                                                            <p className="text-[10px] text-gray-500">Enable all actions</p>
                                                                        </div>
                                                                    </div>
                                                                    <div className="relative">
                                                                        <input
                                                                            type="checkbox"
                                                                            checked={actionsEnabled}
                                                                            disabled={shouldDisableControls}
                                                                            onChange={() => setActionsEnabled(!actionsEnabled)}
                                                                            className="sr-only"
                                                                        />
                                                                        <div
                                                                            className={`w-9 h-4 rounded-full transition-all duration-300 ${actionsEnabled ? "bg-green-500" : "bg-gray-300"
                                                                                } shadow-inner`}
                                                                        >
                                                                            <div
                                                                                className={`w-4 h-4 bg-white rounded-full shadow transition-transform duration-300 transform ${actionsEnabled ? "translate-x-5" : "translate-x-0"
                                                                                    }`}
                                                                            />
                                                                        </div>
                                                                    </div>
                                                                </label>
                                                            </div>

                                                            {/* Divider */}
                                                            <div className="h-px bg-gradient-to-r from-transparent via-gray-200 to-transparent" />
                                                            {/* Direct Actions */}
                                                            <div className={`group p-2 rounded-md hover:bg-indigo-50 transition-colors duration-150 ${shouldDisableControls ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'} `}>
                                                                <label className={`flex items-center justify-between ${shouldDisableControls ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'} `}>
                                                                    <div className="flex items-center gap-2">
                                                                        <div
                                                                            className={`w-7 h-7 rounded-md flex items-center justify-center transition-colors duration-200 ${directActionsEnabled
                                                                                ? "bg-emerald-100 text-emerald-600"
                                                                                : "bg-gray-100 text-gray-500"
                                                                                }`}
                                                                        >
                                                                            {directActionsEnabled ? (
                                                                                <Check className="w-3.5 h-3.5" />
                                                                            ) : (
                                                                                <Sliders className="w-3.5 h-3.5" />
                                                                            )}
                                                                        </div>
                                                                        <div>
                                                                            <span className="text-xs font-medium text-gray-900">
                                                                                Direct Actions
                                                                            </span>
                                                                            <p className="text-[10px] text-gray-500">Enable quick controls</p>
                                                                        </div>
                                                                    </div>
                                                                    <div className="relative">
                                                                        <input
                                                                            type="checkbox"
                                                                            checked={directActionsEnabled}
                                                                            disabled={shouldDisableControls}
                                                                            onChange={() => setDirectActionsEnabled(!directActionsEnabled)}
                                                                            className="sr-only"
                                                                        />
                                                                        <div
                                                                            className={`w-9 h-4 rounded-full transition-all duration-300 ${directActionsEnabled ? "bg-emerald-500" : "bg-gray-300"
                                                                                } shadow-inner`}
                                                                        >
                                                                            <div
                                                                                className={`w-4 h-4 bg-white rounded-full shadow transition-transform duration-300 transform ${directActionsEnabled ? "translate-x-5" : "translate-x-0"
                                                                                    }`}
                                                                            />
                                                                        </div>
                                                                    </div>
                                                                </label>
                                                            </div>

                                                            {/* Divider */}
                                                            <div className="h-px bg-gradient-to-r from-transparent via-gray-200 to-transparent" />

                                                            {/* Multiple Delete */}
                                                            <div className="group p-2 rounded-md hover:bg-red-50 transition-colors duration-150 cursor-pointer">
                                                                <button
                                                                    onClick={() => {
                                                                        setIsOpen(false); // Close dropdown
                                                                        handleMultipleDeleteClick();
                                                                    }}
                                                                    disabled={shouldDisableControls}
                                                                    className={`flex items-center justify-between w-full ${shouldDisableControls ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`}
                                                                >
                                                                    <div className="flex items-center gap-2">
                                                                        <div className="w-7 h-7 rounded-md flex items-center justify-center bg-red-100 text-red-600">
                                                                            <Trash2 className="w-3.5 h-3.5" />
                                                                        </div>
                                                                        <div>
                                                                            <span className="text-xs font-medium text-gray-900">
                                                                                Multiple Delete
                                                                            </span>
                                                                            <p className="text-[10px] text-gray-500">Delete multiple items</p>
                                                                        </div>
                                                                    </div>
                                                                    <div className={`px-2 py-1 text-[10px] font-medium rounded-full transition-colors ${shouldDisableControls
                                                                        ? 'bg-gray-200 text-gray-400'
                                                                        : 'bg-red-100 text-red-600 hover:bg-red-200'
                                                                        }`}>
                                                                        Enable
                                                                    </div>
                                                                </button>
                                                            </div>
                                                        </div>

                                                        {/* Footer */}
                                                        <div className="bg-gray-50 px-3 py-1.5 border-t border-gray-200">
                                                            <p className="text-[10px] text-gray-500 text-center">
                                                                Configure your preferences
                                                            </p>
                                                        </div>
                                                    </div>
                                                )}

                                                {/* Click outside to close */}
                                                {isOpen && (
                                                    <div
                                                        className="fixed inset-0 z-20"
                                                        onClick={() => setIsOpen(false)}
                                                        aria-hidden="true"
                                                    />
                                                )}
                                            </div>
                                            <button
                                                onClick={() => {
                                                    setDuplicateChecked(!duplicateChecked);
                                                    if (!duplicateChecked) {
                                                        setShowDuplicatePopup(true);
                                                    }
                                                }}
                                                className={`group relative inline-flex items-center gap-1.5 px-3 py-1.5 text-xs sm:text-sm rounded-xl transition-all duration-200 ease-out 
                    shadow-sm cursor-pointer hover:shadow-md focus:outline-none focus:ring-1 focus:ring-offset-1
                    ${duplicateChecked
                                                        ? "bg-gradient-to-r from-blue-600 to-blue-700 text-white ring-1 ring-blue-400"
                                                        : "bg-gradient-to-r from-blue-500 to-blue-600 text-white hover:from-blue-600 hover:to-blue-700 focus:ring-blue-300"
                                                    }`}
                                            >
                                                {/* Glow */}
                                                <div className="absolute inset-0 rounded-md bg-blue-400 opacity-0 group-hover:opacity-10 transition-opacity duration-200" />

                                                {/* Content */}
                                                <div className="relative flex text-xs items-center gap-1.5">
                                                    <Copy className="w-3 h-3 sm:w-4 sm:h-4" />
                                                    <span className="hidden sm:inline">Similar Courses</span>
                                                    <span className="sm:hidden">Similar</span>
                                                </div>
                                            </button>
                                            {/* Module Selection Dropdown */}
                                            <div className="flex items-center gap-1 sm:gap-2">
                                                <div className="relative w-full sm:w-[180px]">
                                                    <Select
                                                        value={selectedModuleToHighlight || ""}
                                                        onValueChange={(value) => {
                                                            setSelectedModuleToHighlight(value);
                                                            // Scroll to the module
                                                            setTimeout(() => {
                                                                const moduleElement = document.querySelector(`[data-module-id="${value}"]`);
                                                                if (moduleElement) {
                                                                    moduleElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                                                }
                                                            }, 100);
                                                        }}
                                                        disabled={shouldDisableControls}
                                                    >
                                                        <SelectTrigger className="w-full h-6 sm:h-7 text-[9px] sm:text-xs">
                                                            <SelectValue placeholder="Select module" />
                                                        </SelectTrigger>
                                                        <SelectContent>
                                                            {/* Search input */}
                                                            <div className="p-2 border-b">
                                                                <input
                                                                    type="text"
                                                                    placeholder="Search modules..."
                                                                    value={moduleSearchQuery}
                                                                    onChange={(e) => setModuleSearchQuery(e.target.value)}
                                                                    className="w-full p-1 text-xs border rounded focus:outline-none focus:ring-1 focus:ring-blue-500"
                                                                    onClick={(e) => e.stopPropagation()}
                                                                />
                                                            </div>

                                                            {/* Module list */}
                                                            <div className="max-h-60 overflow-auto">
                                                                {sortedModules
                                                                    .filter(module =>
                                                                        module.title.toLowerCase().includes(moduleSearchQuery.toLowerCase())
                                                                    )
                                                                    .map((module) => (
                                                                        <SelectItem
                                                                            key={module._id}
                                                                            value={module._id}
                                                                            className="text-xs"
                                                                        >
                                                                            <div className="flex items-center gap-2">
                                                                                <div className="w-2 h-2 rounded-full bg-blue-500 flex-shrink-0"></div>
                                                                                <span className="truncate">{module.title}</span>
                                                                            </div>
                                                                        </SelectItem>
                                                                    ))
                                                                }
                                                                {sortedModules.filter(module =>
                                                                    module.title.toLowerCase().includes(moduleSearchQuery.toLowerCase())
                                                                ).length === 0 && (
                                                                        <div className="px-3 py-2 text-xs text-gray-500 text-center">
                                                                            No modules found
                                                                        </div>
                                                                    )}
                                                            </div>

                                                            {/* Clear selection */}
                                                            {selectedModuleToHighlight && (
                                                                <>
                                                                    <div className="border-t mt-1"></div>
                                                                    <div
                                                                        className="px-3 py-2 text-xs text-red-600 hover:bg-red-50 cursor-pointer"
                                                                        onClick={() => setSelectedModuleToHighlight(null)}
                                                                    >
                                                                        Clear selection
                                                                    </div>
                                                                </>
                                                            )}
                                                        </SelectContent>
                                                    </Select>

                                                    {/* Clear button (shown when module is selected) */}
                                                    {selectedModuleToHighlight && (
                                                        <button
                                                            onClick={() => setSelectedModuleToHighlight(null)}
                                                            className="absolute right-6 top-1/2 transform -translate-y-1/2 p-0.5 hover:bg-gray-200 rounded"
                                                            title="Clear module selection"
                                                        >
                                                            <X className="w-3 h-3 text-gray-500" />
                                                        </button>
                                                    )}
                                                </div>
                                            </div>
                                        </div>

                                        {/* Teaching Elements dropdown - Right side on larger screens, new line on smaller */}
                                        <div className="flex items-center gap-1 sm:gap-2 w-full sm:w-auto sm:ml-auto min-w-0 mt-1 sm:mt-0">

                                            <Label htmlFor="pedagogy-type" className={`text-[9px] sm:text-xs font-medium whitespace-nowrap flex-shrink-0  ${shouldDisableControls ? "opacity-50 cursor-not-allowed" : ""}`}>
                                                <span className="hidden md:inline">Teaching Elements:</span>
                                                <span className="md:hidden">Elements:</span>
                                            </Label>
                                            <Select
                                                value=""
                                                onValueChange={() => { }}
                                                disabled={shouldDisableControls}
                                            >
                                                <SelectTrigger className="w-full sm:w-[160px] md:w-[200px] h-6 sm:h-7 text-[9px] sm:text-xs min-w-0" disabled={shouldDisableControls}>
                                                    <SelectValue placeholder={
                                                        selectedPedagogyTypes.length === 0
                                                            ? "Select elements"
                                                            : selectedPedagogyTypes.includes("iDo") &&
                                                                selectedPedagogyTypes.includes("weDo") &&
                                                                selectedPedagogyTypes.includes("youDo")
                                                                ? "All Elements"
                                                                : `${selectedPedagogyTypes.length} selected`
                                                    } />
                                                </SelectTrigger>
                                                <SelectContent>
                                                    <div
                                                        className="flex items-center space-x-2 p-2 hover:bg-gray-100"
                                                        onClick={(e) => e.stopPropagation()}
                                                    >
                                                        <Checkbox
                                                            id="pedagogy-all"
                                                            checked={
                                                                selectedPedagogyTypes.includes("iDo") &&
                                                                selectedPedagogyTypes.includes("weDo") &&
                                                                selectedPedagogyTypes.includes("youDo")
                                                            }
                                                            onCheckedChange={(checked) => {
                                                                setSelectedPedagogyTypes(checked ? ["iDo", "weDo", "youDo"] : []);
                                                            }}
                                                        />
                                                        <label
                                                            htmlFor="pedagogy-all"
                                                            className="text-xs font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
                                                        >
                                                            All Teaching Elements
                                                        </label>
                                                    </div>
                                                    {["iDo", "weDo", "youDo"].map((type) => (
                                                        <div
                                                            key={type}
                                                            className="flex items-center space-x-2 p-2 hover:bg-gray-100"
                                                            onClick={(e) => e.stopPropagation()}
                                                        >
                                                            <Checkbox
                                                                id={`pedagogy-${type}`}
                                                                checked={selectedPedagogyTypes.includes(type as any)}
                                                                onCheckedChange={(checked) => {
                                                                    setSelectedPedagogyTypes(prev =>
                                                                        checked
                                                                            ? [...prev.filter(t => t !== "all"), type as "iDo" | "weDo" | "youDo"]
                                                                            : prev.filter(t => t !== type)
                                                                    );
                                                                }}
                                                            />
                                                            <label
                                                                htmlFor={`pedagogy-${type}`}
                                                                className="text-xs font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
                                                            >
                                                                {type === "iDo" ? "I Do Activities" :
                                                                    type === "weDo" ? "We Do Activities" : "You Do Activities"}
                                                            </label>
                                                        </div>
                                                    ))}
                                                </SelectContent>
                                            </Select>

                                        </div>
                                        {/* Utility Buttons */}

                                        <div className="flex items-center gap-1 sm:gap-2 flex-wrap">
                                            <button
                                                className={`flex  items-center gap-1 text-[9px] sm:text-[10px] h-6 sm:h-7 px-1 sm:px-2 whitespace-nowrap
 ${selectedCourse && !shouldDisableControls
                                                        ? "bg-gradient-to-r from-orange-400 via-orange-500 to-orange-600 cursor-pointer text-white hover:brightness-110 hover:text-white shadow"
                                                        : "bg-gray-200 text-gray-400 cursor-not-allowed"
                                                    }
  rounded-full transition-colors duration-300`}

                                                title={selectedCourse ? "Click to view summary" : "Select a course to view summary"}
                                                onClick={() => setShowSummaryDialog(true)}
                                                disabled={!selectedCourse || shouldDisableControls}
                                            >
                                                <Eye className="w-3 h-3 flex-shrink-0" />
                                                <span className="hidden sm:inline">View Summary</span>
                                                <span className="sm:hidden">Summary</span>
                                            </button>

                                        </div>
                                        <button
                                            className={`flex items-center gap-1 text-[9px] sm:text-[10px] h-6 sm:h-7 px-2 sm:px-3 whitespace-nowrap
            ${selectedCourse && !shouldDisableControls
                                                    ? "bg-gradient-to-r from-blue-500 to-blue-600 cursor-pointer text-white hover:from-blue-600 hover:to-blue-700 shadow-md"
                                                    : "bg-gray-100 text-gray-400 cursor-not-allowed"
                                                }
            rounded-full transition-all duration-200 ease-in-out transform hover:scale-[1.02]`}
                                            title={selectedCourse ? "Click to preview course structure" : "Select a course to preview"}
                                            onClick={() => setShowMainFullPreviewDialog(true)}
                                            disabled={!selectedCourse || shouldDisableControls}
                                        >
                                            <Eye className="w-3 h-3 flex-shrink-0" />
                                            <span className="hidden sm:inline">Preview</span>
                                            <span className="sm:hidden">Preview</span>
                                        </button>

                                        <div className="flex items-center gap-1 sm:gap-2 flex-wrap">
                                            <button
                                                className={`flex  items-center gap-1 text-[9px] sm:text-[10px] h-6 sm:h-7 px-2 sm:px-3 whitespace-nowrap
    ${selected && !shouldDisableControls
                                                        ? "bg-gradient-to-r from-indigo-500 to-purple-600 cursor-pointer text-white hover:from-indigo-600 hover:to-purple-700 shadow-md"
                                                        : "bg-gray-100 text-gray-400 cursor-not-allowed"
                                                    }
      rounded-full transition-all duration-200 ease-in-out transform hover:scale-[1.02]`}
                                                title={selected ? "Click to preview" : "Select an item to preview"}
                                                onClick={() => setShowPreviewDialog(true)}
                                                disabled={!selected || shouldDisableControls}
                                            >
                                                <Eye className="w-3 h-3 flex-shrink-0" />
                                                <span className="hidden sm:inline">Print</span>
                                                <span className="sm:hidden">Print</span>
                                            </button>
                                        </div>

                                    </div>
                                </div>

                                {/* Main Course Structure Table */}
                                <div
                                    className="relative overflow-hidden"
                                    style={{
                                        // Dynamic height based on scaled content
                                        height: contentHeight ? `${contentHeight * tableZoomLevel}px` : 'auto',
                                        minHeight: 'fit-content'
                                    }}
                                >
                                    <div
                                        ref={scaledContentRef}
                                        className="origin-top-left"
                                        style={{
                                            transform: `scale(${tableZoomLevel})`,
                                            transformOrigin: "top left",
                                            width: `${100 / tableZoomLevel}%`,
                                            // Dynamic negative margin based on actual content height and zoom
                                            marginBottom: `${calculateNegativeMargin()}px`
                                        }}
                                    >
                                        <div
                                            className={`bg-white rounded-xl shadow-sm border border-gray-200 relative flex flex-col`}
                                            style={{
                                                maxHeight: '70vh', // Fixed height for the entire table container
                                            }}
                                        >
                                            <div className="flex-none">
                                                <div className="sticky top-0 z-30 bg-white border-b border-gray-200">
                                                    <div className="overflow-x-auto">
                                                        <Table className="border-separate border-spacing-0 min-w-full" style={{ tableLayout: 'fixed' }}>
                                                            <TableHeader className="bg-white">
                                                                {/* Main Headers */}
                                                                <TableRow className="bg-blue-100">


                                                                    {/* Dynamic hierarchy columns */}
                                                                    {selectedCourse.courseHierarchy.map((level, index) => (
                                                                        <TableHead
                                                                            key={level}
                                                                            className={`border border-gray-400 overflow-hidden text-center font-bold text-xs p-1 bg-blue-100 z-10`}
                                                                            style={{

                                                                                ...(hierarchyWidthPercentage ? { width: `${hierarchyWidthPercentage}%` } : {})
                                                                            }}
                                                                            rowSpan={3}
                                                                        >
                                                                            <div className="flex items-center justify-center gap-1 group">
                                                                                {level}
                                                                                {/* Add Module button */}
                                                                                {level === 'Module' && (
                                                                                    <div className="relative">
                                                                                        <button
                                                                                            onClick={() => {
                                                                                                setDialogType('module');
                                                                                                setShowDialog(true);
                                                                                            }}
                                                                                            className="flex items-center justify-center p-1 cursor-pointer rounded-full bg-blue-500 hover:bg-blue-600 transition-all duration-200 shadow-lg relative z-10"
                                                                                            title="Add module"
                                                                                        >
                                                                                            <Plus className="w-4 h-4 text-white" />
                                                                                        </button>
                                                                                        <div className="absolute inset-0 rounded-full border-2 border-blue-300 animate-ping"></div>
                                                                                    </div>
                                                                                )}

                                                                            </div>
                                                                        </TableHead>
                                                                    ))}
                                                                    <AnimatePresence>
                                                                        <motion.th
                                                                            key="level-header"
                                                                            variants={popAnimation}
                                                                            initial="initial"
                                                                            className={`border border-gray-400 text-center font-bold text-xs p-1 bg-blue-100 z-10 min-w-[80px]`}

                                                                            rowSpan={3}
                                                                        >
                                                                            Level
                                                                        </motion.th>
                                                                    </AnimatePresence>
                                                                    {/* Teaching Learning Elements header - only shown if any activities exist */}
                                                                    {selectedPedagogyTypes.length > 0 && (activityTypes["iDo"].length > 0 || activityTypes["weDo"].length > 0 || activityTypes["youDo"].length > 0) && (
                                                                        <TableHead
                                                                            className={`border border-gray-400 text-center bg-blue-100 font-bold text-xs p-1 min-w-[900px] transition-all duration-300 `}
                                                                            colSpan={
                                                                                (selectedPedagogyTypes.includes("iDo") ? activityTypes["iDo"].length : 0) +
                                                                                (selectedPedagogyTypes.includes("weDo") ? activityTypes["weDo"].length : 0) +
                                                                                (selectedPedagogyTypes.includes("youDo") ? activityTypes["youDo"].length : 0)
                                                                            }
                                                                        >
                                                                            {selectedPedagogyTypes.includes("iDo") && selectedPedagogyTypes.includes("weDo") && selectedPedagogyTypes.includes("youDo") &&
                                                                                activityTypes["iDo"].length > 0 && activityTypes["weDo"].length > 0 && activityTypes["youDo"].length > 0
                                                                                ? "All Teaching Elements"
                                                                                : selectedPedagogyTypes.map(type => {
                                                                                    // Only show the pedagogy type if it has activities
                                                                                    if (activityTypes[type] && activityTypes[type].length > 0) {
                                                                                        return type === "iDo" ? "I Do Activities" :
                                                                                            type === "weDo" ? "We Do Activities" : "You Do Activities";
                                                                                    }
                                                                                    return null;
                                                                                }).filter(Boolean).join(" + ") // Filter out null values and join with "+"
                                                                            }
                                                                        </TableHead>
                                                                    )}
                                                                </TableRow>
                                                                {/* Activity Type Headers - only shown if activities exist */}
                                                                {selectedPedagogyTypes.length > 1 && (
                                                                    <TableRow className="bg-gray-100">
                                                                        {selectedPedagogyTypes.includes("iDo") && activityTypes["iDo"].length > 0 && (
                                                                            <TableHead
                                                                                colSpan={activityTypes["iDo"].length}
                                                                                className={`border border-gray-400 text-center font-medium text-[9px] p-0.5 bg-yellow-100 transition-all duration-300 `}
                                                                            >
                                                                                I Do Activities
                                                                            </TableHead>
                                                                        )}
                                                                        {selectedPedagogyTypes.includes("weDo") && activityTypes["weDo"].length > 0 && (
                                                                            <TableHead
                                                                                colSpan={activityTypes["weDo"].length}
                                                                                className={`border border-gray-400 text-center font-medium text-[9px] p-0.5 bg-orange-100 transition-all duration-300 `}
                                                                            >
                                                                                We Do Activities
                                                                            </TableHead>
                                                                        )}
                                                                        {selectedPedagogyTypes.includes("youDo") && activityTypes["youDo"].length > 0 && (
                                                                            <TableHead
                                                                                colSpan={activityTypes["youDo"].length}
                                                                                className={`border border-gray-400 text-center font-medium text-[9px] p-0.5 bg-green-100 transition-all duration-300 `}
                                                                            >
                                                                                You Do Activities
                                                                            </TableHead>
                                                                        )}
                                                                    </TableRow>
                                                                )}

                                                                {/* Replace the activity type headers with: */}
                                                                {selectedPedagogyTypes.length > 0 && (
                                                                    <TableRow className="bg-gray-100">
                                                                        {selectedPedagogyTypes.includes("iDo") && activityTypes["iDo"].map((activity) => (
                                                                            <TableHead
                                                                                key={`iDo-${activity}`}
                                                                                className={`
      border border-gray-400 text-center font-medium text-[9px] p-0.5 bg-yellow-100 
      transition-all duration-300 
      truncate hover:overflow-visible hover:whitespace-normal hover:z-50 hover:min-w-[120px]
    `}
                                                                                title={activity}
                                                                            >
                                                                                {activity}
                                                                            </TableHead>
                                                                        ))}
                                                                        {selectedPedagogyTypes.includes("weDo") && activityTypes["weDo"].map((activity) => (
                                                                            <TableHead
                                                                                key={`weDo-${activity}`}
                                                                                className={`
      border border-gray-400 text-center font-medium text-[9px] p-0.5 bg-orange-100 
      transition-all duration-300 
      truncate hover:overflow-visible hover:whitespace-normal hover:z-50 hover:min-w-[120px]
    `}
                                                                                title={activity}
                                                                            >
                                                                                {activity}
                                                                            </TableHead>
                                                                        ))}
                                                                        {selectedPedagogyTypes.includes("youDo") && activityTypes["youDo"].map((activity) => (
                                                                            <TableHead
                                                                                key={`youDo-${activity}`}
                                                                                className={`
      border border-gray-400 text-center font-medium text-[9px] p-0.5 bg-green-100 
      transition-all duration-300 
      truncate hover:overflow-visible hover:whitespace-normal hover:z-50 hover:min-w-[120px]
    `}
                                                                                title={activity}
                                                                            >
                                                                                {activity}
                                                                            </TableHead>
                                                                        ))}
                                                                    </TableRow>
                                                                )}

                                                            </TableHeader>
                                                        </Table>
                                                    </div>
                                                </div>
                                            </div>
                                            {/* <div className="flex-1 overflow-auto [&::-webkit-scrollbar]:hidden"> */}
                                            <div className="flex-1 overflow-auto [&::-webkit-scrollbar]:hidden">
                                                <Table className="border-separate border-spacing-0 min-w-full" style={{ tableLayout: 'fixed' }}>
                                                    {/* Hidden header for column alignment */}
                                                    <TableHeader className="invisible" style={{ height: '0px', lineHeight: '0px' }}>
                                                        <TableRow style={{ height: '0px' }}>
                                                            {selectedCourse.courseHierarchy.map((level, index) => (
                                                                <TableHead
                                                                    key={`hidden-${level}`}
                                                                    className="border-0 p-0"
                                                                    style={{
                                                                        height: '0px',
                                                                        lineHeight: '0px',
                                                                        ...(hierarchyWidthPercentage ? { width: `${hierarchyWidthPercentage}%` } : { minWidth: '120px' })
                                                                    }}
                                                                />
                                                            ))}
                                                            <TableHead className="border-0 p-0" style={{
                                                                height: '0px',
                                                                lineHeight: '0px',
                                                                minWidth: '80px'
                                                            }} />
                                                            {selectedPedagogyTypes.length > 0 && (
                                                                <>
                                                                    {selectedPedagogyTypes.includes("iDo") && activityTypes["iDo"].map((activity) => (
                                                                        <TableHead key={`hidden-iDo-${activity}`} className="border-0 p-0" style={{
                                                                            height: '0px',
                                                                            lineHeight: '0px',
                                                                            minWidth: '70px'
                                                                        }} />
                                                                    ))}
                                                                    {selectedPedagogyTypes.includes("weDo") && activityTypes["weDo"].map((activity) => (
                                                                        <TableHead key={`hidden-weDo-${activity}`} className="border-0 p-0" style={{
                                                                            height: '0px',
                                                                            lineHeight: '0px',
                                                                            minWidth: '70px'
                                                                        }} />
                                                                    ))}
                                                                    {selectedPedagogyTypes.includes("youDo") && activityTypes["youDo"].map((activity) => (
                                                                        <TableHead key={`hidden-youDo-${activity}`} className="border-0 p-0" style={{
                                                                            height: '0px',
                                                                            lineHeight: '0px',
                                                                            minWidth: '70px'
                                                                        }} />
                                                                    ))}
                                                                </>
                                                            )}
                                                        </TableRow>
                                                    </TableHeader>

                                                    <TableBody>
                                                        {(() => {
                                                            const moduleRowTracker: { [key: string]: boolean } = {};
                                                            const subModuleRowTracker: { [key: string]: boolean } = {};
                                                            const topicRowTracker: { [key: string]: boolean } = {};
                                                            const subtopicRowTracker: { [key: string]: boolean } = {};

                                                            return tableRows.map((row, index) => {
                                                                const isFirstSubtopicInModule = !moduleRowTracker[row.moduleId]
                                                                const isFirstSubtopicInSubModule = !subModuleRowTracker[row.subModuleId];
                                                                const isFirstSubtopicInTopic = !topicRowTracker[row.topicId]
                                                                const isFirstSubtopicInSubtopic = !subtopicRowTracker[row.subtopicId];

                                                                if (isFirstSubtopicInModule) {
                                                                    moduleRowTracker[row.moduleId] = true
                                                                }
                                                                if (isFirstSubtopicInSubModule) subModuleRowTracker[row.subModuleId] = true;
                                                                if (isFirstSubtopicInTopic) {
                                                                    topicRowTracker[row.topicId] = true
                                                                }
                                                                if (isFirstSubtopicInSubtopic) subtopicRowTracker[row.subtopicId] = true;


                                                                return (
                                                                    <motion.tr
                                                                        key={`${row.moduleId}-${row.topicId}-${row.subtopicId}`}
                                                                        className="hover:bg-gray-50 h-6"
                                                                        initial={{ opacity: 0, y: 10 }}
                                                                        animate={{ opacity: 1, y: 0 }}
                                                                        transition={{ duration: 0.2, delay: index * 0.01 }}
                                                                        layout // This enables smooth layout animations when rows change
                                                                    >

                                                                        {/* Module Cell */}
                                                                        {/* Module Cell */}
                                                                        {selectedCourse.courseHierarchy.includes('Module') && isFirstSubtopicInModule && (
                                                                            <TableCell
                                                                                data-module-id={row.moduleId} // Add this data attribute for scrolling
                                                                                rowSpan={moduleSpans[row.moduleId]}
                                                                                draggable={!isDefaultItem(row.moduleName)}
                                                                                onDragStart={(e) => handleModuleDragStart(e, row.moduleId)}
                                                                                onDragOver={(e) => handleDragOver(e, row.moduleId, 'module')}
                                                                                onDragEnd={handleModuleDragEnd}
                                                                                title={`Enable actions to edit, delete, or change the position of "${row.moduleName}"`}
                                                                                onDrop={(e) => handleModuleDrop(e, row.moduleId)}
                                                                                className={`border border-gray-400 p-1.5 bg-blue-50 align-middle
     z-10 
    text-[12px] font-medium text-gray-800 tracking-wide
      ${draggingModuleId === row.moduleId ? 'opacity-30 bg-gray-200' : ''} 
      ${dragOverId === row.moduleId ? 'border-t-2 border-blue-500' : ''}
      ${movableCell && !isCellMovable('module', row.moduleId) ? 'opacity-50' : ''}
      ${isCellMovable('module', row.moduleId) ? 'border-2 border-blue-500 cursor-grab hover:bg-blue-100' : ''}
      ${selectedModuleToHighlight === row.moduleId ? 'bg-blue-100 shadow-lg' : ''} // Highlight style
    `}
                                                                            >
                                                                                <div
                                                                                    className={`relative flex items-center justify-center w-full ${actionsEnabled && !isDefaultItem(row.moduleName) ? 'py-1.5' : ''}`}
                                                                                >
                                                                                    {/* Highlight indicator */}
                                                                                    {selectedModuleToHighlight === row.moduleId && (
                                                                                        <div className="absolute -left-1 top-1/2 transform -translate-y-1/2">
                                                                                            <div className="w-2 h-2 rounded-full bg-blue-500 animate-pulse"></div>
                                                                                        </div>
                                                                                    )}

                                                                                    {deleteMode.type === 'module' && !isDefaultItem(row.moduleName) && (
                                                                                        <div className="flex-[0.1] flex justify-start mr-1">
                                                                                            <input
                                                                                                type="checkbox"
                                                                                                checked={deleteMode.selectedItems.has(row.moduleId)}
                                                                                                onChange={(e) => handleDeleteModeSelection(row.moduleId, e.target.checked)}
                                                                                                className="w-3.5 h-3.5 cursor-pointer accent-red-500"
                                                                                            />
                                                                                        </div>
                                                                                    )}
                                                                                    <span
                                                                                        className="flex-[0.8] text-center px-2 break-words whitespace-normal overflow-hidden text-ellipsis"
                                                                                    >
                                                                                        {row.moduleName === "Default Module" ? "-" : row.moduleName}
                                                                                    </span>

                                                                                    {actionsEnabled && !isDefaultItem(row.moduleName) && deleteMode.type !== 'module' && (
                                                                                        <div className="flex-[0.2] flex justify-end">
                                                                                            <CellActionsMenu
                                                                                                row={row}
                                                                                                type="module"
                                                                                                onEdit={() => {
                                                                                                    const module = modules.find(m => m._id === row.moduleId);
                                                                                                    if (module) handleEdit('module', module);
                                                                                                }}
                                                                                                onDelete={() => handleDeleteClick('module', row.moduleId)}
                                                                                                onEnableDrag={() => {
                                                                                                    setMovableCell({ type: 'module', id: row.moduleId })
                                                                                                    setIsMoveModeActive(true)
                                                                                                }}
                                                                                                onMultipleDelete={() => activateHierarchicalDeleteMode('module', row.moduleId)}
                                                                                            />
                                                                                        </div>
                                                                                    )}
                                                                                </div>
                                                                            </TableCell>
                                                                        )}
                                                                        {/* SubModule Cell */}
                                                                        {selectedCourse.courseHierarchy.includes('Sub Module') && isFirstSubtopicInSubModule && (
                                                                            <TableCell
                                                                                rowSpan={subModuleSpans[row.subModuleId]}
                                                                                draggable={!isDefaultItem(row.subModuleName)}
                                                                                onDragStart={(e) => handleSubModuleDragStart(e, row.subModuleId)}
                                                                                onDragOver={(e) => handleDragOver(e, row.subModuleId, 'submodule')}
                                                                                onDragEnd={handleSubModuleDragEnd}
                                                                                onDrop={(e) => handleSubModuleDrop(e, row.subModuleId)}
                                                                                title={`Enable actions to edit, delete, or change the position of "${row.subModuleName}"`}

                                                                                className={`border border-gray-400 p-1.5 bg-blue-50 align-middle
     z-10 left-[120px]
    text-[12px] font-medium text-gray-800 tracking-wide
                                                                                    
                                                                                   
                                                                                       ${draggingSubModuleId === row.subModuleId ? 'opacity-30 bg-gray-200' : ''} 
            ${dragOverId === row.subModuleId ? 'border-t-2 border-blue-500' : ''}
            ${movableCell && !isCellMovable('submodule', row.subModuleId) ? 'opacity-50' : ''}
  ${isCellMovable('submodule', row.subModuleId) ? 'border-2 border-blue-500 cursor-grab hover:bg-blue-100' : ''}
                                                                                    `}
                                                                            >
                                                                                <div className={`relative flex items-center justify-center w-full ${actionsEnabled && !isDefaultItem(row.subModuleName) ? 'py-1.5' : ''}`}>
                                                                                    {/* Checkbox for delete mode */}
                                                                                    {(deleteMode.type === 'submodule' && !hierarchicalDeleteMode && !isDefaultItem(row.subModuleName)) ||
                                                                                        (shouldShowHierarchicalCheckbox('submodule', row.subModuleId) && !isDefaultItem(row.subModuleName)) ? (
                                                                                        <div className="flex-[0.1] flex justify-start mr-1">
                                                                                            <input
                                                                                                type="checkbox"
                                                                                                checked={deleteMode.selectedItems.has(row.subModuleId)}
                                                                                                onChange={(e) => handleDeleteModeSelection(row.subModuleId, e.target.checked)}
                                                                                                className="w-3.5 h-3.5 cursor-pointer accent-red-500"
                                                                                            />
                                                                                        </div>
                                                                                    ) : null}
                                                                                    {actionsEnabled && isDefaultItem(row.subModuleName) ? (
                                                                                        <AddCellButton
                                                                                            onClick={() => {
                                                                                                const parentModule = modules.find(m => m._id === row.moduleId);
                                                                                                if (parentModule) {
                                                                                                    setSelectedModuleForSubModule({
                                                                                                        id: parentModule._id,
                                                                                                        name: parentModule.title
                                                                                                    });
                                                                                                    setDialogType('submodule');
                                                                                                    setShowDialog(true);
                                                                                                }
                                                                                            }}
                                                                                            label="Sub Module"
                                                                                        />
                                                                                    ) : (
                                                                                        <>
                                                                                            <span className="flex-[0.8] text-center px-2 break-words whitespace-normal overflow-hidden text-ellipsis">
                                                                                                {row.subModuleName}
                                                                                            </span>
                                                                                            {actionsEnabled && !isDefaultItem(row.subModuleName) && deleteMode.type !== 'submodule' && (
                                                                                                <div className="flex-[0.2] flex justify-end">
                                                                                                    <CellActionsMenu
                                                                                                        row={row}
                                                                                                        type="submodule"
                                                                                                        onAdd={() => {
                                                                                                            const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];
                                                                                                            const hasSubModules = hierarchyLevels.includes('sub module');

                                                                                                            if (hasSubModules) {
                                                                                                                const parentModule = modules.find(m => m._id === row.moduleId);
                                                                                                                if (parentModule) {
                                                                                                                    setSelectedModuleForSubModule({
                                                                                                                        id: parentModule._id,
                                                                                                                        name: parentModule.title
                                                                                                                    });
                                                                                                                    setDialogType('submodule');
                                                                                                                    setShowDialog(true);
                                                                                                                }
                                                                                                            } else {
                                                                                                                const parentModule = modules.find(m => m._id === row.moduleId);
                                                                                                                if (parentModule) {
                                                                                                                    setSelectedSubModuleForTopic({
                                                                                                                        id: parentModule._id,
                                                                                                                        moduleId: parentModule._id,
                                                                                                                        name: parentModule.title
                                                                                                                    });
                                                                                                                    setDialogType('topic');
                                                                                                                    setShowDialog(true);
                                                                                                                }
                                                                                                            }
                                                                                                        }}
                                                                                                        onEdit={() => {
                                                                                                            const subModule = subModules.find(sm => sm._id === row.subModuleId);
                                                                                                            if (subModule) handleEdit("submodule", subModule);
                                                                                                        }}
                                                                                                        onDelete={() => handleDeleteClick("submodule", row.subModuleId)}
                                                                                                        onEnableDrag={() => {
                                                                                                            setMovableCell({ type: 'submodule', id: row.subModuleId });
                                                                                                            setIsMoveModeActive(true);
                                                                                                        }}
                                                                                                        onMultipleDelete={() => activateHierarchicalDeleteMode('submodule', row.subModuleId)}
                                                                                                        addLabel={selectedCourse?.courseHierarchy.includes('Sub Module') ? 'New Sub Module' : 'New Topic'}
                                                                                                    />
                                                                                                </div>
                                                                                            )}
                                                                                        </>
                                                                                    )}
                                                                                </div>
                                                                            </TableCell>
                                                                        )}
                                                                        {/* Topic Cell */}
                                                                        {selectedCourse.courseHierarchy.includes("Topic") && isFirstSubtopicInTopic && (
                                                                            <TableCell
                                                                                rowSpan={topicSpans[row.topicId]}
                                                                                draggable={!isDefaultItem(row.topicName)}
                                                                                title={`Enable actions to edit, delete, or change the position of "${row.topicName}"`}

                                                                                onDragStart={(e) => handleTopicDragStart(e, row.topicId)}
                                                                                onDragOver={(e) => handleDragOver(e, row.topicId, 'topic')}
                                                                                onDragEnd={handleTopicDragEnd}
                                                                                onDrop={(e) => handleTopicDrop(e, row.topicId)}
                                                                                className={`border border-gray-400 text-center font-medium text-gray-800 tracking-wide p-1.5 bg-blue-50 align-middle text-[12px]  z-10 ${selectedCourse.courseHierarchy.includes("Sub Module") ? "left-[120px] " : "left-[120px] "
                                                                                    }
                                                                                     ${draggingTopicId === row.topicId ? 'opacity-30 bg-gray-200' : ''} 
            ${dragOverId === row.topicId ? 'border-t-2 border-blue-500' : ''}
           ${movableCell && !isCellMovable('topic', row.topicId) ? 'opacity-50' : ''}
  ${isCellMovable('topic', row.topicId) ? 'border-2 border-blue-500 cursor-grab hover:bg-blue-100' : ''}
                                                                                    `}
                                                                            >

                                                                                <div className={`relative flex items-center justify-center w-full ${actionsEnabled && !isDefaultItem(row.topicName) ? 'py-1.5' : ''}`}>
                                                                                    {/* Checkbox for delete mode */}
                                                                                    {(deleteMode.type === 'topic' && !hierarchicalDeleteMode && !isDefaultItem(row.topicName)) ||
                                                                                        (shouldShowHierarchicalCheckbox('topic', row.topicId) && !isDefaultItem(row.topicName)) ? (
                                                                                        <div className="flex-[0.1] flex justify-start mr-1">
                                                                                            <input
                                                                                                type="checkbox"
                                                                                                checked={deleteMode.selectedItems.has(row.topicId)}
                                                                                                onChange={(e) => handleDeleteModeSelection(row.topicId, e.target.checked)}
                                                                                                className="w-3.5 h-3.5 cursor-pointer accent-red-500"
                                                                                            />
                                                                                        </div>
                                                                                    ) : null}
                                                                                    {actionsEnabled && isDefaultItem(row.topicName) ? (
                                                                                        <AddCellButton
                                                                                            onClick={() => {
                                                                                                const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];
                                                                                                const hasSubModules = hierarchyLevels.includes('sub module');

                                                                                                if (hasSubModules) {
                                                                                                    // Parent is submodule
                                                                                                    const parentSubModule = subModules.find(sm => sm._id === row.subModuleId);
                                                                                                    if (parentSubModule) {
                                                                                                        setSelectedSubModuleForTopic({
                                                                                                            id: parentSubModule._id,
                                                                                                            moduleId: parentSubModule.moduleId,
                                                                                                            name: parentSubModule.title
                                                                                                        });
                                                                                                        setDialogType('topic');
                                                                                                        setDisableAddonlyMode(false);
                                                                                                        setShowDialog(true);
                                                                                                    } else if (isLastHierarchy2("topic")) {
                                                                                                        setSelectedSubModuleForTopic({
                                                                                                            id: null,
                                                                                                            moduleId: row.moduleId || 'orphaned',
                                                                                                            name: '-'
                                                                                                        });
                                                                                                        setDialogType('topic');
                                                                                                        setShowDialog(true);
                                                                                                        setDisableAddonlyMode(true);
                                                                                                        setAddOnlyPedagogyLevel(true); // Force pedagogy/level mode
                                                                                                    }
                                                                                                } else {
                                                                                                    // Parent is module
                                                                                                    const parentModule = modules.find(m => m._id === row.moduleId);
                                                                                                    if (parentModule) {
                                                                                                        setSelectedSubModuleForTopic({
                                                                                                            id: parentModule._id, // Using module ID as subModuleId
                                                                                                            moduleId: parentModule._id,
                                                                                                            name: parentModule.title
                                                                                                        });
                                                                                                        setDialogType('topic');
                                                                                                        setShowDialog(true);
                                                                                                    }
                                                                                                }
                                                                                            }}
                                                                                            label="Topic"
                                                                                        />
                                                                                    ) : (
                                                                                        <>
                                                                                            <span className="flex-[0.8] text-center px-2 break-words whitespace-normal overflow-hidden text-ellipsis">
                                                                                                {row.topicName}
                                                                                            </span>
                                                                                            {actionsEnabled && !isDefaultItem(row.topicName) && deleteMode.type !== 'topic' && (
                                                                                                <div className="flex-[0.2] flex justify-end">
                                                                                                    <CellActionsMenu
                                                                                                        row={row}
                                                                                                        type="topic"
                                                                                                        onAdd={() => {
                                                                                                            const hierarchyLevels = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()) || [];
                                                                                                            const hasSubModules = hierarchyLevels.includes('sub module');

                                                                                                            if (hasSubModules) {
                                                                                                                // If course has submodules, the parent is the current submodule
                                                                                                                const currentSubModule = subModules.find(sm => sm._id === row.subModuleId);
                                                                                                                if (currentSubModule) {
                                                                                                                    setSelectedSubModuleForTopic({
                                                                                                                        id: currentSubModule._id,
                                                                                                                        moduleId: currentSubModule.moduleId,
                                                                                                                        name: currentSubModule.title
                                                                                                                    });
                                                                                                                    setDialogType('topic');
                                                                                                                    setShowDialog(true);
                                                                                                                }
                                                                                                            } else {
                                                                                                                // If course doesn't have submodules, the parent is the current module
                                                                                                                const currentModule = modules.find(m => m._id === row.moduleId);
                                                                                                                if (currentModule) {
                                                                                                                    setSelectedSubModuleForTopic({
                                                                                                                        id: currentModule._id, // Using module ID as subModuleId for topics
                                                                                                                        moduleId: currentModule._id,
                                                                                                                        name: currentModule.title
                                                                                                                    });
                                                                                                                    setDialogType('topic');
                                                                                                                    setShowDialog(true);
                                                                                                                }
                                                                                                            }
                                                                                                        }}
                                                                                                        onEdit={() => {
                                                                                                            const topic = topics.find(t => t._id === row.topicId);
                                                                                                            if (topic) handleEdit("topic", topic);
                                                                                                        }}
                                                                                                        onDelete={() => handleDeleteClick("topic", row.topicId)}
                                                                                                        onMultipleDelete={() => activateHierarchicalDeleteMode('topic', row.topicId)}
                                                                                                        onEnableDrag={() => {
                                                                                                            setMovableCell({ type: 'topic', id: row.topicId })
                                                                                                            setIsMoveModeActive(true);
                                                                                                        }}
                                                                                                        addLabel="New Topic"
                                                                                                    />
                                                                                                </div>
                                                                                            )}
                                                                                        </>
                                                                                    )}
                                                                                </div>
                                                                            </TableCell>
                                                                        )}
                                                                        {/* Subtopic Cell */}
                                                                        {selectedCourse.courseHierarchy.includes("Sub Topic") && (
                                                                            <TableCell
                                                                                draggable={!isDefaultItem(row.subtopicName)}
                                                                                onDragStart={(e) => handleSubtopicDragStart(e, row.subtopicId)}
                                                                                title={`Enable actions to edit, delete, or change the position of "${row.subtopicName}"`}
                                                                                onDragOver={(e) => handleDragOver(e, row.subtopicId, 'subtopic')}
                                                                                onDragEnd={handleSubtopicDragEnd}
                                                                                onDrop={(e) => handleSubtopicDrop(e, row.subtopicId)}
                                                                                className={`border border-gray-400 text-center text-[12px] font-medium text-gray-800 tracking-wide p-1.5 bg-blue-50 align-middle h-[32px]  z-10
                                                                                   
                                                                                     ${selectedCourse.courseHierarchy.includes("Sub Module") && selectedCourse.courseHierarchy.includes("Topic")
                                                                                        ? "left-[360px] "
                                                                                        : selectedCourse.courseHierarchy.includes("Sub Module") || selectedCourse.courseHierarchy.includes("Topic")
                                                                                            ? "left-[120px]"
                                                                                            : "left-[120px]"
                                                                                    }
                                                                                     ${draggingSubtopicId === row.subtopicId ? 'opacity-30 bg-gray-200' : ''} 
            ${dragOverId === row.subtopicId ? 'border-t-2 border-blue-500' : ''}
           ${movableCell && !isCellMovable('subtopic', row.subtopicId) ? 'opacity-50' : ''}
  ${isCellMovable('subtopic', row.subtopicId) ? 'border-2 border-blue-500 cursor-grab hover:bg-blue-100' : ''} `}
                                                                            >
                                                                                <div className={`relative flex items-center justify-center w-full ${actionsEnabled && !isDefaultItem(row.subtopicName) ? 'py-1.5' : ''}`}>
                                                                                    {/* Checkbox for delete mode */}
                                                                                    {(deleteMode.type === 'subtopic' && !hierarchicalDeleteMode && !isDefaultItem(row.subtopicName)) ||
                                                                                        (shouldShowHierarchicalCheckbox('subtopic', row.subtopicId) && !isDefaultItem(row.subtopicName)) ? (
                                                                                        <div className="flex-[0.1] flex justify-start mr-1">
                                                                                            <input
                                                                                                type="checkbox"
                                                                                                checked={deleteMode.selectedItems.has(row.subtopicId)}
                                                                                                onChange={(e) => handleDeleteModeSelection(row.subtopicId, e.target.checked)}
                                                                                                className="w-3.5 h-3.5 cursor-pointer accent-red-500"
                                                                                            />
                                                                                        </div>
                                                                                    ) : null}
                                                                                    {actionsEnabled && isDefaultItem(row.subtopicName) ? (
                                                                                        <AddCellButton
                                                                                            onClick={() => {
                                                                                                const parentTopic = topics.find(t => t._id === row.topicId);
                                                                                                if (parentTopic) {
                                                                                                    setSelectedTopicForSubTopic({
                                                                                                        id: parentTopic._id,
                                                                                                        moduleId: parentTopic.moduleId,
                                                                                                        subModuleId: parentTopic.subModuleId,
                                                                                                        name: parentTopic.title
                                                                                                    });
                                                                                                    setDisableAddonlyMode(false);
                                                                                                    setDialogType('subtopic');
                                                                                                    setShowDialog(true);
                                                                                                } else if (isLastHierarchy2("subtopic")) {

                                                                                                    setSelectedTopicForSubTopic({
                                                                                                        id: null,
                                                                                                        moduleId: row.moduleId || null,
                                                                                                        subModuleId: filterPlaceholders2(row.subModuleId) || null,
                                                                                                        name: '-'
                                                                                                    });
                                                                                                    setDialogType('subtopic');
                                                                                                    setDisableAddonlyMode(true);
                                                                                                    setShowDialog(true);
                                                                                                    setAddOnlyPedagogyLevel(true); // Force pedagogy/level mode
                                                                                                }

                                                                                            }}
                                                                                            label="Sub Topic"
                                                                                        />
                                                                                    ) : (
                                                                                        <>
                                                                                            <span className="flex-[0.8] text-center px-2 break-words whitespace-normal overflow-hidden text-ellipsis">
                                                                                                {row.subtopicName}
                                                                                            </span>
                                                                                            {actionsEnabled && !isDefaultItem(row.subtopicName) && deleteMode.type !== 'subtopic' && (
                                                                                                <div className="flex-[0.2] flex justify-end">
                                                                                                    <CellActionsMenu
                                                                                                        row={row}
                                                                                                        type="subtopic"
                                                                                                        onAdd={() => {
                                                                                                            const parentTopic = topics.find(t => t._id === row.topicId);
                                                                                                            if (parentTopic) {
                                                                                                                setSelectedTopicForSubTopic({
                                                                                                                    id: parentTopic._id,
                                                                                                                    moduleId: parentTopic.moduleId,
                                                                                                                    subModuleId: parentTopic.subModuleId,
                                                                                                                    name: parentTopic.title
                                                                                                                });
                                                                                                                setDialogType('subtopic');
                                                                                                                setShowDialog(true);
                                                                                                            }
                                                                                                        }}
                                                                                                        onEdit={() => {
                                                                                                            const subtopic = subTopics.find(st => st._id === row.subtopicId);
                                                                                                            if (subtopic) handleEdit("subtopic", subtopic);
                                                                                                        }}
                                                                                                        onDelete={() => handleDeleteClick("subtopic", row.subtopicId)}
                                                                                                        onEnableDrag={() => {
                                                                                                            setMovableCell({ type: 'subtopic', id: row.subtopicId })
                                                                                                            setIsMoveModeActive(true);
                                                                                                        }}
                                                                                                        addLabel="New Sub Topic"
                                                                                                    />
                                                                                                </div>
                                                                                            )}
                                                                                        </>
                                                                                    )}
                                                                                </div>
                                                                            </TableCell>
                                                                        )}
                                                                        {/* Learning Level Cell */}
                                                                        {renderLevelCell(row, index)}
                                                                        {/* Replace the activity cells rendering with: */}
                                                                        {selectedPedagogyTypes.length > 0 && (
                                                                            <>
                                                                                {selectedPedagogyTypes.includes("iDo") && activityTypes["iDo"].map((activity) => {
                                                                                    const mergeInfo = isCellMerged(index, "iDo", activity);
                                                                                    if (mergeInfo.isMerged && !mergeInfo.isStart) return null;
                                                                                    return renderActivityCell("iDo", activity, {
                                                                                        ...row,
                                                                                        subModuleId: row.subModuleId // Ensure subModuleId is passed
                                                                                    }, index, mergeInfo)
                                                                                })}
                                                                                {selectedPedagogyTypes.includes("weDo") && activityTypes["weDo"].map((activity) => {
                                                                                    const mergeInfo = isCellMerged(index, "weDo", activity);
                                                                                    if (mergeInfo.isMerged && !mergeInfo.isStart) return null;
                                                                                    return renderActivityCell("weDo", activity, {
                                                                                        ...row,
                                                                                        subModuleId: row.subModuleId // Ensure subModuleId is passed
                                                                                    }, index, mergeInfo)
                                                                                })}
                                                                                {selectedPedagogyTypes.includes("youDo") && activityTypes["youDo"].map((activity) => {
                                                                                    const mergeInfo = isCellMerged(index, "youDo", activity);
                                                                                    if (mergeInfo.isMerged && !mergeInfo.isStart) return null;
                                                                                    return renderActivityCell("youDo", activity, {
                                                                                        ...row,
                                                                                        subModuleId: row.subModuleId // Ensure subModuleId is passed
                                                                                    }, index, mergeInfo)
                                                                                })}
                                                                            </>
                                                                        )}
                                                                    </motion.tr>
                                                                )
                                                            })
                                                        })()}

                                                    </TableBody>
                                                </Table>
                                            </div>
                                            <div className="flex-none">
                                                <div className="sticky bottom-0 z-30 bg-white border-t border-gray-200">
                                                    <div className="overflow-x-auto">
                                                        <Table className="border-separate border-spacing-0 min-w-full" style={{ tableLayout: 'fixed' }}>
                                                            {/* Hidden header to match column widths - MUST BE IDENTICAL TO ABOVE */}
                                                            <TableHeader className="invisible" style={{ height: '0px', lineHeight: '0px' }}>
                                                                <TableRow style={{ height: '0px' }}>
                                                                    {selectedCourse.courseHierarchy.map((level, index) => (
                                                                        <TableHead
                                                                            key={`hidden-${level}`}
                                                                            className="border-0 p-0"
                                                                            style={{
                                                                                height: '0px',
                                                                                lineHeight: '0px',
                                                                                ...(hierarchyWidthPercentage ? { width: `${hierarchyWidthPercentage}%` } : { minWidth: '120px' })
                                                                            }}
                                                                        />
                                                                    ))}
                                                                    <TableHead className="border-0 p-0" style={{
                                                                        height: '0px',
                                                                        lineHeight: '0px',
                                                                        minWidth: '80px'
                                                                    }} />
                                                                    {selectedPedagogyTypes.length > 0 && (
                                                                        <>
                                                                            {selectedPedagogyTypes.includes("iDo") && activityTypes["iDo"].map((activity) => (
                                                                                <TableHead key={`hidden-iDo-${activity}`} className="border-0 p-0" style={{
                                                                                    height: '0px',
                                                                                    lineHeight: '0px',
                                                                                    minWidth: '70px'
                                                                                }} />
                                                                            ))}
                                                                            {selectedPedagogyTypes.includes("weDo") && activityTypes["weDo"].map((activity) => (
                                                                                <TableHead key={`hidden-weDo-${activity}`} className="border-0 p-0" style={{
                                                                                    height: '0px',
                                                                                    lineHeight: '0px',
                                                                                    minWidth: '70px'
                                                                                }} />
                                                                            ))}
                                                                            {selectedPedagogyTypes.includes("youDo") && activityTypes["youDo"].map((activity) => (
                                                                                <TableHead key={`hidden-youDo-${activity}`} className="border-0 p-0" style={{
                                                                                    height: '0px',
                                                                                    lineHeight: '0px',
                                                                                    minWidth: '70px'
                                                                                }} />
                                                                            ))}
                                                                        </>
                                                                    )}
                                                                </TableRow>
                                                            </TableHeader>
                                                            <TableBody>
                                                                {selectedPedagogyTypes.length > 0 && (
                                                                    <TableRow className="bg-gray-200 font-bold sticky bottom-0">


                                                                        <TableCell
                                                                            className={`border border-gray-400 text-center p-1 text-[10px] bg-gray-200 z-10 left-0`}
                                                                            colSpan={selectedCourse.courseHierarchy.length + 1}
                                                                        >
                                                                            Total Hours
                                                                        </TableCell>

                                                                        {selectedPedagogyTypes.includes("iDo") && activityTypes["iDo"].map((activity) => (
                                                                            <TableCell
                                                                                key={`total-iDo-${activity}`}
                                                                                className="border border-gray-400 text-center font-bold p-0.5 text-[10px] bg-yellow-100 min-w-[70px] h-[32px]"
                                                                            >
                                                                                {calculateTotalHours("iDo", activity) || "0"}
                                                                            </TableCell>
                                                                        ))}
                                                                        {selectedPedagogyTypes.includes("weDo") && activityTypes["weDo"].map((activity) => (
                                                                            <TableCell
                                                                                key={`total-weDo-${activity}`}
                                                                                className="border border-gray-400 text-center font-bold p-0.5 text-[10px] bg-orange-100 min-w-[70px] h-[32px]"
                                                                            >
                                                                                {calculateTotalHours("weDo", activity) || "0"}
                                                                            </TableCell>
                                                                        ))}
                                                                        {selectedPedagogyTypes.includes("youDo") && activityTypes["youDo"].map((activity) => (
                                                                            <TableCell
                                                                                key={`total-youDo-${activity}`}
                                                                                className="border border-gray-400 text-center font-bold p-0.5 text-[10px] bg-green-100 min-w-[70px] h-[32px]"
                                                                            >
                                                                                {calculateTotalHours("youDo", activity) || "0"}
                                                                            </TableCell>
                                                                        ))}
                                                                    </TableRow>
                                                                )}
                                                            </TableBody>
                                                        </Table>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        {/* Total Hours Display in Action Button Area */}

                                        <div className="flex justify-between items-center mt-5 px-3">
                                            <div className="text-sm text-gray-600">
                                                <span className="font-medium">Click cells to edit • Select rows to merge</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            {/* Enhanced Floating Delete Mode Actions */}
                            {(deleteMode.type && (deleteMode || hierarchicalDeleteMode)) && (
                                <motion.div
                                    initial={{ opacity: 0, y: 15 }}
                                    animate={{ opacity: 1, y: 0 }}
                                    exit={{ opacity: 0, y: 15 }}
                                    className="fixed bottom-4 left-1/2 transform -translate-x-1/2 z-50 w-[95%] sm:w-auto"
                                >
                                    <div
                                        className="backdrop-blur-md bg-orange-100/90 dark:bg-orange-950/90
  border border-orange-200 dark:border-orange-800
  rounded-2xl shadow-lg px-3.5 py-2.5 sm:px-4 sm:py-2
  flex flex-wrap sm:flex-nowrap items-center justify-between gap-3 sm:gap-4
  transition-all duration-300 ease-in-out"
                                    >
                                        {/* Select All Checkbox - Show different text for hierarchical mode */}
                                        <div className="flex items-center gap-2 w-full sm:w-auto justify-center sm:justify-start">
                                            <input
                                                type="checkbox"
                                                onChange={(e) => {
                                                    if (hierarchicalDeleteMode) {
                                                        // For hierarchical mode, select only children of the specific parent
                                                        const children = getImmediateChildrenForParent(
                                                            hierarchicalDeleteMode.parentType,
                                                            hierarchicalDeleteMode.parentId
                                                        );
                                                        const childIds = children.map(child => child._id);
                                                        handleDeleteModeSelectAll(e.target.checked, children);
                                                    } else {
                                                        // For global mode, select all items of the type
                                                        const items = getItemsForDeletion(deleteMode.type!);
                                                        handleDeleteModeSelectAll(e.target.checked, items);
                                                    }
                                                }}
                                                checked={
                                                    hierarchicalDeleteMode
                                                        ? deleteMode.selectedItems.size === getImmediateChildrenForParent(
                                                            hierarchicalDeleteMode.parentType,
                                                            hierarchicalDeleteMode.parentId
                                                        ).length
                                                        : deleteMode.selectedItems.size === getItemsForDeletion(deleteMode.type!).length
                                                }
                                                className="w-4 h-4 cursor-pointer accent-orange-500 rounded"
                                            />
                                            <span className="text-xs font-medium text-orange-900 dark:text-orange-200">
                                                {hierarchicalDeleteMode
                                                    ? `Select All Children (${getImmediateChildrenForParent(
                                                        hierarchicalDeleteMode.parentType,
                                                        hierarchicalDeleteMode.parentId
                                                    ).length})`
                                                    : `Select All (${getItemsForDeletion(deleteMode.type!).length})`
                                                }
                                            </span>
                                        </div>

                                        {/* Selection Count */}
                                        <div className="flex-1 text-center">
                                            <span className="text-xs font-semibold text-orange-800 dark:text-orange-100">
                                                {deleteMode.selectedItems.size} {deleteMode.type}(s) selected
                                                {hierarchicalDeleteMode && " (from this parent)"}
                                            </span>
                                        </div>

                                        {/* Action Buttons */}
                                        <div className="flex gap-2 justify-center sm:justify-end w-full sm:w-auto">
                                            <Button
                                                variant="outline"
                                                onClick={cancelDeleteMode}
                                                className="text-[11px] px-3 py-1.5 h-7 rounded-md
      border-orange-300 dark:border-orange-700
      text-orange-800 dark:text-orange-200
      hover:bg-orange-100 dark:hover:bg-orange-800
      transition-all duration-200"
                                            >
                                                Cancel
                                            </Button>
                                            <Button
                                                variant="destructive"
                                                onClick={() => setShowDeleteConfirmation(true)}
                                                disabled={deleteMode.selectedItems.size === 0}
                                                className={`text-[11px] px-3 py-1.5 h-7 rounded-md font-semibold transition-all duration-200 ${deleteMode.selectedItems.size === 0
                                                    ? "opacity-50 cursor-not-allowed bg-orange-300"
                                                    : "bg-orange-600 hover:bg-orange-700 hover:scale-[1.03]"
                                                    } text-white shadow-sm`}
                                            >
                                                Delete ({deleteMode.selectedItems.size})
                                            </Button>
                                        </div>
                                    </div>
                                </motion.div>
                            )}

                        </div>
                    ) : (
                        <div className="bg-yellow-50 rounded-lg border border-yellow-200 p-6 shadow-sm">
                            <div className="flex">
                                <div className="flex-shrink-0">
                                    <svg className="h-5 w-5 text-yellow-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                        <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                                    </svg>
                                </div>
                                <div className="ml-3">
                                    <h3 className="text-sm font-medium text-yellow-800">No course selected</h3>
                                    <div className="mt-2 text-sm text-yellow-700">
                                        <p>Please select a course from the list to continue.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                    {(showAddModuleFirst || showAddTopicFirst) && (
                        renderAddFirstMessages()
                    )}
                </div>
            </div>
            {/* Consolidated Dialog */}
            <AnimatePresence>
                <Dialog
                    open={showDialog}
                    onOpenChange={(open) => {
                        if (!open) {
                            setShowDialog(false);
                            setAddOnlyPedagogyLevel(false);
                            resetAllFormStates();

                        }
                    }}
                >
                    <DialogContent className={` sm:max-w-[97vw] max-w-[95vw] h-[97vh] ${(!isLastHierarchy()) ? 'w-[40vw]' : ''}  p-0  overflow-hidden bg-white border border-slate-200/60 shadow-xl rounded-xl`} onInteractOutside={(e) => e.preventDefault()}>
                        <motion.div
                            initial="hidden"
                            animate="visible"
                            exit="exit"
                            variants={popupVariants}
                            className="relative"
                        >
                            {/* Compact Header */}
                            <div className="px-6 py-2 bg-gradient-to-br from-sky-500 via-blue-600 to-indigo-700 relative overflow-hidden">
                                <DialogHeader className="relative">
                                    <div className="flex items-center gap-3">
                                        <div className="w-8 h-8 rounded-lg bg-white/20 backdrop-blur-sm flex items-center justify-center flex-shrink-0">
                                            {editMode ? (
                                                <svg className="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 20 20">
                                                    <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" />
                                                </svg>
                                            ) : (
                                                <svg className="w-4 h-4 text-white" fill="currentColor" viewBox="0 0 20 20">
                                                    <path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" />
                                                </svg>
                                            )}
                                        </div>
                                        <div className="min-w-0 flex-1">
                                            <DialogTitle className="text-lg font-semibold text-white leading-tight">
                                                {editMode ? (
                                                    <>Edit {editMode.type}</>
                                                ) : dialogType === 'module' ? (
                                                    'New Module'
                                                ) : dialogType === 'submodule' ? (
                                                    'New Submodule'
                                                ) : dialogType === 'topic' ? (
                                                    'New Topic'
                                                ) : (
                                                    'New Subtopic'
                                                )}
                                            </DialogTitle>

                                            {/* Compact Context */}
                                            {((!editMode && dialogType !== 'module') || (editMode && editMode.type !== 'module')) && (
                                                <div className="flex items-center gap-1.5 mt-1">
                                                    <span className="text-white/70 text-sm">in</span>
                                                    <div className="flex items-center flex-wrap gap-1 max-w-md">
                                                        {getHeaderText().split(' → ').map((part, index, array) => (
                                                            <Fragment key={index}>
                                                                <span className={`
            inline-block items-center px-2 py-1 rounded-md cursor-context-menu text-xs  ${dialogType === 'topic' ? "max-w-[200px]" : dialogType === 'subtopic' ? "max-w-[150px]" : "max-w-[25vw]"} font-medium truncate
            ${index === array.length - 1
                                                                        ? (dialogType === 'submodule'
                                                                            ? 'bg-blue-400/25 text-blue-50'
                                                                            : dialogType === 'topic'
                                                                                ? 'bg-amber-400/25 text-amber-50'
                                                                                : 'bg-purple-400/25 text-purple-50')
                                                                        : 'bg-gray-400/25 text-gray-50'
                                                                    }
                                                                 `}
                                                                    title={part}
                                                                >
                                                                    {part}
                                                                </span>
                                                                {index < array.length - 1 && (
                                                                    <ChevronRight className="w-3 h-3 text-white/50" />
                                                                )}
                                                            </Fragment>
                                                        ))}
                                                    </div>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                </DialogHeader>
                            </div>
                            {!editMode && isLastHierarchy() && shouldShowPedagogyLevelToggle(dialogType, editMode) && (
                                <div className={`px-6 py-1 bg-slate-50 border-b border-slate-200 ${disableAddonlyMode ? "opacity-50" : ""}`}>
                                    <div className="flex justify-end items-center gap-6">
                                        {/* Preview Link */}
                                        <button
                                            type="button"
                                            onClick={() => setShowFullPreviewDialog(true)}
                                            className="flex items-center gap-1.5 text-xs underline font-medium text-blue-600 hover:text-blue-800 transition-colors cursor-pointer group"
                                        >
                                            <Eye className="w-3.5 h-3.5 group-hover:scale-110 transition-transform" />
                                            Preview Table
                                        </button>

                                        {/* Toggle Section */}
                                        <div className="flex items-center gap-3">
                                            <span className="text-xs font-medium text-slate-700">Add Pedagogy/Level Only</span>
                                            <button
                                                type="button"
                                                onClick={() => setAddOnlyPedagogyLevel(!addOnlyPedagogyLevel)}
                                                className={`relative inline-flex h-5 w-11 items-center rounded-full transition-colors ${disableAddonlyMode ? "cursor-not-allowed" : "cursor-pointer"} ${addOnlyPedagogyLevel ? 'bg-amber-500' : 'bg-slate-300'
                                                    }`}
                                                disabled={disableAddonlyMode}
                                            >
                                                <span className="sr-only">Add Pedagogy/Level Only</span>
                                                <span
                                                    className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${addOnlyPedagogyLevel ? 'translate-x-6' : 'translate-x-1'
                                                        }`}
                                                />
                                            </button>
                                            <span className="text-sm font-medium text-slate-700">
                                                {addOnlyPedagogyLevel ? 'ON' : 'OFF'}
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            )}
                            {isLastHierarchy() && !shouldShowPedagogyLevelToggle(dialogType, editMode) && (
                                <div className={`px-6 py-1 bg-slate-50 border-b border-slate-200 ${disableAddonlyMode ? "opacity-50" : ""}`}>
                                    <div className="flex justify-end items-center gap-6">
                                        {/* Preview Link */}
                                        <button
                                            type="button"
                                            onClick={() => setShowFullPreviewDialog(true)}
                                            className="flex items-center gap-1.5 text-xs underline font-medium text-blue-600 hover:text-blue-800 transition-colors cursor-pointer group"
                                        >
                                            <Eye className="w-3.5 h-3.5 group-hover:scale-110 transition-transform" />
                                            Preview Table
                                        </button>
                                    </div>
                                </div>
                            )}
                            {/* Compact Form */}
                            <div className="py-1 px-4">
                                <form
                                    onSubmit={(e) => {
                                        e.preventDefault();
                                        if (dialogType === 'module') handleModuleSubmit(e);
                                        else if (dialogType === 'submodule') handleSubModuleSubmit(e);
                                        else if (dialogType === 'topic') handleTopicSubmit(e);
                                        else if (dialogType === 'subtopic') handleSubTopicSubmit(e);
                                    }}
                                    className={`grid gap-6 ${(!isLastHierarchy()) ? 'grid-cols-1' : (addOnlyPedagogyLevel ? 'grid-cols-2' : 'grid-cols-1 md:grid-cols-3')}`}
                                >
                                    {/* Column 1: Basic Information - Always visible */}
                                    {!addOnlyPedagogyLevel && (
                                        <div className="space-y-4 md:col-span-1">
                                            <h3 className="text-sm font-semibold text-slate-700 border-b pb-2 flex items-center">
                                                <svg className="w-4 h-4 mr-2 text-blue-500" fill="currentColor" viewBox="0 0 20 20">
                                                    <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
                                                </svg>
                                                Basic Information
                                            </h3>

                                            {/* Title */}
                                            <div className="space-y-2">
                                                <Label htmlFor="title" className="text-xs font-medium text-slate-700 flex items-center gap-1">
                                                    Title <span className="text-rose-500">*</span>
                                                </Label>
                                                <textarea
                                                    id="title"
                                                    name="title"
                                                    value={
                                                        dialogType === 'module' ? moduleFormData.title :
                                                            dialogType === 'submodule' ? subModuleFormData.title :
                                                                dialogType === 'topic' ? topicFormData.title :
                                                                    subTopicFormData.title
                                                    }
                                                    onChange={(e) => {
                                                        if (dialogType === 'module') handleModuleFormChange(e);
                                                        else if (dialogType === 'submodule') handleSubModuleFormChange(e);
                                                        else if (dialogType === 'topic') handleTopicFormChange(e);
                                                        else if (dialogType === 'subtopic') handleSubTopicFormChange(e);
                                                    }}
                                                    className="w-full h-20 px-3 py-2.5 text-sm border border-slate-200 rounded-lg focus:ring-2 focus:ring-blue-500 bg-slate-50/50 resize-none transition-colors"
                                                    placeholder="Enter title..."
                                                    required
                                                />
                                            </div>

                                            {/* Description */}
                                            <div className="space-y-2">
                                                <Label htmlFor="description" className="text-xs font-medium text-slate-700">
                                                    Description
                                                </Label>
                                                <textarea
                                                    id="description"
                                                    name="description"
                                                    value={
                                                        dialogType === 'module' ? moduleFormData.description :
                                                            dialogType === 'submodule' ? subModuleFormData.description :
                                                                dialogType === 'topic' ? topicFormData.description :
                                                                    subTopicFormData.description
                                                    }
                                                    onChange={(e) => {
                                                        if (dialogType === 'module') handleModuleFormChange(e);
                                                        else if (dialogType === 'submodule') handleSubModuleFormChange(e);
                                                        else if (dialogType === 'topic') handleTopicFormChange(e);
                                                        else if (dialogType === 'subtopic') handleSubTopicFormChange(e);
                                                    }}
                                                    className="w-full h-20 px-3 py-2.5 text-sm border border-slate-200 rounded-lg focus:ring-2 focus:ring-blue-500 bg-slate-50/50 resize-none transition-colors"
                                                    placeholder="Brief description ..."
                                                />
                                            </div>


                                        </div>
                                    )}

                                    {/* Column 2: Options (Level & Pedagogy) - COMPACT DESIGN */}
                                    {isLastHierarchy() && (
                                        <div className="space-y-2 md:col-span-1">
                                            <h3 className="text-sm font-semibold text-slate-700 border-b pb-2 flex items-center">
                                                <svg className="w-4 h-4 mr-2 text-blue-500" fill="currentColor" viewBox="0 0 20 20">
                                                    <path fillRule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clipRule="evenodd" />
                                                </svg>
                                                Options
                                            </h3>

                                            <div className="space-y-2">
                                                {/* Level Section - Compact */}
                                                <div className={`p-3 rounded-lg border transition-all ${showLevelSection ? 'bg-blue-50 border-blue-300 shadow-sm' : 'bg-slate-50 border-slate-200'}`}>
                                                    <div className="flex items-center space-x-3">
                                                        <Checkbox
                                                            id="add-level"
                                                            checked={showLevelSection}
                                                            onCheckedChange={(checked) => {
                                                                if (checked) {
                                                                    setShowLevelSection(true);
                                                                } else {
                                                                    clearLevelMergeSelections();
                                                                    setShowLevelSection(false);
                                                                    setShowMergeLevelSection(false);
                                                                }
                                                            }}
                                                            className="data-[state=checked]:bg-blue-600 data-[state=checked]:border-blue-600"
                                                        />
                                                        <Label htmlFor="add-level" className="text-sm font-medium text-slate-800 cursor-pointer">
                                                            Add Level
                                                        </Label>
                                                    </div>

                                                    {showLevelSection && (
                                                        <motion.div
                                                            initial={{ opacity: 0, height: 0 }}
                                                            animate={{ opacity: 1, height: 'auto' }}
                                                            transition={{ duration: 0.2 }}
                                                            className="mt-2 space-y-1 pt-1 border-t border-blue-100"
                                                        >
                                                            <div className="space-y-2">
                                                                <Label htmlFor="level" className="text-xs font-medium text-slate-700 flex items-center">
                                                                    Level
                                                                </Label>
                                                                <Select
                                                                    value={selectedLevel}
                                                                    onValueChange={setSelectedLevel}
                                                                >
                                                                    <SelectTrigger className="text-xs h-9 w-full bg-white">
                                                                        <SelectValue placeholder="Select level" />
                                                                    </SelectTrigger>
                                                                    <SelectContent>
                                                                        <SelectItem value="Easy" className="text-sm">Easy</SelectItem>
                                                                        <SelectItem value="Medium" className="text-sm">Medium</SelectItem>
                                                                        <SelectItem value="Hard" className="text-sm">Hard</SelectItem>
                                                                    </SelectContent>
                                                                </Select>
                                                            </div>
                                                            {!disableAddonlyMode && (
                                                                <>
                                                                    {savedLevelMergeSelections && getLevelMergeSelectionCount() > 0 ? (
                                                                        <div className="flex items-center justify-between p-1 mt-1 bg-green-50 rounded-md border border-green-200">
                                                                            <div className="flex items-center space-x-2">
                                                                                <SquarePen className="w-3 h-3 text-green-600" />
                                                                                <span className="text-xs text-slate-700 font-medium">
                                                                                    {dialogType === 'module' && ` Edit selected modules for merge`}
                                                                                    {dialogType === 'submodule' && ` Edit selected submodules for merge`}
                                                                                    {dialogType === 'topic' && ` Edit selected topics for merge`}
                                                                                    {dialogType === 'subtopic' && ` Edit selected subtopics for merge`}
                                                                                </span>
                                                                            </div>
                                                                            <Button
                                                                                type="button"
                                                                                variant="outline"
                                                                                size="sm"
                                                                                onClick={editLevelMergeSelections}
                                                                                className="h-7 text-xs"
                                                                                disabled={!selectedLevel || isMergeSectionOpen}
                                                                            >
                                                                                Edit Selection
                                                                            </Button>
                                                                        </div>
                                                                    ) : (
                                                                        <div className="flex items-center space-x-3 p-2 bg-slate-50 rounded-lg border border-slate-200">
                                                                            <Checkbox
                                                                                id="merge-level"
                                                                                checked={showMergeLevelSection}
                                                                                disabled={!selectedLevel || isMergeSectionOpen}
                                                                                onCheckedChange={(checked) => {
                                                                                    setShowMergeLevelSection(!!checked);
                                                                                    if (!checked) {
                                                                                        setSelectedLevelModulesForMerge(new Set());
                                                                                        setSelectedLevelSubModulesForMerge(new Set());
                                                                                        setSelectedLevelTopicsForMerge(new Set());
                                                                                        setSelectedLevelSubTopicsForMerge(new Set());
                                                                                    }
                                                                                }}
                                                                                className="data-[state=checked]:bg-blue-600 data-[state=checked]:border-blue-600"
                                                                            />
                                                                            <Label htmlFor="merge-level" className="text-xs text-slate-700 cursor-pointer flex-1">
                                                                                Merge with existing {" "}
                                                                                <span className="text-blue-600 font-semibold">
                                                                                    {dialogType === "module"
                                                                                        ? "Module"
                                                                                        : dialogType === "submodule"
                                                                                            ? "Submodule"
                                                                                            : dialogType === "topic"
                                                                                                ? "Topic"
                                                                                                : "Subtopic"}
                                                                                </span>
                                                                            </Label>
                                                                            <Merge className="w-4 h-4 text-blue-500" />
                                                                        </div>
                                                                    )}
                                                                </>
                                                            )}
                                                        </motion.div>
                                                    )}
                                                </div>

                                                {/* Pedagogy Section - Compact */}
                                                <div className={`border rounded-lg transition-all ${showPedagogySection ? 'bg-blue-50 border-blue-200' : 'bg-slate-50 border-slate-200'}`}>
                                                    <div className="flex items-center justify-between p-3">
                                                        <div className="flex items-center space-x-2">
                                                            <Checkbox
                                                                id="add-pedagogy"
                                                                checked={showPedagogySection}
                                                                onCheckedChange={(checked) => {
                                                                    if (checked) {
                                                                        setShowPedagogySection(true);
                                                                    } else {
                                                                        clearPedagogyMergeSelections();
                                                                        setShowPedagogySection(false);
                                                                    }
                                                                }}
                                                                className="data-[state=checked]:bg-blue-600 data-[state=checked]:border-blue-600"
                                                            />
                                                            <Label htmlFor="add-pedagogy" className="text-sm font-medium text-slate-800 cursor-pointer">
                                                                Pedagogy
                                                            </Label>
                                                        </div>
                                                        {showPedagogySection && (
                                                            <span className="text-xs text-blue-600 bg-blue-100 px-2 py-0.5 rounded-full font-medium">
                                                                {Object.values(selectedPedagogyActivities).flat().length} selected
                                                            </span>
                                                        )}
                                                    </div>

                                                    {showPedagogySection && (
                                                        <div className="px-3 pb-3 border-t border-blue-100 pt-1 space-y-2">
                                                            {/* Compact Activities List */}
                                                            <div className="max-h-40 overflow-y-auto bg-white border border-slate-200 rounded">
                                                                {/* I Do Activities - Compact */}
                                                                {activityTypes["iDo"].length > 0 && (
                                                                    <div className="border-b border-slate-100 last:border-b-0">
                                                                        <div className="sticky top-0 bg-blue-50 px-2 py-1 text-xs font-medium text-blue-700 flex items-center justify-between">
                                                                            <span className="flex items-center gap-1">
                                                                                <User2 size={13} />
                                                                                I Do
                                                                            </span>
                                                                            <span className="text-xs bg-blue-100 px-1.5 py-0.5 rounded-full">
                                                                                {selectedPedagogyActivities.iDo.length}
                                                                            </span>
                                                                        </div>
                                                                        <div className="p-1 space-y-1">
                                                                            {activityTypes["iDo"].map(activity => {
                                                                                const mergeSelection = savedPedagogyMergeSelections?.iDo?.[activity];
                                                                                const hasMerge = hasActualMergeSelection(mergeSelection);

                                                                                return (
                                                                                    <div key={`iDo-${activity}`} className="flex items-center justify-between px-1 py-0.5 hover:bg-blue-50/50 rounded text-xs group">
                                                                                        <div className="flex items-center space-x-1.5 flex-1 min-w-0">
                                                                                            <Checkbox
                                                                                                id={`iDo-${activity}`}
                                                                                                checked={selectedPedagogyActivities.iDo.includes(activity)}
                                                                                                onCheckedChange={(checked) => {
                                                                                                    const newActivities = { ...selectedPedagogyActivities };
                                                                                                    if (checked) {
                                                                                                        newActivities.iDo = [...newActivities.iDo, activity];
                                                                                                    } else {
                                                                                                        newActivities.iDo = newActivities.iDo.filter(a => a !== activity);
                                                                                                        const newHours = { ...pedagogyHours };
                                                                                                        delete newHours.iDo[activity];
                                                                                                        setPedagogyHours(newHours);
                                                                                                        // Clear merge selection when activity is deselected
                                                                                                        clearPedagogyMergeSelections("iDo", activity);
                                                                                                    }
                                                                                                    setSelectedPedagogyActivities(newActivities);
                                                                                                }}
                                                                                                className="h-3 w-3 data-[state=checked]:bg-blue-600 data-[state=checked]:border-blue-600"
                                                                                            />
                                                                                            <span className="text-slate-700 truncate flex-1">{activity}</span>
                                                                                        </div>

                                                                                        <div className="flex items-center space-x-1">
                                                                                            {selectedPedagogyActivities.iDo.includes(activity) && (
                                                                                                <div className="flex gap-3">
                                                                                                    <div className="flex items-center space-x-0.5">
                                                                                                        <Input
                                                                                                            type="number"
                                                                                                            value={pedagogyHours.iDo[activity] || ""}
                                                                                                            onChange={(e) => {
                                                                                                                const value = parseFloat(e.target.value) || 0;
                                                                                                                setPedagogyHours(prev => ({
                                                                                                                    ...prev,
                                                                                                                    iDo: { ...prev.iDo, [activity]: value }
                                                                                                                }));
                                                                                                            }}
                                                                                                            className="h-5 w-10 text-xs text-center p-0 border-slate-300"
                                                                                                            placeholder="0"
                                                                                                        />
                                                                                                        <span className="text-xs text-slate-500">hrs</span>
                                                                                                    </div>

                                                                                                    {/* Merge button for this specific activity */}
                                                                                                    {!disableAddonlyMode && (
                                                                                                        <button
                                                                                                            type="button"
                                                                                                            onClick={() => {
                                                                                                                setCurrentMergeActivity(activity);
                                                                                                                setShowMergePedagogySection(prev => ({
                                                                                                                    ...prev,
                                                                                                                    iDo: true
                                                                                                                }));
                                                                                                                // Load existing merge selection if it exists
                                                                                                                if (savedPedagogyMergeSelections.iDo[activity]) {
                                                                                                                    editPedagogyMergeSelections("iDo", activity);
                                                                                                                }
                                                                                                            }}
                                                                                                            className={`p-0.5 rounded text-xs ${hasMerge
                                                                                                                ? 'bg-green-100 text-green-700 hover:bg-green-200'
                                                                                                                : 'bg-blue-100 text-blue-700 hover:bg-blue-200'
                                                                                                                } ${(!pedagogyHours.iDo[activity] || pedagogyHours.iDo[activity] <= 0 || isMergeSectionOpen) ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`}
                                                                                                            title={hasMerge ? "Edit merge selection" : "Merge with existing items"}
                                                                                                            disabled={!pedagogyHours.iDo[activity] || pedagogyHours.iDo[activity] <= 0 || isMergeSectionOpen}
                                                                                                        >
                                                                                                            {hasMerge ? (<span className="flex gap-1 items-center">
                                                                                                                <SquarePen className="w-3 h-3" /> Edit
                                                                                                            </span>
                                                                                                            ) : (<span className="flex gap-1 items-center">
                                                                                                                <Merge className="w-3 h-3" /> Merge
                                                                                                            </span>
                                                                                                            )}
                                                                                                        </button>
                                                                                                    )}
                                                                                                </div>
                                                                                            )}
                                                                                        </div>
                                                                                    </div>
                                                                                );
                                                                            })}
                                                                        </div>
                                                                    </div>
                                                                )}

                                                                {/* We Do Activities - Compact */}
                                                                {activityTypes["weDo"].length > 0 && (
                                                                    <div className="border-b border-slate-100 last:border-b-0">
                                                                        <div className="sticky top-0 bg-amber-50 px-2 py-1 text-xs font-medium text-amber-700 flex items-center justify-between">
                                                                            <span className="flex items-center">
                                                                                <Users className="h-3 w-3 mr-1" />
                                                                                We Do
                                                                            </span>
                                                                            <span className="text-xs bg-amber-100 px-1.5 py-0.5 rounded-full">
                                                                                {selectedPedagogyActivities.weDo.length}
                                                                            </span>
                                                                        </div>
                                                                        <div className="p-1 space-y-1">
                                                                            {activityTypes["weDo"].map(activity => {
                                                                                const mergeSelection = savedPedagogyMergeSelections?.weDo?.[activity];
                                                                                const hasMerge = hasActualMergeSelection(mergeSelection);
                                                                                return (
                                                                                    <div key={`weDo-${activity}`} className="flex items-center justify-between px-1 py-0.5 hover:bg-amber-50/50 rounded text-xs group">
                                                                                        <div className="flex items-center space-x-1.5 flex-1 min-w-0">
                                                                                            <Checkbox
                                                                                                id={`weDo-${activity}`}
                                                                                                checked={selectedPedagogyActivities.weDo.includes(activity)}
                                                                                                onCheckedChange={(checked) => {
                                                                                                    const newActivities = { ...selectedPedagogyActivities };
                                                                                                    if (checked) {
                                                                                                        newActivities.weDo = [...newActivities.weDo, activity];
                                                                                                    } else {
                                                                                                        newActivities.weDo = newActivities.weDo.filter(a => a !== activity);
                                                                                                        const newHours = { ...pedagogyHours };
                                                                                                        delete newHours.weDo[activity];
                                                                                                        setPedagogyHours(newHours);
                                                                                                        // Clear merge selection when activity is deselected
                                                                                                        clearPedagogyMergeSelections("weDo", activity);
                                                                                                    }
                                                                                                    setSelectedPedagogyActivities(newActivities);
                                                                                                }}
                                                                                                className="h-3 w-3 data-[state=checked]:bg-blue-600 data-[state=checked]:border-blue-600"
                                                                                            />
                                                                                            <span className="text-slate-700 truncate flex-1">{activity}</span>
                                                                                        </div>

                                                                                        <div className="flex items-center space-x-1">
                                                                                            {selectedPedagogyActivities.weDo.includes(activity) && (
                                                                                                <div className="flex gap-3">
                                                                                                    <div className="flex items-center space-x-0.5">
                                                                                                        <Input
                                                                                                            type="number"
                                                                                                            value={pedagogyHours.weDo[activity] || ""}
                                                                                                            onChange={(e) => {
                                                                                                                const value = parseFloat(e.target.value) || 0;
                                                                                                                setPedagogyHours(prev => ({
                                                                                                                    ...prev,
                                                                                                                    weDo: { ...prev.weDo, [activity]: value }
                                                                                                                }));
                                                                                                            }}
                                                                                                            className="h-5 w-10 text-xs text-center p-0 border-slate-300"
                                                                                                            placeholder="0"
                                                                                                        />
                                                                                                        <span className="text-xs text-slate-500">hrs</span>
                                                                                                    </div>

                                                                                                    {/* Merge button for this specific activity */}
                                                                                                    {!disableAddonlyMode && (
                                                                                                        <button
                                                                                                            type="button"
                                                                                                            onClick={() => {
                                                                                                                setCurrentMergeActivity(activity);
                                                                                                                setShowMergePedagogySection(prev => ({
                                                                                                                    ...prev,
                                                                                                                    weDo: true
                                                                                                                }));
                                                                                                                // Load existing merge selection if it exists
                                                                                                                if (savedPedagogyMergeSelections.weDo[activity]) {
                                                                                                                    editPedagogyMergeSelections("weDo", activity);
                                                                                                                }
                                                                                                            }}
                                                                                                            className={`p-0.5 rounded text-xs ${hasMerge
                                                                                                                ? 'bg-green-100 text-green-700 hover:bg-green-200'
                                                                                                                : 'bg-amber-100 text-amber-700 hover:bg-amber-200'
                                                                                                                } ${(!pedagogyHours.weDo[activity] || pedagogyHours.weDo[activity] <= 0 || isMergeSectionOpen) ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`}
                                                                                                            title={hasMerge ? "Edit merge selection" : "Merge with existing items"}
                                                                                                            disabled={!pedagogyHours.weDo[activity] || pedagogyHours.weDo[activity] <= 0 || isMergeSectionOpen}
                                                                                                        >
                                                                                                            {hasMerge ? (<span className="flex gap-1 items-center">
                                                                                                                <SquarePen className="w-3 h-3" /> Edit
                                                                                                            </span>
                                                                                                            ) : (<span className="flex gap-1 items-center">
                                                                                                                <Merge className="w-3 h-3" /> Merge
                                                                                                            </span>
                                                                                                            )}
                                                                                                        </button>
                                                                                                    )}
                                                                                                </div>
                                                                                            )}
                                                                                        </div>
                                                                                    </div>
                                                                                );
                                                                            })}
                                                                        </div>
                                                                    </div>
                                                                )}

                                                                {/* You Do Activities - Compact */}
                                                                {activityTypes["youDo"].length > 0 && (
                                                                    <div className="border-b border-slate-100 last:border-b-0">
                                                                        <div className="sticky top-0 bg-green-50 px-2 py-1 text-xs font-medium text-green-700 flex items-center justify-between">
                                                                            <span className="flex items-center">
                                                                                <svg className="w-3 h-3 mr-1" fill="currentColor" viewBox="0 0 20 20">
                                                                                    <path fillRule="evenodd" d="M6.672 1.911a1 1 0 10-1.932.518l.259.966a1 1 0 001.932-.518l-.26-.966zM2.429 4.74a1 1 0 10-.517 1.932l.966.259a1 1 0 00.517-1.932l-.966-.26zm8.814-.569a1 1 0 00-1.415-1.414l-.707.707a1 1 0 101.415 1.415l.707-.708zm-7.071 7.072l.707-.707A1 1 0 003.465 9.12l-.708.707a1 1 0 001.415 1.415zm3.2-5.171a1 1 0 00-1.3 1.3l4 10a1 1 0 001.823.075l1.38-2.759 3.018 3.02a1 1 0 001.414-1.415l-3.019-3.02 2.76-1.379a1 1 0 00-.076-1.822l-10-4z" clipRule="evenodd" />
                                                                                </svg>
                                                                                You Do
                                                                            </span>
                                                                            <span className="text-xs bg-green-100 px-1.5 py-0.5 rounded-full">
                                                                                {selectedPedagogyActivities.youDo.length}
                                                                            </span>
                                                                        </div>
                                                                        <div className="p-1 space-y-1">
                                                                            {activityTypes["youDo"].map(activity => {
                                                                                const mergeSelection = savedPedagogyMergeSelections?.youDo?.[activity];
                                                                                const hasMerge = hasActualMergeSelection(mergeSelection);

                                                                                return (
                                                                                    <div key={`youDo-${activity}`} className="flex items-center justify-between px-1 py-0.5 hover:bg-green-50/50 rounded text-xs group">
                                                                                        <div className="flex items-center space-x-1.5 flex-1 min-w-0">
                                                                                            <Checkbox
                                                                                                id={`youDo-${activity}`}
                                                                                                checked={selectedPedagogyActivities.youDo.includes(activity)}
                                                                                                onCheckedChange={(checked) => {
                                                                                                    const newActivities = { ...selectedPedagogyActivities };
                                                                                                    if (checked) {
                                                                                                        newActivities.youDo = [...newActivities.youDo, activity];
                                                                                                    } else {
                                                                                                        newActivities.youDo = newActivities.youDo.filter(a => a !== activity);
                                                                                                        const newHours = { ...pedagogyHours };
                                                                                                        delete newHours.youDo[activity];
                                                                                                        setPedagogyHours(newHours);
                                                                                                        // Clear merge selection when activity is deselected
                                                                                                        clearPedagogyMergeSelections("youDo", activity);
                                                                                                    }
                                                                                                    setSelectedPedagogyActivities(newActivities);
                                                                                                }}
                                                                                                className="h-3 w-3 data-[state=checked]:bg-blue-600 data-[state=checked]:border-blue-600"
                                                                                            />
                                                                                            <span className="text-slate-700 truncate flex-1">{activity}</span>
                                                                                        </div>

                                                                                        <div className="flex items-center space-x-1">
                                                                                            {selectedPedagogyActivities.youDo.includes(activity) && (
                                                                                                <div className="flex gap-3">
                                                                                                    <div className="flex items-center space-x-0.5">
                                                                                                        <Input
                                                                                                            type="number"
                                                                                                            value={pedagogyHours.youDo[activity] || ""}
                                                                                                            onChange={(e) => {
                                                                                                                const value = parseFloat(e.target.value) || 0;
                                                                                                                setPedagogyHours(prev => ({
                                                                                                                    ...prev,
                                                                                                                    youDo: { ...prev.youDo, [activity]: value }
                                                                                                                }));
                                                                                                            }}
                                                                                                            className="h-5 w-10 text-xs text-center p-0 border-slate-300"
                                                                                                            placeholder="0"
                                                                                                        />
                                                                                                        <span className="text-xs text-slate-500">hrs</span>
                                                                                                    </div>

                                                                                                    {/* Merge button for this specific activity */}
                                                                                                    {!disableAddonlyMode && (
                                                                                                        <button
                                                                                                            type="button"
                                                                                                            onClick={() => {
                                                                                                                setCurrentMergeActivity(activity);
                                                                                                                setShowMergePedagogySection(prev => ({
                                                                                                                    ...prev,
                                                                                                                    youDo: true
                                                                                                                }));
                                                                                                                // Load existing merge selection if it exists
                                                                                                                if (savedPedagogyMergeSelections.youDo[activity]) {
                                                                                                                    editPedagogyMergeSelections("youDo", activity);
                                                                                                                }
                                                                                                            }}
                                                                                                            className={`p-0.5 rounded text-xs ${hasMerge
                                                                                                                ? 'bg-green-100 text-green-700 hover:bg-green-200'
                                                                                                                : 'bg-green-100 text-green-700 hover:bg-green-200'
                                                                                                                } ${(!pedagogyHours.youDo[activity] || pedagogyHours.youDo[activity] <= 0 || isMergeSectionOpen) ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'}`}
                                                                                                            title={hasMerge ? "Edit merge selection" : "Merge with existing items"}
                                                                                                            disabled={!pedagogyHours.youDo[activity] || pedagogyHours.youDo[activity] <= 0 || isMergeSectionOpen}
                                                                                                        >
                                                                                                            {hasMerge ? (<span className="flex gap-1 items-center">
                                                                                                                <SquarePen className="w-3 h-3" /> Edit
                                                                                                            </span>
                                                                                                            ) : (<span className="flex gap-1 items-center">
                                                                                                                <Merge className="w-3 h-3" /> Merge
                                                                                                            </span>
                                                                                                            )}
                                                                                                        </button>
                                                                                                    )}
                                                                                                </div>
                                                                                            )}
                                                                                        </div>
                                                                                    </div>
                                                                                );
                                                                            })}
                                                                        </div>
                                                                    </div>
                                                                )}
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    )}

                                    {/* Column 3: Merge Selection (shown when merge is checked) */}
                                    {(showMergeLevelSection || showMergePedagogySection.iDo || showMergePedagogySection.weDo || showMergePedagogySection.youDo) && (
                                        <div className="space-y-2 md:col-span-1">
                                            <h3 className="text-sm font-semibold text-slate-700 border-b pb-2">
                                                <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
                                                    <div className="flex items-center flex-wrap gap-1">
                                                        <svg
                                                            className="w-4 h-4 text-blue-500 shrink-0"
                                                            fill="currentColor"
                                                            viewBox="0 0 20 20"
                                                        >
                                                            <path
                                                                fillRule="evenodd"
                                                                d="M12.316 3.051a1 1 0 01.633 1.265l-4 12a1 1 0 11-1.898-.632l4-12a1 1 0 011.265-.633zM5.707 6.293a1 1 0 010 1.414L3.414 10l2.293 2.293a1 1 0 11-1.414 1.414l-3-3a1 1 0 010-1.414l3-3a1 1 0 011.414 0zm8.586 0a1 1 0 011.414 0l3 3a1 1 0 010 1.414l-3 3a1 1 0 11-1.414-1.414L16.586 10l-2.293-2.293a1 1 0 010-1.414z"
                                                                clipRule="evenodd"
                                                            />
                                                        </svg>
                                                        <span className="whitespace-nowrap">Merge With</span>
                                                        <span className="text-blue-600 font-semibold whitespace-nowrap">
                                                            {dialogType === "module"
                                                                ? "Module"
                                                                : dialogType === "submodule"
                                                                    ? "Submodule"
                                                                    : dialogType === "topic"
                                                                        ? "Topic"
                                                                        : "Subtopic"}
                                                        </span>
                                                        <span className="whitespace-nowrap">for</span>
                                                        <span className="text-blue-600 font-semibold whitespace-nowrap">
                                                            {showMergeLevelSection ? "Level" : currentMergeActivity}
                                                        </span>
                                                    </div>

                                                    {/* Right side: buttons */}
                                                    <div className="flex space-x-2 shrink-0">
                                                        <button
                                                            type="button"
                                                            onClick={() => {
                                                                const allModuleIds = sortedModules.map(m => m._id);
                                                                const allSubModuleIds = sortedSubModules.map(sm => sm._id);
                                                                const allTopicIds = sortedTopics.map(t => t._id);

                                                                setExpandedModules(new Set(allModuleIds));
                                                                setExpandedSubModules(new Set(allSubModuleIds));
                                                                setExpandedTopics(new Set(allTopicIds));
                                                            }}
                                                            className="text-xs cursor-pointer text-blue-600 hover:text-blue-800 font-medium whitespace-nowrap"
                                                        >
                                                            Expand All
                                                        </button>
                                                        <span className="text-xs text-slate-400">|</span>
                                                        <button
                                                            type="button"
                                                            onClick={() => {
                                                                setExpandedModules(new Set());
                                                                setExpandedSubModules(new Set());
                                                                setExpandedTopics(new Set());
                                                            }}
                                                            className="text-xs cursor-pointer text-blue-600 hover:text-blue-800 font-medium whitespace-nowrap"
                                                        >
                                                            Collapse All
                                                        </button>
                                                    </div>
                                                </div>
                                            </h3>

                                            <div className="max-h-74 overflow-y-auto space-y-4 p-1 border border-slate-100 rounded-lg bg-slate-50/30">
                                                {/* Module-level merging */}
                                                {dialogType === 'module' && (
                                                    <div className="space-y-2">
                                                        <p className="text-xs font-medium text-slate-700 px-2 py-1 bg-slate-100 rounded-md">Modules</p>

                                                        {sortedModules.map((module, index, arr) => {
                                                            const currentModuleId = (editMode as any)?.data?._id;
                                                            const isCurrentModule = module._id === currentModuleId;
                                                            const currentModuleIndex = sortedModules.findIndex(m => m._id === currentModuleId);

                                                            // ✅ Enable modules one by one in sequence around the current module

                                                            const isEnabled = (() => {
                                                                if (isCurrentModule) return false; // Disable the current module itself

                                                                // If adding a new module (not in edit mode)
                                                                if (dialogType === 'module' && !editMode) {
                                                                    // Enable from LAST → FIRST
                                                                    if (index === arr.length - 1) {
                                                                        // Last module is always enabled when adding new
                                                                        return true;
                                                                    } else {
                                                                        // Enable if the NEXT module is selected
                                                                        const nextModule = arr[index + 1];
                                                                        return showMergeLevelSection
                                                                            ? selectedLevelModulesForMerge.has(nextModule?._id)
                                                                            : (selectedPedagogyModulesForMerge.iDo?.[currentMergeActivity]?.has(nextModule?._id) ||
                                                                                selectedPedagogyModulesForMerge.weDo?.[currentMergeActivity]?.has(nextModule?._id) ||
                                                                                selectedPedagogyModulesForMerge.youDo?.[currentMergeActivity]?.has(nextModule?._id));
                                                                    }
                                                                }

                                                                // 🔹 Existing logic for edit mode remains the same
                                                                const currentModuleIndex = sortedModules.findIndex(m => m._id === currentModuleId);
                                                                const moduleIndex = sortedModules.findIndex(m => m._id === module._id);
                                                                const distanceFromCurrent = moduleIndex - currentModuleIndex;

                                                                // For modules BEFORE the current module (negative distance)
                                                                if (distanceFromCurrent > 0) {
                                                                    if (distanceFromCurrent === 1) return true; // Immediate previous

                                                                    const nextModuleIndex = moduleIndex - 1;
                                                                    const nextModule = sortedModules[nextModuleIndex];
                                                                    return showMergeLevelSection
                                                                        ? selectedLevelModulesForMerge.has(nextModule?._id)
                                                                        : (selectedPedagogyModulesForMerge.iDo?.[currentMergeActivity]?.has(nextModule?._id) ||
                                                                            selectedPedagogyModulesForMerge.weDo?.[currentMergeActivity]?.has(nextModule?._id) ||
                                                                            selectedPedagogyModulesForMerge.youDo?.[currentMergeActivity]?.has(nextModule?._id));
                                                                }

                                                                // For modules AFTER the current- module (positive distance)
                                                                if (distanceFromCurrent < 0) {
                                                                    if (distanceFromCurrent === -1) return true; // Immediate next

                                                                    const prevModuleIndex = moduleIndex + 1;
                                                                    const prevModule = sortedModules[prevModuleIndex];
                                                                    return showMergeLevelSection
                                                                        ? selectedLevelModulesForMerge.has(prevModule?._id)
                                                                        : (selectedPedagogyModulesForMerge.iDo?.[currentMergeActivity]?.has(prevModule?._id) ||
                                                                            selectedPedagogyModulesForMerge.weDo?.[currentMergeActivity]?.has(prevModule?._id) ||
                                                                            selectedPedagogyModulesForMerge.youDo?.[currentMergeActivity]?.has(prevModule?._id));
                                                                }

                                                                return false;
                                                            })();

                                                            return (
                                                                <div key={module._id} className={`flex items-center space-x-2 ml-0 px-2 py-1.5 rounded-md transition-colors ${isCurrentModule ? 'bg-blue-50 border border-blue-200' : 'hover:bg-slate-100/50'
                                                                    }`}>
                                                                    {isCurrentModule ? (
                                                                        <div className="w-4 h-4 flex items-center justify-center mr-1">
                                                                            <span className="text-blue-500 text-lg">•</span>
                                                                        </div>
                                                                    ) : (
                                                                        <Checkbox
                                                                            id={`module-${module._id}`}
                                                                            checked={
                                                                                showMergeLevelSection
                                                                                    ? selectedLevelModulesForMerge.has(module._id)
                                                                                    : (showMergePedagogySection.iDo &&
                                                                                        selectedPedagogyModulesForMerge.iDo?.[currentMergeActivity]?.has(module._id)) ||
                                                                                    (showMergePedagogySection.weDo &&
                                                                                        selectedPedagogyModulesForMerge.weDo?.[currentMergeActivity]?.has(module._id)) ||
                                                                                    (showMergePedagogySection.youDo &&
                                                                                        selectedPedagogyModulesForMerge.youDo?.[currentMergeActivity]?.has(module._id))
                                                                            }
                                                                            disabled={!isEnabled}
                                                                            onCheckedChange={(checked) => {
                                                                                if (showMergeLevelSection) {
                                                                                    const newSet = new Set(selectedLevelModulesForMerge);
                                                                                    if (checked) {
                                                                                        newSet.add(module._id);
                                                                                    } else {
                                                                                        newSet.delete(module._id);
                                                                                    }
                                                                                    setSelectedLevelModulesForMerge(newSet);
                                                                                } else {
                                                                                    const activityType =
                                                                                        showMergePedagogySection.iDo ? "iDo" :
                                                                                            showMergePedagogySection.weDo ? "weDo" : "youDo";

                                                                                    if (!selectedPedagogyModulesForMerge[activityType]) {
                                                                                        selectedPedagogyModulesForMerge[activityType] = {};
                                                                                    }
                                                                                    if (!selectedPedagogyModulesForMerge[activityType][currentMergeActivity]) {
                                                                                        selectedPedagogyModulesForMerge[activityType][currentMergeActivity] = new Set();
                                                                                    }

                                                                                    const newSet = new Set(selectedPedagogyModulesForMerge[activityType][currentMergeActivity]);
                                                                                    if (checked) newSet.add(module._id);
                                                                                    else newSet.delete(module._id);

                                                                                    setSelectedPedagogyModulesForMerge({
                                                                                        ...selectedPedagogyModulesForMerge,
                                                                                        [activityType]: {
                                                                                            ...selectedPedagogyModulesForMerge[activityType],
                                                                                            [currentMergeActivity]: newSet
                                                                                        }
                                                                                    });
                                                                                }
                                                                            }}
                                                                        />
                                                                    )}
                                                                    <Label
                                                                        htmlFor={isCurrentModule ? undefined : `module-${module._id}`}
                                                                        className={`text-sm cursor-pointer flex-1 truncate ${isCurrentModule ? 'text-blue-700 font-medium' : 'text-slate-700'
                                                                            }`}
                                                                    >
                                                                        {module.title}
                                                                        {isCurrentModule && <span className="ml-2 text-xs text-blue-500">(Current)</span>}
                                                                    </Label>
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                )}


                                                {/* Submodule-level merging with collapse/expand */}
                                                {dialogType === 'submodule' && (
                                                    <div className="space-y-3">

                                                        {sortedModules.map((module, moduleIndex) => {

                                                            const moduleSubModules = sortedSubModules.filter(
                                                                sm => sm.moduleId === module._id
                                                            );
                                                            const currentSubModuleId = (editMode as any)?.data?._id;
                                                            const currentSubModule = sortedSubModules.find(sm => sm._id === currentSubModuleId);
                                                            const isCurrentModule = currentSubModule?.moduleId === module._id;

                                                            // const hasSubModules = moduleSubModules.length > 0;
                                                            const hasSubModules = sortedSubModules.filter(
                                                                sm => sm.moduleId === module._id
                                                            ).length > 0;
                                                            const selectedIndex = sortedModules.findIndex(
                                                                m => m?._id === selectedModuleForSubModule?.id

                                                            );

                                                            const selectedModuleHasSubModules = sortedSubModules.filter(
                                                                sm => sm.moduleId === selectedModuleForSubModule?.id
                                                                    && sm._id !== (editMode as any)?.data?._id
                                                            ).length > 0;

                                                            // 🔑 Utility function to check if a submodule is selected
                                                            const isSubModuleSelected = (subModuleId: string) => {
                                                                if (showMergeLevelSection) {
                                                                    return selectedLevelSubModulesForMerge.has(subModuleId);
                                                                } else {
                                                                    const activityType = showMergePedagogySection.iDo
                                                                        ? "iDo"
                                                                        : showMergePedagogySection.weDo
                                                                            ? "weDo"
                                                                            : "youDo";
                                                                    return (
                                                                        selectedPedagogySubModulesForMerge[activityType]?.[
                                                                            currentMergeActivity
                                                                        ]?.has(subModuleId) ?? false
                                                                    );
                                                                }
                                                            };

                                                            let isModuleEnabled = false;

                                                            if (moduleIndex === selectedIndex) {
                                                                isModuleEnabled = true;
                                                            } else if (!selectedModuleHasSubModules && selectedIndex !== -1) {
                                                                if (moduleIndex === selectedIndex - 1 || moduleIndex === selectedIndex + 1) {
                                                                    isModuleEnabled = hasSubModules;
                                                                } else {
                                                                    const leftAdjacent = sortedModules[selectedIndex - 1];
                                                                    const rightAdjacent = sortedModules[selectedIndex + 1];

                                                                    if (leftAdjacent && moduleIndex < selectedIndex - 1) {


                                                                        const nextModuleSubModules = sortedSubModules.filter(
                                                                            sm => sm.moduleId === sortedModules[moduleIndex + 1]?._id
                                                                                && sm._id !== (editMode as any)?.data?._id
                                                                        );
                                                                        isModuleEnabled =
                                                                            nextModuleSubModules.length > 0 &&
                                                                            nextModuleSubModules.every(sm => isSubModuleSelected(sm._id));
                                                                    } else if (rightAdjacent && moduleIndex > selectedIndex + 1) {

                                                                        const prevModuleSubModules = sortedSubModules.filter(
                                                                            sm => sm.moduleId === sortedModules[moduleIndex - 1]?._id
                                                                                && sm._id !== (editMode as any)?.data?._id
                                                                        );
                                                                        isModuleEnabled =
                                                                            prevModuleSubModules.length > 0 &&
                                                                            prevModuleSubModules.every(sm => isSubModuleSelected(sm._id));
                                                                    } else {
                                                                        isModuleEnabled = false;
                                                                    }
                                                                }
                                                            } else if (moduleIndex > selectedIndex) {
                                                                const prevModuleSubModules = sortedSubModules.filter(
                                                                    sm => sm.moduleId === sortedModules[moduleIndex - 1]?._id
                                                                        && sm._id !== (editMode as any)?.data?._id
                                                                );
                                                                isModuleEnabled =
                                                                    prevModuleSubModules.length > 0 &&
                                                                    prevModuleSubModules.every(sm => isSubModuleSelected(sm._id));
                                                            } else if (moduleIndex < selectedIndex) {
                                                                const nextModuleSubModules = sortedSubModules.filter(
                                                                    sm => sm.moduleId === sortedModules[moduleIndex + 1]?._id
                                                                        && sm._id !== (editMode as any)?.data?._id
                                                                );
                                                                isModuleEnabled =
                                                                    nextModuleSubModules.length > 0 &&
                                                                    nextModuleSubModules.every(sm => isSubModuleSelected(sm._id));
                                                            }

                                                            if (!hasSubModules && moduleIndex !== selectedIndex && selectedModuleHasSubModules) {
                                                                isModuleEnabled = false;
                                                            }

                                                            const isExpanded = expandedModules.has(module._id);

                                                            return (
                                                                <div key={module._id} className="space-y-1">
                                                                    <div
                                                                        className={`text-xs font-medium text-slate-700 px-2 py-1 rounded-md flex items-center transition-colors
              ${moduleIndex === selectedIndex ? "bg-blue-200 font-semibold" : "bg-blue-50"}
              ${isModuleEnabled ? "cursor-pointer hover:bg-blue-100" : "opacity-50 cursor-not-allowed"}`}
                                                                        onClick={() =>
                                                                            isModuleEnabled &&
                                                                            toggleExpansion(module._id, expandedModules, setExpandedModules)
                                                                        }
                                                                    >
                                                                        {isExpanded ? (
                                                                            <ChevronDownIcon className="w-3 h-3 mr-1 text-blue-500" />
                                                                        ) : (
                                                                            <ChevronRightIcon className="w-3 h-3 mr-1 text-blue-500" />
                                                                        )}
                                                                        <FolderOpen className="w-3 h-3 mr-1.5 text-blue-500" />
                                                                        <span className={isCurrentModule ? 'text-blue-800 font-semibold' : 'text-slate-700'}>
                                                                            {module.title}
                                                                        </span>
                                                                        {isCurrentModule && <span className="ml-2 text-xs text-blue-600">(Current Module)</span>}
                                                                        <span className="ml-auto text-xs text-slate-500">
                                                                            ({moduleSubModules.length})
                                                                        </span>
                                                                    </div>

                                                                    {isExpanded && hasSubModules && (
                                                                        <div className="space-y-1 ml-3 pl-2 border-l border-blue-200">
                                                                            {moduleSubModules.map((subModule, subModuleIndex, arr) => {
                                                                                const isCurrentSubModule = subModule._id === currentSubModuleId;

                                                                                let isSubmoduleEnabled = false;

                                                                                if (moduleIndex < selectedIndex) {
                                                                                    // For modules BEFORE selected module: enable from LAST to FIRST
                                                                                    if (subModuleIndex === arr.length - 1) {
                                                                                        // Last submodule: enabled if module is enabled
                                                                                        isSubmoduleEnabled = isModuleEnabled;
                                                                                    } else {
                                                                                        // Other submodules: enabled if NEXT submodule is selected
                                                                                        const nextSubModule = arr[subModuleIndex + 1];
                                                                                        isSubmoduleEnabled = nextSubModule && isSubModuleSelected(nextSubModule._id);
                                                                                    }
                                                                                }
                                                                                else if (moduleIndex > selectedIndex) {
                                                                                    // For modules AFTER selected module: enable from FIRST to LAST
                                                                                    if (subModuleIndex === 0) {
                                                                                        // First submodule: enabled if module is enabled
                                                                                        isSubmoduleEnabled = isModuleEnabled;
                                                                                    } else {
                                                                                        // Other submodules: enabled if PREVIOUS submodule is selected
                                                                                        const prevSubModule = arr[subModuleIndex - 1];
                                                                                        isSubmoduleEnabled = prevSubModule && isSubModuleSelected(prevSubModule._id);
                                                                                    }
                                                                                }
                                                                                else if (moduleIndex === selectedIndex) {
                                                                                    // ✅ NEW LOGIC: If adding a new submodule in the current module
                                                                                    if (dialogType === 'submodule' && !editMode) {
                                                                                        // Enable from LAST → FIRST
                                                                                        if (subModuleIndex === arr.length - 1) {
                                                                                            // Last submodule enabled if module itself is enabled
                                                                                            isSubmoduleEnabled = isModuleEnabled;
                                                                                        } else {
                                                                                            // Others enabled if NEXT one is selected
                                                                                            const nextSubModule = arr[subModuleIndex + 1];
                                                                                            isSubmoduleEnabled = nextSubModule && isSubModuleSelected(nextSubModule._id);
                                                                                        }
                                                                                    }
                                                                                    // 🔹 Keep your OLD existing logic for edit mode
                                                                                    else {
                                                                                        const currentSubModuleIndex = arr.findIndex(sm => sm._id === currentSubModuleId);

                                                                                        if (subModuleIndex < currentSubModuleIndex) {
                                                                                            if (subModuleIndex === currentSubModuleIndex - 1) {
                                                                                                isSubmoduleEnabled = isModuleEnabled;
                                                                                            } else {
                                                                                                const nextSubModule = arr[subModuleIndex + 1];
                                                                                                isSubmoduleEnabled = nextSubModule && isSubModuleSelected(nextSubModule._id);
                                                                                            }
                                                                                        } else {
                                                                                            if (subModuleIndex === currentSubModuleIndex + 1) {
                                                                                                isSubmoduleEnabled = isModuleEnabled;
                                                                                            } else {
                                                                                                const prevSubModule = arr[subModuleIndex - 1];
                                                                                                isSubmoduleEnabled = prevSubModule && isSubModuleSelected(prevSubModule._id);
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }


                                                                                return (
                                                                                    <div
                                                                                        key={subModule._id}
                                                                                        className={`flex items-center space-x-2 py-1.5 rounded-md transition-colors px-2
                                            ${isCurrentSubModule ? 'bg-blue-50 border border-blue-200' : ''}
                                            ${isSubmoduleEnabled && !isCurrentSubModule ? "hover:bg-slate-100/50" : "opacity-50 cursor-not-allowed"}`}
                                                                                    >

                                                                                        {isCurrentSubModule ? (
                                                                                            <div className="w-4 h-4 flex items-center justify-center mr-1">
                                                                                                <span className="text-blue-500 text-lg">•</span>
                                                                                            </div>
                                                                                        ) : (
                                                                                            <Checkbox
                                                                                                id={`submodule-${subModule._id}`}
                                                                                                disabled={!isSubmoduleEnabled}
                                                                                                checked={
                                                                                                    showMergeLevelSection
                                                                                                        ? selectedLevelSubModulesForMerge.has(subModule._id)
                                                                                                        : (showMergePedagogySection.iDo &&
                                                                                                            selectedPedagogySubModulesForMerge.iDo?.[currentMergeActivity]?.has(subModule._id)) ||
                                                                                                        (showMergePedagogySection.weDo &&
                                                                                                            selectedPedagogySubModulesForMerge.weDo?.[currentMergeActivity]?.has(subModule._id)) ||
                                                                                                        (showMergePedagogySection.youDo &&
                                                                                                            selectedPedagogySubModulesForMerge.youDo?.[currentMergeActivity]?.has(subModule._id))
                                                                                                }
                                                                                                onCheckedChange={(checked) => {
                                                                                                    if (showMergeLevelSection) {
                                                                                                        const newSet = new Set(selectedLevelSubModulesForMerge);
                                                                                                        if (checked) {
                                                                                                            newSet.add(subModule._id);
                                                                                                        } else {
                                                                                                            newSet.delete(subModule._id);
                                                                                                        }
                                                                                                        setSelectedLevelSubModulesForMerge(newSet);
                                                                                                    } else {
                                                                                                        const activityType =
                                                                                                            showMergePedagogySection.iDo ? "iDo" :
                                                                                                                showMergePedagogySection.weDo ? "weDo" : "youDo";

                                                                                                        if (!selectedPedagogySubModulesForMerge[activityType]) {
                                                                                                            selectedPedagogySubModulesForMerge[activityType] = {};
                                                                                                        }
                                                                                                        if (!selectedPedagogySubModulesForMerge[activityType][currentMergeActivity]) {
                                                                                                            selectedPedagogySubModulesForMerge[activityType][currentMergeActivity] = new Set();
                                                                                                        }

                                                                                                        const newSet = new Set(selectedPedagogySubModulesForMerge[activityType][currentMergeActivity]);
                                                                                                        if (checked) newSet.add(subModule._id);
                                                                                                        else newSet.delete(subModule._id);

                                                                                                        setSelectedPedagogySubModulesForMerge({
                                                                                                            ...selectedPedagogySubModulesForMerge,
                                                                                                            [activityType]: {
                                                                                                                ...selectedPedagogySubModulesForMerge[activityType],
                                                                                                                [currentMergeActivity]: newSet
                                                                                                            }
                                                                                                        });
                                                                                                    }
                                                                                                }}
                                                                                            />
                                                                                        )}
                                                                                        {/* // <Label htmlFor={`submodule-${subModule._id}`} className="text-sm text-slate-700 cursor-pointer flex-1 truncate">
                                                                                        //     {subModule.title}
                                                                                        // </Label> */}
                                                                                        <Label
                                                                                            htmlFor={isCurrentSubModule ? undefined : `submodule-${subModule._id}`}
                                                                                            className={`text-sm cursor-pointer flex-1 truncate ${isCurrentSubModule ? 'text-blue-700 font-medium' : 'text-slate-700'}`}
                                                                                        >
                                                                                            {subModule.title}
                                                                                            {isCurrentSubModule && <span className="ml-2 text-xs text-blue-500">(Current Submodule)</span>}
                                                                                        </Label>
                                                                                    </div>
                                                                                );
                                                                            })}
                                                                        </div>
                                                                    )}
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                )}



                                                {/* Topic-level merging with nested collapse/expand */}
                                                {dialogType === 'topic' && (
                                                    <div className="space-y-3">
                                                        {sortedModules.map((module, moduleIndex) => {

                                                            const currentTopicId = (editMode as any)?.data?._id;
                                                            const currentTopic = sortedTopics.find(t => t._id === currentTopicId);
                                                            const currentModule = currentTopic ? sortedModules.find(m => m._id === currentTopic.moduleId) : null;
                                                            const currentSubModule = currentTopic?.subModuleId ?
                                                                sortedSubModules.find(sm => sm._id === currentTopic.subModuleId) : null;

                                                            const isCurrentModule = currentModule?._id === module._id;


                                                            const hierarchyLevels = selectedCourse?.courseHierarchy.map(level => level.toLowerCase()) || [];
                                                            const hasSubModules = hierarchyLevels.includes('sub module');



                                                            const moduleTopics = sortedTopics.filter(t => {
                                                                const isCurrentTopic = t._id === (editMode as any)?.data?._id;
                                                                return t.moduleId === module._id &&
                                                                    (!hasSubModules || !t.subModuleId) &&
                                                                    !isCurrentTopic; // Explicitly exclude current topic
                                                            });

                                                            const moduleSubModules = hasSubModules ?
                                                                sortedSubModules.filter(sm => sm.moduleId === module._id) : [];

                                                            let hasAnyTopics = moduleTopics.length > 0;
                                                            let totalTopicsCount = moduleTopics.length;

                                                            if (hasSubModules) {
                                                                for (const subModule of moduleSubModules) {

                                                                    const subModuleTopics = sortedTopics.filter(t => {
                                                                        const isCurrentTopic = t._id === (editMode as any)?.data?._id;
                                                                        return t.subModuleId === subModule._id && !isCurrentTopic;
                                                                    });
                                                                    totalTopicsCount += subModuleTopics.length;
                                                                    if (subModuleTopics.length > 0) {
                                                                        hasAnyTopics = true;
                                                                    }
                                                                }
                                                            }


                                                            // Determine if module should be enabled
                                                            const selectedModuleIndex = sortedModules.findIndex(
                                                                m => m._id === selectedSubModuleForTopic?.moduleId
                                                            );

                                                            let isModuleEnabled = false;
                                                            const direction = moduleIndex > selectedModuleIndex ? 'after' : moduleIndex < selectedModuleIndex ? 'before' : 'current';

                                                            // Use the appropriate selected topics set based on merge type
                                                            const selectedTopicsForMerge = showMergeLevelSection
                                                                ? selectedLevelTopicsForMerge
                                                                : (showMergePedagogySection.iDo ? selectedPedagogyTopicsForMerge.iDo?.[currentMergeActivity] :
                                                                    showMergePedagogySection.weDo ? selectedPedagogyTopicsForMerge.weDo?.[currentMergeActivity] :
                                                                        selectedPedagogyTopicsForMerge.youDo?.[currentMergeActivity]) || new Set();

                                                            if (direction === 'current') {
                                                                isModuleEnabled = true;
                                                            } else if (direction === 'after') {
                                                                if (hasSubModules) {
                                                                    if (moduleIndex === selectedModuleIndex + 1) {
                                                                        const prevModule = sortedModules[moduleIndex - 1];
                                                                        const isPrevModuleCompleted = areAllSubModulesCompleted(
                                                                            prevModule,
                                                                            sortedSubModules,
                                                                            sortedTopics,
                                                                            selectedTopicsForMerge,
                                                                            selectedSubModuleForTopic?.id,
                                                                            (editMode as any)?.data?._id // Add this parameter

                                                                        );

                                                                        const currentModuleSubModules = sortedSubModules.filter(sm => sm.moduleId === selectedSubModuleForTopic?.moduleId);
                                                                        const currentSubModuleIndex = currentModuleSubModules.findIndex(sm => sm._id === selectedSubModuleForTopic?.id);
                                                                        const lastSubModuleIndex = currentModuleSubModules.length - 1;
                                                                        let isCurrentToLastCompleted = false;

                                                                        if (currentSubModuleIndex !== -1 && currentSubModuleIndex === lastSubModuleIndex) {
                                                                            // const currentSubModuleTopics = sortedTopics.filter(t => t.subModuleId === selectedSubModuleForTopic?.id);
                                                                            const currentSubModuleTopics = sortedTopics.filter(t => {
                                                                                const isCurrentTopic = t._id === (editMode as any)?.data?._id;
                                                                                return t.subModuleId === selectedSubModuleForTopic?.id && !isCurrentTopic;
                                                                            });
                                                                            isCurrentToLastCompleted = currentSubModuleTopics.every(t => selectedTopicsForMerge.has(t._id));
                                                                        } else if (currentSubModuleIndex !== -1) {
                                                                            isCurrentToLastCompleted = true;
                                                                            for (let i = currentSubModuleIndex; i <= lastSubModuleIndex; i++) {
                                                                                const subModuleTopics = sortedTopics.filter(t => t.subModuleId === currentModuleSubModules[i]._id);
                                                                                if (!subModuleTopics.every(t => selectedTopicsForMerge.has(t._id))) {
                                                                                    isCurrentToLastCompleted = false;
                                                                                    break;
                                                                                }
                                                                            }
                                                                        }

                                                                        isModuleEnabled = isPrevModuleCompleted || isCurrentToLastCompleted;
                                                                    } else {
                                                                        const prevModule = sortedModules[moduleIndex - 1];
                                                                        isModuleEnabled = areAllSubModulesCompleted(
                                                                            prevModule,
                                                                            sortedSubModules,
                                                                            sortedTopics,
                                                                            selectedTopicsForMerge,
                                                                            selectedSubModuleForTopic?.id,
                                                                            (editMode as any)?.data?._id // Add this parameter
                                                                        );
                                                                    }
                                                                } else {
                                                                    if (moduleIndex === selectedModuleIndex + 1) {
                                                                        const prevModule = sortedModules[moduleIndex - 1];
                                                                        const isPrevModuleCompleted = areAllModuleTopicsCompleted(
                                                                            prevModule,
                                                                            sortedTopics,
                                                                            selectedTopicsForMerge,
                                                                            (editMode as any)?.data?._id
                                                                        );

                                                                        const currentModuleTopics = sortedTopics.filter(t => t.moduleId === selectedSubModuleForTopic?.moduleId && t._id !== (editMode as any)?.data?._id);
                                                                        const currentTopicIndex = currentModuleTopics.findIndex(t => t._id === (editMode as any)?.data?._id);
                                                                        const lastTopicIndex = currentModuleTopics.length - 1;
                                                                        let isCurrentToLastCompleted = true;

                                                                        if (currentTopicIndex !== -1 && currentTopicIndex === lastTopicIndex) {
                                                                            isCurrentToLastCompleted = true;
                                                                        } else if (currentTopicIndex !== -1) {
                                                                            for (let i = currentTopicIndex + 1; i <= lastTopicIndex; i++) {
                                                                                if (!selectedTopicsForMerge.has(currentModuleTopics[i]._id)) {
                                                                                    isCurrentToLastCompleted = false;
                                                                                    break;
                                                                                }
                                                                            }
                                                                        }

                                                                        isModuleEnabled = isPrevModuleCompleted || isCurrentToLastCompleted;
                                                                    } else {
                                                                        const prevModule = sortedModules[moduleIndex - 1];
                                                                        isModuleEnabled = areAllModuleTopicsCompleted(
                                                                            prevModule,
                                                                            sortedTopics,
                                                                            selectedTopicsForMerge,
                                                                            (editMode as any)?.data?._id
                                                                        );
                                                                    }
                                                                }
                                                            } else if (direction === 'before') {
                                                                if (hasSubModules) {
                                                                    if (moduleIndex === selectedModuleIndex - 1) {
                                                                        const nextModule = sortedModules[moduleIndex + 1];
                                                                        const isNextModuleCompleted = areAllSubModulesCompleted(
                                                                            nextModule,
                                                                            sortedSubModules,
                                                                            sortedTopics,
                                                                            selectedTopicsForMerge,
                                                                            selectedSubModuleForTopic?.id,
                                                                            (editMode as any)?.data?._id // Add this parameter
                                                                        );

                                                                        const currentModuleSubModules = sortedSubModules.filter(sm => sm.moduleId === selectedSubModuleForTopic?.moduleId);
                                                                        const currentSubModuleIndex = currentModuleSubModules.findIndex(sm => sm._id === selectedSubModuleForTopic?.id);
                                                                        let isCurrentToFirstCompleted = false;

                                                                        if (currentSubModuleIndex !== -1 && currentSubModuleIndex === 0) {
                                                                            const currentSubModuleTopics = sortedTopics.filter(t => {
                                                                                const isCurrentTopic = t._id === (editMode as any)?.data?._id;
                                                                                return t.subModuleId === selectedSubModuleForTopic?.id && !isCurrentTopic;
                                                                            });
                                                                            isCurrentToFirstCompleted = currentSubModuleTopics.every(t => selectedTopicsForMerge.has(t._id));
                                                                        } else if (currentSubModuleIndex !== -1) {
                                                                            isCurrentToFirstCompleted = true;
                                                                            for (let i = currentSubModuleIndex; i >= 0; i--) {
                                                                                const subModuleTopics = sortedTopics.filter(t => t.subModuleId === currentModuleSubModules[i]._id);
                                                                                if (!subModuleTopics.every(t => selectedTopicsForMerge.has(t._id))) {
                                                                                    isCurrentToFirstCompleted = false;
                                                                                    break;
                                                                                }
                                                                            }
                                                                        }

                                                                        isModuleEnabled = isNextModuleCompleted || isCurrentToFirstCompleted;
                                                                    } else {
                                                                        const nextModule = sortedModules[moduleIndex + 1];
                                                                        isModuleEnabled = areAllSubModulesCompleted(
                                                                            nextModule,
                                                                            sortedSubModules,
                                                                            sortedTopics,
                                                                            selectedTopicsForMerge,
                                                                            selectedSubModuleForTopic?.id,
                                                                            (editMode as any)?.data?._id // Add this parameter
                                                                        );
                                                                    }
                                                                } else {
                                                                    if (moduleIndex === selectedModuleIndex - 1) {
                                                                        const nextModule = sortedModules[moduleIndex + 1];
                                                                        const isNextModuleCompleted = areAllModuleTopicsCompleted(
                                                                            nextModule,
                                                                            sortedTopics,
                                                                            selectedTopicsForMerge,
                                                                            (editMode as any)?.data?._id
                                                                        );

                                                                        const currentModuleTopics = sortedTopics.filter(t => t.moduleId === selectedSubModuleForTopic?.moduleId && t._id !== (editMode as any)?.data?._id);
                                                                        const currentTopicIndex = currentModuleTopics.findIndex(t => t._id === (editMode as any)?.data?._id);
                                                                        let isCurrentToFirstCompleted = true;

                                                                        if (currentTopicIndex !== -1 && currentTopicIndex === 0) {
                                                                            isCurrentToFirstCompleted = true;
                                                                        } else if (currentTopicIndex !== -1) {
                                                                            for (let i = currentTopicIndex - 1; i >= 0; i--) {
                                                                                if (!selectedTopicsForMerge.has(currentModuleTopics[i]._id)) {
                                                                                    isCurrentToFirstCompleted = false;
                                                                                    break;
                                                                                }
                                                                            }
                                                                        }

                                                                        isModuleEnabled = isNextModuleCompleted || isCurrentToFirstCompleted;
                                                                    } else {
                                                                        const nextModule = sortedModules[moduleIndex + 1];
                                                                        isModuleEnabled = areAllModuleTopicsCompleted(
                                                                            nextModule,
                                                                            sortedTopics,
                                                                            selectedTopicsForMerge,
                                                                            (editMode as any)?.data?._id
                                                                        );
                                                                    }
                                                                }
                                                            }

                                                            const isModuleExpanded = expandedModules.has(module._id);

                                                            return (
                                                                <div key={module._id} className="space-y-2">

                                                                    <div
                                                                        className={`text-xs font-medium text-slate-700 px-2 py-1 rounded-md flex items-center cursor-pointer transition-colors
    ${moduleIndex === selectedModuleIndex ? "bg-blue-200 font-semibold" : "bg-blue-50"}
    ${isModuleEnabled ? "hover:bg-blue-100" : "opacity-50 cursor-not-allowed"}
    ${isCurrentModule ? 'border border-blue-300' : ''}`} // Add border for current module
                                                                        onClick={() => isModuleEnabled && toggleExpansion(module._id, expandedModules, setExpandedModules)}
                                                                    >
                                                                        {isModuleExpanded ? (
                                                                            <ChevronDownIcon className="w-3 h-3 mr-1 text-blue-500" />
                                                                        ) : (
                                                                            <ChevronRightIcon className="w-3 h-3 mr-1 text-blue-500" />
                                                                        )}
                                                                        <FolderOpen className="w-3 h-3 mr-1.5 text-blue-500" />

                                                                        <span className={isCurrentModule ? 'text-blue-800 font-semibold' : 'text-slate-700'}>
                                                                            {module.title}
                                                                        </span>
                                                                        {isCurrentModule && <span className="ml-2 text-xs text-blue-600">(Current Module)</span>}
                                                                        <span className="ml-auto text-xs text-slate-500">({totalTopicsCount})</span>
                                                                    </div>

                                                                    {isModuleExpanded && (
                                                                        <>
                                                                            {!hasSubModules && moduleTopics.length > 0 && (
                                                                                <div className="space-y-1 ml-3 pl-2 border-l border-blue-200">
                                                                                    {moduleTopics.map((topic, topicIndex, arr) => {
                                                                                        const isCurrentTopic = (editMode as any)?.data?._id === topic._id;
                                                                                        const prevTopic = direction === 'after' ? arr[topicIndex - 1] : arr[topicIndex + 1];
                                                                                        const isTopicEnabled = isModuleEnabled && (isCurrentTopic || !prevTopic || selectedTopicsForMerge.has(prevTopic._id));

                                                                                        return (

                                                                                            <div key={topic._id} className={`flex items-center space-x-2 py-1.5 rounded-md transition-colors px-2
          ${isTopicEnabled ? "hover:bg-slate-100/50" : "opacity-50 cursor-not-allowed"}
          ${isCurrentTopic ? "bg-green-50 border border-green-200" : ""}`}>

                                                                                                {isCurrentTopic ? (
                                                                                                    <div className="w-4 h-4 flex items-center justify-center mr-1">
                                                                                                        <span className="text-green-500 text-lg">•</span>
                                                                                                    </div>
                                                                                                ) : (
                                                                                                    <Checkbox
                                                                                                        id={`topic-${topic._id}`}
                                                                                                        checked={selectedTopicsForMerge.has(topic._id) || isCurrentTopic}
                                                                                                        disabled={!isTopicEnabled || isCurrentTopic}
                                                                                                        onCheckedChange={(checked) => {
                                                                                                            if (isCurrentTopic) return;

                                                                                                            const newSelectedTopics = new Set(selectedTopicsForMerge);

                                                                                                            if (checked) {
                                                                                                                newSelectedTopics.add(topic._id);
                                                                                                            } else {
                                                                                                                // Get all topics in order
                                                                                                                const allTopics: any = [];
                                                                                                                sortedModules.forEach(mod => {
                                                                                                                    const hasSubMods = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()).includes('sub module');
                                                                                                                    if (hasSubMods) {
                                                                                                                        sortedSubModules.filter(sm => sm.moduleId === mod._id).forEach(sm => {
                                                                                                                            sortedTopics.filter(t => t.subModuleId === sm._id).forEach(t => allTopics.push(t._id));
                                                                                                                        });
                                                                                                                    } else {
                                                                                                                        sortedTopics.filter(t => t.moduleId === mod._id).forEach(t => allTopics.push(t._id));
                                                                                                                    }
                                                                                                                });

                                                                                                                const currentIndex = allTopics.indexOf(topic._id);
                                                                                                                newSelectedTopics.delete(topic._id);

                                                                                                                if (direction === 'after' || direction === 'current') {
                                                                                                                    // Remove all topics after this one
                                                                                                                    for (let i = currentIndex + 1; i < allTopics.length; i++) {
                                                                                                                        newSelectedTopics.delete(allTopics[i]);
                                                                                                                    }
                                                                                                                } else {
                                                                                                                    // Remove all topics before this one
                                                                                                                    for (let i = currentIndex - 1; i >= 0; i--) {
                                                                                                                        newSelectedTopics.delete(allTopics[i]);
                                                                                                                    }
                                                                                                                }
                                                                                                            }

                                                                                                            // Update the appropriate state based on merge type
                                                                                                            if (showMergeLevelSection) {
                                                                                                                setSelectedLevelTopicsForMerge(newSelectedTopics);
                                                                                                            } else {
                                                                                                                const activityType = showMergePedagogySection.iDo ? "iDo" :
                                                                                                                    showMergePedagogySection.weDo ? "weDo" : "youDo";

                                                                                                                setSelectedPedagogyTopicsForMerge({
                                                                                                                    ...selectedPedagogyTopicsForMerge,
                                                                                                                    [activityType]: {
                                                                                                                        ...selectedPedagogyTopicsForMerge[activityType],
                                                                                                                        [currentMergeActivity]: newSelectedTopics
                                                                                                                    }
                                                                                                                });
                                                                                                            }
                                                                                                        }}
                                                                                                    />
                                                                                                )}

                                                                                                <Label
                                                                                                    htmlFor={isCurrentTopic ? undefined : `topic-${topic._id}`}
                                                                                                    className={`text-sm flex-1 truncate ${isTopicEnabled ? "cursor-pointer" : "cursor-not-allowed"} 
              ${isCurrentTopic ? "text-green-700 font-medium" : "text-slate-700"}`}
                                                                                                >
                                                                                                    {topic.title}
                                                                                                    {isCurrentTopic && <span className="ml-2 text-xs text-green-600">(Current Topic)</span>}
                                                                                                </Label>
                                                                                            </div>
                                                                                        );
                                                                                    })}
                                                                                </div>
                                                                            )}

                                                                            {hasSubModules && moduleSubModules.map((subModule, subIndex) => {


                                                                                const subModuleTopics = sortedTopics.filter(t => t.subModuleId === subModule._id && t._id !== (editMode as any)?.data?._id);



                                                                                const isCurrentSubModule = selectedSubModuleForTopic?.id === subModule._id;
                                                                                const isSubModuleExpanded = expandedSubModules.has(subModule._id);


                                                                                // Determine if submodule should be enabled
                                                                                let isSubModuleEnabled = false;



                                                                                const currentSubModuleIndex = moduleSubModules.findIndex(sm => sm._id === selectedSubModuleForTopic?.id);
                                                                                const direction = subIndex > currentSubModuleIndex ? 'after' :
                                                                                    subIndex < currentSubModuleIndex ? 'before' : 'current';




                                                                                if (isModuleEnabled) {
                                                                                    if (direction === 'current') {
                                                                                        // ✅ Current submodule is always enabled
                                                                                        isSubModuleEnabled = true;

                                                                                        // If it has no topics, mark it as "completed" for enablement of neighbors
                                                                                        const currentSubModuleTopics = sortedTopics.filter(t => t.subModuleId === subModule._id);
                                                                                        const isCurrentEmpty = currentSubModuleTopics.length === 0;
                                                                                        if (isCurrentEmpty) {
                                                                                            // Add its topics to selectedTopicsForMerge so neighbors see it as completed
                                                                                            currentSubModuleTopics.forEach(t => selectedTopicsForMerge.add(t._id));
                                                                                        }



                                                                                    } else if (direction === 'after') {
                                                                                        const prevSubModule = moduleSubModules[subIndex - 1];

                                                                                        // Check if this is the first submodule right after current
                                                                                        const isImmediatelyAfterCurrent = subIndex === currentSubModuleIndex + 1;

                                                                                        if (isImmediatelyAfterCurrent) {
                                                                                            // Enable immediately - no need to check if all topics are selected
                                                                                            isSubModuleEnabled = true;
                                                                                        } else {
                                                                                            // For subsequent submodules, check if previous is complete
                                                                                            const prevSubModuleTopics = sortedTopics.filter(t =>
                                                                                                t.subModuleId === prevSubModule._id &&
                                                                                                t._id !== (editMode as any)?.data?._id
                                                                                            );

                                                                                            isSubModuleEnabled = prevSubModuleTopics.length > 0 &&
                                                                                                prevSubModuleTopics.every(t => selectedTopicsForMerge.has(t._id));
                                                                                        }
                                                                                    }


                                                                                    else if (direction === 'before') {
                                                                                        if (subIndex === moduleSubModules.length - 1) {
                                                                                            isSubModuleEnabled = true;
                                                                                        } else {
                                                                                            const nextSubModule = moduleSubModules[subIndex + 1];
                                                                                            const nextSubModuleTopics = sortedTopics.filter(t => t.subModuleId === nextSubModule._id);

                                                                                            isSubModuleEnabled =
                                                                                                nextSubModuleTopics.length === 0
                                                                                                    ? nextSubModule._id === selectedSubModuleForTopic?.id // only enable if next is current
                                                                                                    : nextSubModuleTopics.every(t => selectedTopicsForMerge.has(t._id));
                                                                                        }
                                                                                    }
                                                                                }


                                                                                return (
                                                                                    <div key={subModule._id} className="space-y-1 ml-3 pl-2 border-l border-blue-200">
                                                                                        <div
                                                                                            className={`text-xs font-medium text-slate-600 px-2 py-1 rounded-md flex items-center cursor-pointer transition-colors
                                                ${isCurrentSubModule ? "bg-amber-200 font-semibold" : "bg-amber-50"}
                                                ${isSubModuleEnabled ? "hover:bg-amber-100" : "opacity-50 cursor-not-allowed"}`}
                                                                                            onClick={() => isSubModuleEnabled && toggleExpansion(subModule._id, expandedSubModules, setExpandedSubModules)}
                                                                                        >
                                                                                            {isSubModuleExpanded ? (
                                                                                                <ChevronDownIcon className="w-3 h-3 mr-1 text-amber-500" />
                                                                                            ) : (
                                                                                                <ChevronRightIcon className="w-3 h-3 mr-1 text-amber-500" />
                                                                                            )}
                                                                                            <Layers className="w-3 h-3 mr-1.5 text-amber-500" />
                                                                                            {/* {subModule.title} */}
                                                                                            <span className={isCurrentSubModule ? 'text-amber-800 font-semibold' : 'text-slate-600'}>
                                                                                                {subModule.title}
                                                                                            </span>
                                                                                            {isCurrentSubModule && <span className="ml-2 text-xs text-amber-600">(Current Submodule)</span>}
                                                                                            <span className="ml-auto text-xs text-slate-500">({subModuleTopics.length})</span>
                                                                                        </div>
                                                                                        {isSubModuleExpanded && (
                                                                                            <div className="space-y-1 ml-3 pl-2 border-l border-amber-200">
                                                                                                {subModuleTopics.map((topic, topicIndex, arr) => {
                                                                                                    const isCurrentTopic = (editMode as any)?.data?._id === topic._id;
                                                                                                    const prevTopic = direction === 'after' ? arr[topicIndex - 1] : arr[topicIndex + 1];
                                                                                                    const isTopicEnabled = isSubModuleEnabled && (isCurrentTopic || !prevTopic || selectedTopicsForMerge.has(prevTopic._id));

                                                                                                    return (
                                                                                                        <div key={topic._id} className={`flex items-center space-x-2 py-1.5 rounded-md transition-colors px-2
                                                            ${isTopicEnabled ? "hover:bg-slate-100/50" : "opacity-50 cursor-not-allowed"}
                                                            ${isCurrentTopic ? "bg-green-50" : ""}`}>
                                                                                                            <Checkbox
                                                                                                                id={`topic-${topic._id}`}
                                                                                                                checked={selectedTopicsForMerge.has(topic._id) || isCurrentTopic}
                                                                                                                disabled={!isTopicEnabled || isCurrentTopic}
                                                                                                                // Replace the existing onCheckedChange logic in both module topics and submodule topics sections

                                                                                                                onCheckedChange={(checked) => {
                                                                                                                    if (isCurrentTopic) return;

                                                                                                                    const newSelectedTopics = new Set(selectedTopicsForMerge);

                                                                                                                    if (checked) {
                                                                                                                        newSelectedTopics.add(topic._id);
                                                                                                                    } else {
                                                                                                                        // Get all topics in order
                                                                                                                        const allTopics: any = [];
                                                                                                                        sortedModules.forEach(mod => {
                                                                                                                            const hasSubMods = selectedCourse?.courseHierarchy.map(l => l.toLowerCase()).includes('sub module');
                                                                                                                            if (hasSubMods) {
                                                                                                                                sortedSubModules.filter(sm => sm.moduleId === mod._id).forEach(sm => {
                                                                                                                                    sortedTopics.filter(t => t.subModuleId === sm._id).forEach(t => allTopics.push(t._id));
                                                                                                                                });
                                                                                                                            } else {
                                                                                                                                sortedTopics.filter(t => t.moduleId === mod._id).forEach(t => allTopics.push(t._id));
                                                                                                                            }
                                                                                                                        });

                                                                                                                        const currentIndex = allTopics.indexOf(topic._id);
                                                                                                                        const currentTopicId = (editMode as any)?.data?._id;
                                                                                                                        const currentTopicIndex = allTopics.indexOf(currentTopicId);

                                                                                                                        newSelectedTopics.delete(topic._id);

                                                                                                                        // Determine if we're deselecting above or below the current topic
                                                                                                                        if (currentIndex < currentTopicIndex) {
                                                                                                                            // Deselecting above current topic - remove all topics below the deselected one (towards current)
                                                                                                                            for (let i = currentIndex + 1; i < allTopics.length; i++) {
                                                                                                                                newSelectedTopics.delete(allTopics[i]);
                                                                                                                            }
                                                                                                                        } else if (currentIndex > currentTopicIndex) {
                                                                                                                            // Deselecting below current topic - remove all topics above the deselected one (towards current)
                                                                                                                            for (let i = 0; i < currentIndex; i++) {
                                                                                                                                newSelectedTopics.delete(allTopics[i]);
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }

                                                                                                                    // Update the appropriate state based on merge type
                                                                                                                    if (showMergeLevelSection) {
                                                                                                                        setSelectedLevelTopicsForMerge(newSelectedTopics);
                                                                                                                    } else {
                                                                                                                        const activityType = showMergePedagogySection.iDo ? "iDo" :
                                                                                                                            showMergePedagogySection.weDo ? "weDo" : "youDo";

                                                                                                                        setSelectedPedagogyTopicsForMerge({
                                                                                                                            ...selectedPedagogyTopicsForMerge,
                                                                                                                            [activityType]: {
                                                                                                                                ...selectedPedagogyTopicsForMerge[activityType],
                                                                                                                                [currentMergeActivity]: newSelectedTopics
                                                                                                                            }
                                                                                                                        });
                                                                                                                    }
                                                                                                                }}
                                                                                                            />
                                                                                                            <Label htmlFor={`topic-${topic._id}`} className={`text-sm text-slate-700 flex-1 truncate ${isTopicEnabled ? "cursor-pointer" : "cursor-not-allowed"} ${isCurrentTopic ? "font-medium" : ""}`}>
                                                                                                                {topic.title} {isCurrentTopic && "(Current)"}
                                                                                                            </Label>
                                                                                                        </div>
                                                                                                    );
                                                                                                })}
                                                                                            </div>
                                                                                        )}
                                                                                    </div>
                                                                                );
                                                                            })}
                                                                        </>
                                                                    )}
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                )}

                                                {/* Subtopic-level merging with multi-level collapse/expand */}
                                                {dialogType === 'subtopic' && (
                                                    <div className="space-y-3">
                                                        {sortedModules.map(module => {
                                                            const hierarchyLevels = selectedCourse?.courseHierarchy.map(level => level.toLowerCase()) || [];
                                                            const hasSubModules = hierarchyLevels.includes('sub module');

                                                            const moduleTopics = sortedTopics.filter(t =>
                                                                t.moduleId === module._id &&
                                                                (!hasSubModules || !t.subModuleId)
                                                            );

                                                            const moduleSubModules = hasSubModules ?
                                                                sortedSubModules.filter(sm => sm.moduleId === module._id) : [];

                                                            let hasAnySubtopics = false;
                                                            let totalSubtopicsCount = 0;

                                                            for (const topic of moduleTopics) {
                                                                const topicSubTopics = sortedSubTopics.filter(st =>
                                                                    st.topicId === topic._id &&
                                                                    st._id !== (editMode as any)?.data?._id
                                                                );
                                                                totalSubtopicsCount += topicSubTopics.length;
                                                                if (topicSubTopics.length > 0) {
                                                                    hasAnySubtopics = true;
                                                                }
                                                            }

                                                            if (hasSubModules && !hasAnySubtopics) {
                                                                for (const subModule of moduleSubModules) {
                                                                    const subModuleTopics = sortedTopics.filter(t => t.subModuleId === subModule._id);
                                                                    for (const topic of subModuleTopics) {
                                                                        const topicSubTopics = sortedSubTopics.filter(st =>
                                                                            st.topicId === topic._id &&
                                                                            st._id !== (editMode as any)?.data?._id
                                                                        );
                                                                        totalSubtopicsCount += topicSubTopics.length;
                                                                        if (topicSubTopics.length > 0) {
                                                                            hasAnySubtopics = true;
                                                                        }
                                                                    }
                                                                }
                                                            }

                                                            if (!hasAnySubtopics) return null;

                                                            const isModuleExpanded = expandedModules.has(module._id);

                                                            return (
                                                                <div key={module._id} className="space-y-3">
                                                                    <div
                                                                        className="text-xs font-medium text-slate-700 px-2 py-1 bg-blue-50 rounded-md flex items-center cursor-pointer hover:bg-blue-100 transition-colors"
                                                                        onClick={() => toggleExpansion(module._id, expandedModules, setExpandedModules)}
                                                                    >
                                                                        {isModuleExpanded ? (
                                                                            <ChevronDownIcon className="w-3 h-3 mr-1 text-blue-500" />
                                                                        ) : (
                                                                            <ChevronRightIcon className="w-3 h-3 mr-1 text-blue-500" />
                                                                        )}
                                                                        <FolderOpen className="w-3 h-3 mr-1.5 text-blue-500" />
                                                                        {module.title}
                                                                        <span className="ml-auto text-xs text-slate-500">({totalSubtopicsCount})</span>
                                                                    </div>

                                                                    {isModuleExpanded && (
                                                                        <>
                                                                            {!hasSubModules && moduleTopics.map(topic => {
                                                                                const topicSubTopics = sortedSubTopics.filter(st =>
                                                                                    st.topicId === topic._id &&
                                                                                    st._id !== (editMode as any)?.data?._id
                                                                                );

                                                                                if (topicSubTopics.length === 0) return null;

                                                                                const isTopicExpanded = expandedTopics.has(topic._id);

                                                                                return (
                                                                                    <div key={topic._id} className="space-y-1 ml-3 pl-2 border-l border-blue-200">
                                                                                        <div
                                                                                            className="text-xs font-medium text-slate-600 px-2 py-1 bg-amber-50 rounded-md flex items-center cursor-pointer hover:bg-amber-100 transition-colors"
                                                                                            onClick={() => toggleExpansion(topic._id, expandedTopics, setExpandedTopics)}
                                                                                        >
                                                                                            {isTopicExpanded ? (
                                                                                                <ChevronDownIcon className="w-3 h-3 mr-1 text-amber-500" />
                                                                                            ) : (
                                                                                                <ChevronRightIcon className="w-3 h-3 mr-1 text-amber-500" />
                                                                                            )}
                                                                                            <Layers className="w-3 h-3 mr-1.5 text-amber-500" />
                                                                                            {topic.title}
                                                                                            <span className="ml-auto text-xs text-slate-500">({topicSubTopics.length})</span>
                                                                                        </div>
                                                                                        {isTopicExpanded && (
                                                                                            <div className="space-y-1 ml-3 pl-2 border-l border-amber-200">
                                                                                                {topicSubTopics.map(subTopic => (
                                                                                                    <div key={subTopic._id} className="flex items-center space-x-2 py-1.5 hover:bg-slate-100/50 rounded-md transition-colors px-2">
                                                                                                        <Checkbox
                                                                                                            id={`subtopic-${subTopic._id}`}
                                                                                                            checked={
                                                                                                                showMergeLevelSection
                                                                                                                    ? selectedLevelSubTopicsForMerge.has(subTopic._id)
                                                                                                                    : (showMergePedagogySection.iDo &&
                                                                                                                        selectedPedagogySubTopicsForMerge.iDo?.[currentMergeActivity]?.has(subTopic._id)) ||
                                                                                                                    (showMergePedagogySection.weDo &&
                                                                                                                        selectedPedagogySubTopicsForMerge.weDo?.[currentMergeActivity]?.has(subTopic._id)) ||
                                                                                                                    (showMergePedagogySection.youDo &&
                                                                                                                        selectedPedagogySubTopicsForMerge.youDo?.[currentMergeActivity]?.has(subTopic._id))
                                                                                                            }
                                                                                                            onCheckedChange={(checked) => {
                                                                                                                if (showMergeLevelSection) {
                                                                                                                    const newSet = new Set(selectedLevelSubTopicsForMerge);
                                                                                                                    if (checked) {
                                                                                                                        newSet.add(subTopic._id);
                                                                                                                    } else {
                                                                                                                        newSet.delete(subTopic._id);
                                                                                                                    }
                                                                                                                    setSelectedLevelSubTopicsForMerge(newSet);
                                                                                                                } else {
                                                                                                                    const activityType =
                                                                                                                        showMergePedagogySection.iDo ? "iDo" :
                                                                                                                            showMergePedagogySection.weDo ? "weDo" : "youDo";

                                                                                                                    // Initialize if not exists
                                                                                                                    if (!selectedPedagogySubTopicsForMerge[activityType]) {
                                                                                                                        selectedPedagogySubTopicsForMerge[activityType] = {};
                                                                                                                    }
                                                                                                                    if (!selectedPedagogySubTopicsForMerge[activityType][currentMergeActivity]) {
                                                                                                                        selectedPedagogySubTopicsForMerge[activityType][currentMergeActivity] = new Set();
                                                                                                                    }

                                                                                                                    const newSet = new Set(selectedPedagogySubTopicsForMerge[activityType][currentMergeActivity]);
                                                                                                                    if (checked) newSet.add(subTopic._id);
                                                                                                                    else newSet.delete(subTopic._id);

                                                                                                                    setSelectedPedagogySubTopicsForMerge({
                                                                                                                        ...selectedPedagogySubTopicsForMerge,
                                                                                                                        [activityType]: {
                                                                                                                            ...selectedPedagogySubTopicsForMerge[activityType],
                                                                                                                            [currentMergeActivity]: newSet
                                                                                                                        }
                                                                                                                    });
                                                                                                                }
                                                                                                            }}
                                                                                                        />
                                                                                                        <Label htmlFor={`subtopic-${subTopic._id}`} className="text-sm text-slate-700 cursor-pointer flex-1 truncate">
                                                                                                            {subTopic.title}
                                                                                                        </Label>
                                                                                                    </div>
                                                                                                ))}
                                                                                            </div>
                                                                                        )}
                                                                                    </div>
                                                                                );
                                                                            })}

                                                                            {hasSubModules && moduleSubModules.map(subModule => {
                                                                                const subModuleTopics = sortedTopics.filter(t => t.subModuleId === subModule._id);

                                                                                let subModuleHasSubtopics = false;
                                                                                let subModuleSubtopicsCount = 0;
                                                                                for (const topic of subModuleTopics) {
                                                                                    const topicSubTopics = sortedSubTopics.filter(st =>
                                                                                        st.topicId === topic._id &&
                                                                                        st._id !== (editMode as any)?.data?._id
                                                                                    );
                                                                                    subModuleSubtopicsCount += topicSubTopics.length;
                                                                                    if (topicSubTopics.length > 0) {
                                                                                        subModuleHasSubtopics = true;
                                                                                    }
                                                                                }

                                                                                if (!subModuleHasSubtopics) return null;

                                                                                const isSubModuleExpanded = expandedSubModules.has(subModule._id);

                                                                                return (
                                                                                    <div key={subModule._id} className="space-y-2 ml-3 pl-2 border-l border-blue-200">
                                                                                        <div
                                                                                            className="text-xs font-medium text-slate-600 px-2 py-1 bg-amber-50 rounded-md flex items-center cursor-pointer hover:bg-amber-100 transition-colors"
                                                                                            onClick={() => toggleExpansion(subModule._id, expandedSubModules, setExpandedSubModules)}
                                                                                        >
                                                                                            {isSubModuleExpanded ? (
                                                                                                <ChevronDownIcon className="w-3 h-3 mr-1 text-amber-500" />
                                                                                            ) : (
                                                                                                <ChevronRightIcon className="w-3 h-3 mr-1 text-amber-500" />
                                                                                            )}
                                                                                            <Layers className="w-3 h-3 mr-1.5 text-amber-500" />
                                                                                            {subModule.title}
                                                                                            <span className="ml-auto text-xs text-slate-500">({subModuleSubtopicsCount})</span>
                                                                                        </div>

                                                                                        {isSubModuleExpanded && subModuleTopics.map(topic => {
                                                                                            const topicSubTopics = sortedSubTopics.filter(st =>
                                                                                                st.topicId === topic._id &&
                                                                                                st._id !== (editMode as any)?.data?._id
                                                                                            );

                                                                                            if (topicSubTopics.length === 0) return null;

                                                                                            const isTopicExpanded = expandedTopics.has(topic._id);

                                                                                            return (
                                                                                                <div key={topic._id} className="space-y-1 ml-3 pl-2 border-l border-amber-200">
                                                                                                    <div
                                                                                                        className="text-xs text-slate-600 px-2 py-1 bg-green-50 rounded-md flex items-center cursor-pointer hover:bg-green-100 transition-colors"
                                                                                                        onClick={() => toggleExpansion(topic._id, expandedTopics, setExpandedTopics)}
                                                                                                    >
                                                                                                        {isTopicExpanded ? (
                                                                                                            <ChevronDownIcon className="w-3 h-3 mr-1 text-green-500" />
                                                                                                        ) : (
                                                                                                            <ChevronRightIcon className="w-3 h-3 mr-1 text-green-500" />
                                                                                                        )}
                                                                                                        <FileText className="w-3 h-3 mr-1.5 text-green-500" />
                                                                                                        {topic.title}
                                                                                                        <span className="ml-auto text-xs text-slate-500">({topicSubTopics.length})</span>
                                                                                                    </div>
                                                                                                    {isTopicExpanded && (
                                                                                                        <div className="space-y-1 ml-3 pl-2 border-l border-green-200">
                                                                                                            {topicSubTopics.map(subTopic => (
                                                                                                                <div key={subTopic._id} className="flex items-center space-x-2 py-1.5 hover:bg-slate-100/50 rounded-md transition-colors px-2">
                                                                                                                    <Checkbox
                                                                                                                        id={`subtopic-${subTopic._id}`}
                                                                                                                        checked={
                                                                                                                            showMergeLevelSection
                                                                                                                                ? selectedLevelSubTopicsForMerge.has(subTopic._id)
                                                                                                                                : (showMergePedagogySection.iDo &&
                                                                                                                                    selectedPedagogySubTopicsForMerge.iDo?.[currentMergeActivity]?.has(subTopic._id)) ||
                                                                                                                                (showMergePedagogySection.weDo &&
                                                                                                                                    selectedPedagogySubTopicsForMerge.weDo?.[currentMergeActivity]?.has(subTopic._id)) ||
                                                                                                                                (showMergePedagogySection.youDo &&
                                                                                                                                    selectedPedagogySubTopicsForMerge.youDo?.[currentMergeActivity]?.has(subTopic._id))
                                                                                                                        }
                                                                                                                        onCheckedChange={(checked) => {
                                                                                                                            if (showMergeLevelSection) {
                                                                                                                                const newSet = new Set(selectedLevelSubTopicsForMerge);
                                                                                                                                if (checked) {
                                                                                                                                    newSet.add(subTopic._id);
                                                                                                                                } else {
                                                                                                                                    newSet.delete(subTopic._id);
                                                                                                                                }
                                                                                                                                setSelectedLevelSubTopicsForMerge(newSet);
                                                                                                                            } else {
                                                                                                                                const activityType =
                                                                                                                                    showMergePedagogySection.iDo ? "iDo" :
                                                                                                                                        showMergePedagogySection.weDo ? "weDo" : "youDo";

                                                                                                                                // Initialize if not exists
                                                                                                                                if (!selectedPedagogySubTopicsForMerge[activityType]) {
                                                                                                                                    selectedPedagogySubTopicsForMerge[activityType] = {};
                                                                                                                                }
                                                                                                                                if (!selectedPedagogySubTopicsForMerge[activityType][currentMergeActivity]) {
                                                                                                                                    selectedPedagogySubTopicsForMerge[activityType][currentMergeActivity] = new Set();
                                                                                                                                }

                                                                                                                                const newSet = new Set(selectedPedagogySubTopicsForMerge[activityType][currentMergeActivity]);
                                                                                                                                if (checked) newSet.add(subTopic._id);
                                                                                                                                else newSet.delete(subTopic._id);

                                                                                                                                setSelectedPedagogySubTopicsForMerge({
                                                                                                                                    ...selectedPedagogySubTopicsForMerge,
                                                                                                                                    [activityType]: {
                                                                                                                                        ...selectedPedagogySubTopicsForMerge[activityType],
                                                                                                                                        [currentMergeActivity]: newSet
                                                                                                                                    }
                                                                                                                                });
                                                                                                                            }
                                                                                                                        }}
                                                                                                                    />
                                                                                                                    <Label htmlFor={`subtopic-${subTopic._id}`} className="text-sm text-slate-700 cursor-pointer flex-1 truncate">
                                                                                                                        {subTopic.title}
                                                                                                                    </Label>
                                                                                                                </div>
                                                                                                            ))}
                                                                                                        </div>
                                                                                                    )}
                                                                                                </div>
                                                                                            );
                                                                                        })}
                                                                                    </div>
                                                                                );
                                                                            })}
                                                                        </>
                                                                    )}
                                                                </div>
                                                            );
                                                        })}
                                                    </div>
                                                )}
                                            </div>

                                            {/* Save button for merge selections */}
                                            <div className="flex justify-end gap-2 pt-2">
                                                <Button
                                                    type="button"
                                                    variant="outline"
                                                    size="sm"
                                                    onClick={() => {
                                                        if (showMergeLevelSection) {
                                                            setShowMergeLevelSection(false);
                                                            // Clear level selections
                                                            setSelectedLevelModulesForMerge(new Set());
                                                            setSelectedLevelSubModulesForMerge(new Set());
                                                            setSelectedLevelTopicsForMerge(new Set());
                                                            setSelectedLevelSubTopicsForMerge(new Set());
                                                        }
                                                        if (showMergePedagogySection.iDo) {
                                                            setShowMergePedagogySection(prev => ({ ...prev, iDo: false }));
                                                            setSelectedPedagogyModulesForMerge(prev => ({
                                                                ...prev,
                                                                iDo: {
                                                                    ...prev.iDo,
                                                                    [currentMergeActivity]: new Set()
                                                                }
                                                            }));
                                                            setSelectedPedagogySubModulesForMerge(prev => ({
                                                                ...prev,
                                                                iDo: {
                                                                    ...prev.iDo,
                                                                    [currentMergeActivity]: new Set()
                                                                }
                                                            }));
                                                            setSelectedPedagogyTopicsForMerge(prev => ({
                                                                ...prev,
                                                                iDo: {
                                                                    ...prev.iDo,
                                                                    [currentMergeActivity]: new Set()
                                                                }
                                                            }));
                                                            setSelectedPedagogySubTopicsForMerge(prev => ({
                                                                ...prev,
                                                                iDo: {
                                                                    ...prev.iDo,
                                                                    [currentMergeActivity]: new Set()
                                                                }
                                                            }));
                                                        }
                                                        if (showMergePedagogySection.weDo) {
                                                            setShowMergePedagogySection(prev => ({ ...prev, weDo: false }));
                                                            setSelectedPedagogyModulesForMerge(prev => ({
                                                                ...prev,
                                                                weDo: {
                                                                    ...prev.weDo,
                                                                    [currentMergeActivity]: new Set()
                                                                }
                                                            }));
                                                            setSelectedPedagogySubModulesForMerge(prev => ({
                                                                ...prev,
                                                                weDo: {
                                                                    ...prev.weDo,
                                                                    [currentMergeActivity]: new Set()
                                                                }
                                                            }));
                                                            setSelectedPedagogyTopicsForMerge(prev => ({
                                                                ...prev,
                                                                weDo: {
                                                                    ...prev.weDo,
                                                                    [currentMergeActivity]: new Set()
                                                                }
                                                            }));
                                                            setSelectedPedagogySubTopicsForMerge(prev => ({
                                                                ...prev,
                                                                weDo: {
                                                                    ...prev.weDo,
                                                                    [currentMergeActivity]: new Set()
                                                                }
                                                            }));
                                                        }
                                                        if (showMergePedagogySection.youDo) {
                                                            setShowMergePedagogySection(prev => ({ ...prev, youDo: false }));
                                                            setSelectedPedagogyModulesForMerge(prev => ({
                                                                ...prev,
                                                                youDo: {
                                                                    ...prev.youDo,
                                                                    [currentMergeActivity]: new Set()
                                                                }
                                                            }));
                                                            setSelectedPedagogySubModulesForMerge(prev => ({
                                                                ...prev,
                                                                youDo: {
                                                                    ...prev.youDo,
                                                                    [currentMergeActivity]: new Set()
                                                                }
                                                            }));
                                                            setSelectedPedagogyTopicsForMerge(prev => ({
                                                                ...prev,
                                                                youDo: {
                                                                    ...prev.youDo,
                                                                    [currentMergeActivity]: new Set()
                                                                }
                                                            }));
                                                            setSelectedPedagogySubTopicsForMerge(prev => ({
                                                                ...prev,
                                                                youDo: {
                                                                    ...prev.youDo,
                                                                    [currentMergeActivity]: new Set()
                                                                }
                                                            }));
                                                        }
                                                    }}
                                                    className="h-8 text-xs"
                                                >
                                                    Cancel
                                                </Button>
                                                <Button
                                                    type="button"
                                                    size="sm"
                                                    onClick={() => {
                                                        if (showMergeLevelSection) {
                                                            saveLevelMergeSelections();
                                                        }
                                                        if (showMergePedagogySection.iDo) {
                                                            savePedagogyMergeSelections("iDo", currentMergeActivity);
                                                        }
                                                        if (showMergePedagogySection.weDo) {
                                                            savePedagogyMergeSelections("weDo", currentMergeActivity);
                                                        }
                                                        if (showMergePedagogySection.youDo) {
                                                            savePedagogyMergeSelections("youDo", currentMergeActivity);
                                                        }
                                                    }}
                                                    className="h-8 text-xs bg-blue-600 hover:bg-blue-700"
                                                >
                                                    Save Merge Selection
                                                </Button>
                                            </div>
                                        </div>
                                    )}

                                    {/* Action buttons - span all columns */}
                                    <div className="absolute bottom-0 right-0 left-0 bg-white border-t border-slate-100 px-6 py-3 rounded-b-xl">
                                        <div className="flex justify-end gap-2">
                                            <Button
                                                type="button"
                                                variant="outline"
                                                size="sm"
                                                className="h-8 px-5 text-sm font-medium text-slate-600 cursor-pointer border-slate-200 hover:bg-slate-100 rounded-lg"
                                                onClick={() => {
                                                    setShowDialog(false);
                                                    resetAllFormStates();
                                                }}
                                            >
                                                Cancel
                                            </Button>
                                            <Button
                                                type="submit"
                                                size="sm"
                                                className="h-8 px-5 text-sm font-medium bg-gradient-to-br from-sky-500 via-blue-600 to-indigo-700 hover:from-sky-600 hover:via-blue-700 hover:to-indigo-800 text-white shadow-lg hover:shadow-xl transition-all duration-200 disabled:opacity-60 disabled:cursor-not-allowed rounded-lg backdrop-blur-sm border border-white/20"
                                                // disabled={
                                                //     isMergeSectionOpen || (addOnlyPedagogyLevel ? (!selectedLevel) &&
                                                //         (!hasPedagogyHoursGreaterThanZero()) :
                                                //         dialogType === 'module' ? (isCreatingModule || !moduleFormData.title) :
                                                //             dialogType === 'submodule' ? (isCreatingSubModule || !subModuleFormData.title) :
                                                //                 dialogType === 'topic' ? (isCreatingTopic || !topicFormData.title) :
                                                //                     (isCreatingSubTopic || !subTopicFormData.title))
                                                // }
                                                onClick={(e) => {
                                                    // Check conditions and show toast if invalid
                                                    if (isMergeSectionOpen) {
                                                        e.preventDefault();
                                                        toast.error("Please complete the merge selection first", {
                                                            duration: 3000,
                                                            position: 'top-right',
                                                        });
                                                        return;
                                                    }

                                                    if (addOnlyPedagogyLevel) {
                                                        if (!selectedLevel && !hasPedagogyHoursGreaterThanZero()) {
                                                            e.preventDefault();
                                                            toast.error("Please add at least one pedagogy activity with hours or select a level", {
                                                                duration: 3000,
                                                                position: 'top-right',
                                                            });
                                                            return;
                                                        }
                                                    } else {
                                                        let isValid = true;
                                                        let errorMessage = "";

                                                        if (dialogType === 'module' && !moduleFormData.title) {
                                                            isValid = false;
                                                            errorMessage = "Title is required for module";
                                                        } else if (dialogType === 'submodule' && !subModuleFormData.title) {
                                                            isValid = false;
                                                            errorMessage = "Title is required for submodule";
                                                        } else if (dialogType === 'topic' && !topicFormData.title) {
                                                            isValid = false;
                                                            errorMessage = "Title is required for topic";
                                                        } else if (dialogType === 'subtopic' && !subTopicFormData.title) {
                                                            isValid = false;
                                                            errorMessage = "Title is required for subtopic";
                                                        }

                                                        if (!isValid) {
                                                            e.preventDefault();
                                                            toast.error(errorMessage, {
                                                                duration: 3000,
                                                                position: 'top-right',
                                                            });
                                                            return;
                                                        }
                                                    }

                                                    // If all validations pass, let the form submit normally
                                                }}
                                            >
                                                {editMode ? (
                                                    <>
                                                        {(isCreatingModule || isCreatingSubModule || isCreatingTopic || isCreatingSubTopic) ? (
                                                            <>
                                                                <svg className="animate-spin -ml-1 mr-1.5 h-3.5 w-3.5" fill="none" viewBox="0 0 24 24">
                                                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                                </svg>
                                                                Saving
                                                            </>
                                                        ) : (
                                                            <>
                                                                <svg className="w-3.5 h-3.5 mr-1.5" fill="currentColor" viewBox="0 0 20 20">
                                                                    <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                                                                </svg>
                                                                Save Changes
                                                            </>
                                                        )}
                                                    </>
                                                ) : addOnlyPedagogyLevel ? (
                                                    // Pedagogy/Level Only Mode - Always show "Save"
                                                    isCreatingModule || isCreatingSubModule || isCreatingTopic || isCreatingSubTopic ? (
                                                        <>
                                                            <svg className="animate-spin -ml-1 mr-1.5 h-3.5 w-3.5" fill="none" viewBox="0 0 24 24">
                                                                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                            </svg>
                                                            Saving
                                                        </>
                                                    ) : (
                                                        <>
                                                            <svg className="w-3.5 h-3.5 mr-1.5" fill="currentColor" viewBox="0 0 20 20">
                                                                <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                                                            </svg>
                                                            Save
                                                        </>
                                                    )
                                                ) : (
                                                    <>
                                                        {dialogType === 'module' && (
                                                            isCreatingModule ? (
                                                                <>
                                                                    <svg className="animate-spin -ml-1 mr-1.5 h-3 w-3" fill="none" viewBox="0 0 24 24">
                                                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                                    </svg>
                                                                    {isLastHierarchy() ? ("Saving") : ("Adding")}
                                                                </>
                                                            ) : (
                                                                <>
                                                                    {isLastHierarchy() ? (
                                                                        <>
                                                                            <File />
                                                                            Save</>
                                                                    ) : (
                                                                        <>
                                                                            <svg className="w-3 h-3 mr-1.5" fill="currentColor" viewBox="0 0 20 20">
                                                                                <path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" />
                                                                            </svg>
                                                                            Add Module</>
                                                                    )}
                                                                </>
                                                            )
                                                        )}
                                                        {dialogType === 'submodule' && (
                                                            isCreatingSubModule ? (
                                                                <>
                                                                    <svg className="animate-spin -ml-1 mr-1.5 h-3 w-3" fill="none" viewBox="0 0 24 24">
                                                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                                    </svg>
                                                                    {isLastHierarchy() ? ("Saving") : ("Adding")}
                                                                </>
                                                            ) : (
                                                                <>
                                                                    {isLastHierarchy() ? (
                                                                        <>
                                                                            <File />
                                                                            Save</>
                                                                    ) : (
                                                                        <>
                                                                            <svg className="w-3 h-3 mr-1.5" fill="currentColor" viewBox="0 0 20 20">
                                                                                <path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" />
                                                                            </svg>
                                                                            Add Submodule</>
                                                                    )}
                                                                </>
                                                            )
                                                        )}
                                                        {dialogType === 'topic' && (
                                                            isCreatingTopic ? (
                                                                <>
                                                                    <svg className="animate-spin -ml-1 mr-1.5 h-3 w-3" fill="none" viewBox="0 0 24 24">
                                                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                                    </svg>
                                                                    {isLastHierarchy() ? ("Saving") : ("Adding")}
                                                                </>
                                                            ) : (
                                                                <>
                                                                    {isLastHierarchy() ? (
                                                                        <>
                                                                            <File />
                                                                            Save</>
                                                                    ) : (
                                                                        <>
                                                                            <svg className="w-3 h-3 mr-1.5" fill="currentColor" viewBox="0 0 20 20">
                                                                                <path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" />
                                                                            </svg>
                                                                            Add Topic</>
                                                                    )}
                                                                </>
                                                            )
                                                        )}
                                                        {dialogType === 'subtopic' && (
                                                            isCreatingSubTopic ? (
                                                                <>
                                                                    <svg className="animate-spin -ml-1 mr-1.5 h-3 w-3" fill="none" viewBox="0 0 24 24">
                                                                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                                                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                                    </svg>
                                                                    Saving
                                                                </>
                                                            ) : (
                                                                <>
                                                                    <File />
                                                                    Save
                                                                </>
                                                            )
                                                        )}
                                                    </>
                                                )}
                                            </Button>
                                        </div>
                                    </div>
                                </form>
                            </div>
                        </motion.div>
                    </DialogContent>
                </Dialog>
            </AnimatePresence>
            <style>
                {`
  .thin-scrollbar::-webkit-scrollbar {
    width: 6px;
    height: 6px;
  }
  .thin-scrollbar::-webkit-scrollbar-track {
    background: transparent;
  }
  .thin-scrollbar::-webkit-scrollbar-thumb {
    border-radius: 9999px;
    background: linear-gradient(to bottom, #1757e1ff, #1e40af);
  }
  .thin-scrollbar::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(to bottom, #1757e1ff, #1e3a8a);
  }
  /* Firefox */
  .thin-scrollbar {
    scrollbar-width: thin;
    scrollbar-color: #1757e1ff transparent;
  }
`}
            </style>

            <AnimatePresence>
                {showDeleteDialog && (
                    <motion.div
                        className="fixed inset-0 bg-gray-900/20 backdrop-blur-sm flex items-center justify-center z-50 p-4"
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                    >
                        <motion.div
                            className="bg-white rounded-lg shadow-xl max-w-sm w-full p-6"
                            initial={{ scale: 0.9, opacity: 0 }}
                            animate={{ scale: 1, opacity: 1 }}
                            exit={{ scale: 0.9, opacity: 0 }}
                            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
                        >
                            <div className="text-center">
                                <div className="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100">
                                    <AlertTriangle className="h-6 w-6 text-red-600" />
                                </div>
                                <h3 className="mt-5 text-lg font-medium text-gray-900">Delete {itemToDelete?.type}</h3>
                                <div className="mt-2 text-sm text-gray-500">
                                    <p className="text-sm">Are you sure you want to delete this {itemToDelete?.type}?</p>
                                    <p className="font-semibold text-red-500">This action cannot be undone.</p>
                                </div>
                            </div>
                            <div className="mt-6 grid grid-cols-2 gap-3">
                                <Button
                                    variant="outline"
                                    size="sm"
                                    className="cursor-pointer"
                                    onClick={() => {
                                        setShowDeleteDialog(false);
                                        setItemToDelete(null);
                                    }}
                                >
                                    Cancel
                                </Button>
                                <Button
                                    variant="destructive"
                                    size="sm"
                                    onClick={confirmDelete}
                                    className="cursor-pointer"
                                >
                                    {(isConfirmDelete ? "Deleting..." : "Delete")}
                                </Button>
                            </div>
                        </motion.div>
                    </motion.div>
                )}
            </AnimatePresence>

            {/* Error Dialog */}
            <AnimatePresence>
                <Dialog open={showErrorDialog} onOpenChange={setShowErrorDialog}>
                    <DialogContent className="sm:max-w-md">
                        <motion.div
                            initial="hidden"
                            animate="visible"
                            exit="exit"
                            variants={popupVariants}
                        >
                            <DialogHeader>
                                <DialogTitle className="text-red-600 flex items-center gap-2">
                                    <AlertTriangle className="w-5 h-5" />
                                    Error
                                </DialogTitle>
                            </DialogHeader>
                            <div className="space-y-4">
                                <p className="text-sm text-gray-600">{errorMessage}</p>
                                <div className="flex justify-end">
                                    <Button
                                        variant="outline"
                                        onClick={() => {
                                            setShowErrorDialog(false)
                                            setMergeSelectionMode(null);
                                            setSelectedMergeCells(new Set());
                                        }}
                                    >
                                        OK
                                    </Button>
                                </div>
                            </div>
                        </motion.div>
                    </DialogContent>
                </Dialog>
            </AnimatePresence>
            {/* Summary Dialog */}
            <AnimatePresence>
                <Dialog open={showSummaryDialog} onOpenChange={setShowSummaryDialog}>
                    <DialogContent className="sm:max-w-2xl" onInteractOutside={(e) => e.preventDefault()}>
                        <motion.div
                            initial="hidden"
                            animate="visible"
                            exit="exit"
                            variants={popupVariants}
                        >
                            <DialogHeader>
                                <DialogTitle className="text-lg font-semibold text-gray-800">Pedagogy Hours Summary</DialogTitle>
                            </DialogHeader>
                            <div className="max-h-[70vh] overflow-auto">
                                <Table className="border">
                                    <TableHeader>
                                        <TableRow className="bg-gray-100 hover:bg-gray-100">
                                            <TableHead className="w-[200px] border font-medium text-gray-700">Activity Type</TableHead>
                                            <TableHead className="w-[200px] border font-medium text-gray-700">Elements</TableHead>
                                            <TableHead className="border font-medium text-gray-700">Hours</TableHead>
                                            <TableHead className="w-[150px] border font-medium text-gray-700">Section Total</TableHead>
                                        </TableRow>
                                    </TableHeader>
                                    <TableBody>
                                        {/* I Do Section */}
                                        {activityTypes["iDo"].map((activity, index) => (
                                            <TableRow key={`summary-iDo-${activity}`} className="hover:bg-yellow-50">
                                                {index === 0 && (
                                                    <TableCell className="font-semibold border bg-yellow-100 text-yellow-800" rowSpan={activityTypes["iDo"].length}>
                                                        I Do
                                                    </TableCell>
                                                )}
                                                <TableCell className="border pl-8 text-gray-700">{activity}</TableCell>
                                                <TableCell className="border text-gray-700">
                                                    {calculateTotalHours("iDo", activity)}
                                                </TableCell>
                                                {index === 0 && (
                                                    <TableCell className="font-semibold border bg-yellow-100 text-yellow-800" rowSpan={activityTypes["iDo"].length}>
                                                        {calculateSectionTotal("iDo", activityTypes["iDo"])}
                                                    </TableCell>
                                                )}
                                            </TableRow>
                                        ))}

                                        {/* We Do Section */}
                                        {activityTypes["weDo"].map((activity, index) => (
                                            <TableRow key={`summary-weDo-${activity}`} className="hover:bg-orange-50">
                                                {index === 0 && (
                                                    <TableCell className="font-semibold border bg-orange-100 text-orange-800" rowSpan={activityTypes["weDo"].length}>
                                                        We Do
                                                    </TableCell>
                                                )}
                                                <TableCell className="border pl-8 text-gray-700">{activity}</TableCell>
                                                <TableCell className="border text-gray-700">
                                                    {calculateTotalHours("weDo", activity)}
                                                </TableCell>
                                                {index === 0 && (
                                                    <TableCell className="font-semibold border bg-orange-100 text-orange-800" rowSpan={activityTypes["weDo"].length}>
                                                        {calculateSectionTotal("weDo", activityTypes["weDo"])}
                                                    </TableCell>
                                                )}
                                            </TableRow>
                                        ))}

                                        {/* You Do Section */}
                                        {activityTypes["youDo"].map((activity, index) => (
                                            <TableRow key={`summary-youDo-${activity}`} className="hover:bg-green-50">
                                                {index === 0 && (
                                                    <TableCell className="font-semibold border bg-green-100 text-green-800" rowSpan={activityTypes["youDo"].length}>
                                                        You Do
                                                    </TableCell>
                                                )}
                                                <TableCell className="border pl-8 text-gray-700">{activity}</TableCell>
                                                <TableCell className="border text-gray-700">
                                                    {calculateTotalHours("youDo", activity)}
                                                </TableCell>
                                                {index === 0 && (
                                                    <TableCell className="font-semibold border bg-green-100 text-green-800" rowSpan={activityTypes["youDo"].length}>
                                                        {calculateSectionTotal("youDo", activityTypes["youDo"])}
                                                    </TableCell>
                                                )}
                                            </TableRow>
                                        ))}

                                        {/* Grand Total */}
                                        <TableRow className="bg-gray-100 hover:bg-gray-100">
                                            <TableCell className="font-semibold border text-gray-800" colSpan={3}>Total Hours</TableCell>
                                            <TableCell className="font-semibold border text-gray-800">
                                                {Object.entries(activityTypes).reduce((sum, [type, activities]) => {
                                                    return sum + activities.reduce((typeSum, activity) => {
                                                        return typeSum + calculateTotalHours(type as "iDo" | "weDo" | "youDo", activity);
                                                    }, 0);
                                                }, 0)}
                                            </TableCell>
                                        </TableRow>
                                    </TableBody>
                                </Table>
                            </div>
                        </motion.div>
                    </DialogContent>
                </Dialog>
            </AnimatePresence>
            {/* Instructions Dialog */}
            <AnimatePresence>
                <Dialog open={showInstructions} onOpenChange={setShowInstructions}>
                    <DialogContent className="sm:max-w-md" onInteractOutside={(e) => e.preventDefault()}>
                        <motion.div
                            initial="hidden"
                            animate="visible"
                            exit="exit"
                            variants={popupVariants}
                        >
                            <DialogHeader>
                                <DialogTitle className="flex items-center gap-2 mb-2">
                                    <div className="p-1.5 bg-blue-100 rounded-full">
                                        <svg className="w-4 h-4 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <circle cx="12" cy="12" r="10" />
                                            <circle cx="12" cy="12" r="6" />
                                            <circle cx="12" cy="12" r="2" />
                                        </svg>
                                    </div>
                                    How to use Pedagogy Management
                                </DialogTitle>
                            </DialogHeader>
                            <div className="space-y-3">
                                <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                    <div className="flex items-start gap-3">
                                        <div className="text-sm">
                                            <ul className="text-gray-700 space-y-2 list-disc list-inside">
                                                <li>Click any cell to edit individual hours (Enter to save, Escape to cancel)</li>
                                                <li>Select multiple consecutive rows to merge cells</li>
                                                <li>When merging, enter the total hours for all selected items</li>
                                                <li>Merged cells count only once in totals (no double counting)</li>
                                                <li>Use "Full View" for table fullscreen and drag zoom controls to reposition</li>
                                                <li>Enable "Actions" to add/edit/delete modules and their contents</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                                <div className="flex justify-end pt-2">
                                    <Button
                                        size="sm"
                                        onClick={() => setShowInstructions(false)}
                                    >
                                        Got it!
                                    </Button>
                                </div>
                            </div>
                        </motion.div>
                    </DialogContent>
                </Dialog>
            </AnimatePresence>
            {/* Edit Merge Dialog */}
            <AnimatePresence>
                <Dialog open={!!editingMerge} onOpenChange={(open) => {
                    if (!open) {
                        setEditingMerge(null);
                        setMergeEditError("");
                    }
                }}>
                    <DialogContent className="w-[95vw] max-w-md mx-auto sm:w-full sm:max-w-md md:max-w-lg lg:max-w-xl">
                        <motion.div
                            initial="hidden"
                            animate="visible"
                            exit="exit"
                            variants={popupVariants}
                        >
                            <DialogHeader className="pb-4">
                                <DialogTitle className="text-base sm:text-lg md:text-lg text-left">
                                    Edit Merged Hours
                                </DialogTitle>
                            </DialogHeader>
                            <div className="space-y-4 sm:space-y-6">
                                <div className="space-y-2 sm:space-y-3">
                                    <Label
                                        htmlFor="mergeHours"
                                        className="text-sm sm:text-sm font-medium block"
                                    >
                                        Total hours for {editingMerge?.activity} ({editingMerge?.type})
                                    </Label>
                                    <Input
                                        id="mergeHours"
                                        type="number"
                                        value={editingMerge?.value ?? ""}
                                        onChange={(e) => {
                                            if (editingMerge) {
                                                setEditingMerge({
                                                    ...editingMerge,
                                                    value: Number(e.target.value) || 0
                                                });
                                                setMergeEditError(""); // Clear error when user types
                                            }
                                        }}
                                        step="0.5"
                                        min="0"
                                        autoFocus
                                        className="w-full h-10 sm:h-11 md:h-10 text-sm sm:text-base px-3 sm:px-4"
                                    />
                                    {mergeEditError && (
                                        <p className="text-xs sm:text-sm text-red-500 mt-1">
                                            {mergeEditError}
                                        </p>
                                    )}
                                </div>
                                <div className="flex flex-col-reverse sm:flex-row justify-end gap-2 sm:gap-3 pt-2">
                                    <Button
                                        variant="outline"
                                        onClick={() => {
                                            setEditingMerge(null);
                                            setMergeEditError("");
                                        }}
                                        className="w-full sm:w-auto h-9 sm:h-9 text-sm sm:text-base px-4 sm:px-6"
                                    >
                                        Cancel
                                    </Button>
                                    <Button
                                        onClick={() => {
                                            if (editingMerge) {
                                                updateMergedPedagogy.mutate({
                                                    type: editingMerge.type,
                                                    activity: editingMerge.activity,
                                                    value: editingMerge.value,
                                                    mergeIndex: editingMerge.mergeIndex,
                                                    hierarchyIds: editingMerge.hierarchyIds
                                                });
                                                setEditingMerge(null);
                                            }
                                        }}
                                        disabled={updateMergedPedagogy.isPending}
                                        className="w-full sm:w-auto h-9 sm:h-9 text-sm sm:text-base px-4 sm:px-6"
                                    >
                                        {updateMergedPedagogy.isPending ? "Saving..." : "Save Changes"}
                                    </Button>
                                </div>
                            </div>
                        </motion.div>
                    </DialogContent>
                </Dialog>
            </AnimatePresence>
            {/* Preview Dialog */}
            <AnimatePresence>
                <Dialog open={showPreviewDialog} onOpenChange={setShowPreviewDialog}>
                    <DialogContent className="max-w-[98vw] max-h-[98vh] p-0 flex flex-col" onInteractOutside={(e) => e.preventDefault()}>
                        <motion.div
                            initial="hidden"
                            animate="visible"
                            exit="exit"
                            variants={popupVariants}
                            className="max-w-[98vw] max-h-[98vh] p-0 flex flex-col"
                        >
                            <DialogHeader className="p-4 pb-2 shrink-0">
                                <DialogTitle className="text-sm font-semibold">
                                    Pedagogy Preview - {selectedCourse?.courseName}
                                </DialogTitle>
                            </DialogHeader>

                            {/* Export Controls - Reorganized Layout */}
                            <div className="px-4 py-2 border-b bg-slate-50/80 backdrop-blur-sm">
                                <div className="flex items-start justify-between gap-4">
                                    {/* Conditional Layout Based on Teaching Elements */}
                                    {(selectedPedagogyTypes.includes("iDo") || selectedPedagogyTypes.includes("weDo") || selectedPedagogyTypes.includes("youDo")) ? (
                                        <>
                                            {/* Left Side - Course Hierarchy & Export Options when Teaching Elements exist */}
                                            <div className="flex flex-col gap-2 min-w-[30vw]">
                                                <div className="flex gap-4">
                                                    {/* Course Hierarchy Card */}
                                                    <div className="bg-white rounded-md p-3 shadow-sm border border-slate-200 flex-1">
                                                        {/* Top row with heading + include total hours on the right */}
                                                        <div className="flex items-center mb-2">
                                                            <div className="flex items-center gap-2">
                                                                <div className="w-1.5 h-1.5 rounded-full bg-blue-500"></div>
                                                                <h3 className="text-xs font-semibold text-slate-700">Course Hierarchy</h3>
                                                            </div>

                                                            {/* ✅ Include Total Hours pill on right */}
                                                            <label
                                                                // className="ml-auto flex items-center gap-1 px-2 py-1 text-xs rounded border border-blue-200 bg-blue-50 hover:bg-blue-100 hover:border-blue-400 cursor-pointer transition-colors"
                                                                className={`ml-auto flex items-center gap-1 px-2 py-1 text-xs rounded border transition-colors
                  ${(Array.isArray(exportSelections.pedagogy.iDo) &&
                                                                        exportSelections.pedagogy.iDo.length === activityTypes["iDo"].length ||
                                                                        !selectedPedagogyTypes.includes("iDo")) &&
                                                                        (Array.isArray(exportSelections.pedagogy.weDo) &&
                                                                            exportSelections.pedagogy.weDo.length === activityTypes["weDo"].length ||
                                                                            !selectedPedagogyTypes.includes("weDo")) &&
                                                                        (Array.isArray(exportSelections.pedagogy.youDo) &&
                                                                            exportSelections.pedagogy.youDo.length === activityTypes["youDo"].length ||
                                                                            !selectedPedagogyTypes.includes("youDo"))
                                                                        ? "border-blue-200 bg-blue-50 hover:bg-blue-100 hover:border-blue-400 cursor-pointer text-blue-600"
                                                                        : "border-gray-200 bg-gray-100 text-gray-400 cursor-not-allowed"
                                                                    }`}
                                                            >
                                                                <Checkbox
                                                                    checked={exportSelections.includeTotalHours}

                                                                    onCheckedChange={(checked) => {
                                                                        setExportSelections((prev: any) => ({
                                                                            ...prev,
                                                                            includeTotalHours: !!checked,
                                                                        }));
                                                                    }}
                                                                    className="h-3 w-3 rounded border transition-colors"
                                                                />
                                                                <span className=" font-medium">Include Total Hours</span>
                                                            </label>
                                                        </div>

                                                        {/* Checkboxes below */}
                                                        <div className="flex flex-wrap gap-1.5">
                                                            {/* All checkbox */}
                                                            <label className="flex items-center gap-1 px-2 py-1 text-xs rounded border border-slate-200 hover:bg-blue-50 hover:border-blue-300 cursor-pointer transition-colors">
                                                                <Checkbox
                                                                    id="export-all"
                                                                    checked={
                                                                        (!selectedCourse?.courseHierarchy.includes("Module") ||
                                                                            exportSelections.hierarchy.module) &&
                                                                        (!selectedCourse?.courseHierarchy.includes("Sub Module") ||
                                                                            exportSelections.hierarchy.subModule) &&
                                                                        (!selectedCourse?.courseHierarchy.includes("Topic") ||
                                                                            exportSelections.hierarchy.topic) &&
                                                                        (!selectedCourse?.courseHierarchy.includes("Sub Topic") ||
                                                                            exportSelections.hierarchy.subTopic)
                                                                    }
                                                                    onCheckedChange={(checked) => {
                                                                        const allChecked = !!checked;
                                                                        setExportSelections((prev: { hierarchy: { module: any; subModule: any; topic: any; subTopic: any; level: any; }; }) => ({
                                                                            ...prev,
                                                                            hierarchy: {
                                                                                module: selectedCourse?.courseHierarchy.includes("Module")
                                                                                    ? allChecked
                                                                                    : prev.hierarchy.module,
                                                                                subModule: selectedCourse?.courseHierarchy.includes("Sub Module")
                                                                                    ? allChecked
                                                                                    : prev.hierarchy.subModule,
                                                                                topic: selectedCourse?.courseHierarchy.includes("Topic")
                                                                                    ? allChecked
                                                                                    : prev.hierarchy.topic,
                                                                                subTopic: selectedCourse?.courseHierarchy.includes("Sub Topic")
                                                                                    ? allChecked
                                                                                    : prev.hierarchy.subTopic,
                                                                                level: prev.hierarchy.level,
                                                                            },
                                                                        }));
                                                                    }}
                                                                    className="h-3 w-3"
                                                                />
                                                                <span className="text-slate-600">All</span>
                                                            </label>

                                                            {/* Module */}
                                                            {selectedCourse?.courseHierarchy.includes("Module") && (
                                                                <label className="flex items-center gap-1 px-2 py-1 text-xs rounded border border-slate-200 hover:bg-blue-50 hover:border-blue-300 cursor-pointer transition-colors">
                                                                    <Checkbox
                                                                        id="export-module"
                                                                        checked={exportSelections.hierarchy.module}
                                                                        onCheckedChange={(checked) =>
                                                                            setExportSelections((prev: { hierarchy: any; }) => ({
                                                                                ...prev,
                                                                                hierarchy: { ...prev.hierarchy, module: !!checked },
                                                                            }))
                                                                        }
                                                                        className="h-3 w-3"
                                                                    />
                                                                    <span className="text-slate-600">Module</span>
                                                                </label>
                                                            )}

                                                            {/* Sub Module */}
                                                            {selectedCourse?.courseHierarchy.includes("Sub Module") && (
                                                                <label className="flex items-center gap-1 px-2 py-1 text-xs rounded border border-slate-200 hover:bg-blue-50 hover:border-blue-300 cursor-pointer transition-colors">
                                                                    <Checkbox
                                                                        id="export-submodule"
                                                                        checked={exportSelections.hierarchy.subModule}
                                                                        onCheckedChange={(checked) =>
                                                                            setExportSelections((prev: { hierarchy: any; }) => ({
                                                                                ...prev,
                                                                                hierarchy: { ...prev.hierarchy, subModule: !!checked },
                                                                            }))
                                                                        }
                                                                        className="h-3 w-3"
                                                                    />
                                                                    <span className="text-slate-600">Sub Module</span>
                                                                </label>
                                                            )}

                                                            {/* Topic */}
                                                            {selectedCourse?.courseHierarchy.includes("Topic") && (
                                                                <label className="flex items-center gap-1 px-2 py-1 text-xs rounded border border-slate-200 hover:bg-blue-50 hover:border-blue-300 cursor-pointer transition-colors">
                                                                    <Checkbox
                                                                        id="export-topic"
                                                                        checked={exportSelections.hierarchy.topic}
                                                                        onCheckedChange={(checked) =>
                                                                            setExportSelections((prev: { hierarchy: any; }) => ({
                                                                                ...prev,
                                                                                hierarchy: { ...prev.hierarchy, topic: !!checked },
                                                                            }))
                                                                        }
                                                                        className="h-3 w-3"
                                                                    />
                                                                    <span className="text-slate-600">Topic</span>
                                                                </label>
                                                            )}

                                                            {/* Sub Topic */}
                                                            {selectedCourse?.courseHierarchy.includes("Sub Topic") && (
                                                                <label className="flex items-center gap-1 px-2 py-1 text-xs rounded border border-slate-200 hover:bg-blue-50 hover:border-blue-300 cursor-pointer transition-colors">
                                                                    <Checkbox
                                                                        id="export-subtopic"
                                                                        checked={exportSelections.hierarchy.subTopic}
                                                                        onCheckedChange={(checked) =>
                                                                            setExportSelections((prev: { hierarchy: any; }) => ({
                                                                                ...prev,
                                                                                hierarchy: { ...prev.hierarchy, subTopic: !!checked },
                                                                            }))
                                                                        }
                                                                        className="h-3 w-3"
                                                                    />
                                                                    <span className="text-slate-600">Sub Topic</span>
                                                                </label>
                                                            )}
                                                        </div>
                                                    </div>


                                                    {/* Level Card */}
                                                    <div className="bg-white rounded-md p-3 shadow-sm border border-slate-200 w-40">
                                                        <div className="flex items-center gap-2 mb-2">
                                                            <div className="w-1.5 h-1.5 rounded-full bg-green-500"></div>
                                                            <h3 className="text-xs font-semibold text-slate-700">Level</h3>
                                                        </div>

                                                        <label className="flex items-center gap-1 px-2 py-1 text-xs rounded border border-slate-200 hover:bg-green-50 hover:border-green-300 cursor-pointer transition-colors">
                                                            <Checkbox
                                                                id="export-level"
                                                                checked={exportSelections.hierarchy.level}
                                                                onCheckedChange={(checked) =>
                                                                    setExportSelections((prev: { hierarchy: any; }) => ({
                                                                        ...prev,
                                                                        hierarchy: { ...prev.hierarchy, level: !!checked }
                                                                    }))
                                                                }
                                                                className="h-3 w-3"
                                                            />
                                                            <span className="text-slate-600">Level</span>
                                                        </label>
                                                    </div>
                                                </div>


                                                {/* Export Options Card */}
                                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                                    {/* Left Card */}
                                                    <div className="bg-white rounded-md p-3 shadow-sm border border-slate-200">
                                                        <div className="flex items-center justify-between mb-2">
                                                            {/* Left section */}
                                                            <div className="flex items-center gap-2">
                                                                <div className="w-1.5 h-1.5 rounded-full bg-green-500"></div>
                                                                <h3 className="text-xs font-semibold text-slate-700">Options</h3>
                                                            </div>

                                                            {/* Right section (Clear button) */}
                                                            <motion.button
                                                                onClick={() => {
                                                                    setExportSelections((prev: any) => ({
                                                                        ...prev,
                                                                        hoursOption: '', // Reset to default option
                                                                    }));
                                                                }}
                                                                whileHover={{ scale: 1.05, backgroundColor: "#fee2e2" }} // light red hover
                                                                whileTap={{ scale: 0.9 }} // shrink on click
                                                                className="flex items-center gap-1 h-6 px-2 cursor-pointer text-xs font-semibold text-red-600 rounded border border-red-200 bg-red-50 transition-colors"
                                                            >
                                                                <X className="h-3 w-3" />
                                                                Clear
                                                            </motion.button>
                                                        </div>

                                                        <div className="flex flex-col gap-2 text-xs text-slate-600">

                                                            <label className="flex items-center gap-2 ">
                                                                <input
                                                                    type="radio"
                                                                    name="hoursOption"
                                                                    value="activity"
                                                                    className="h-3 w-3 cursor-pointer"
                                                                    checked={exportSelections.hoursOption === 'activity'}
                                                                    onChange={() => {
                                                                        setExportSelections((prev: any) => ({
                                                                            ...prev,
                                                                            hoursOption: 'activity'
                                                                        }));
                                                                    }}
                                                                />
                                                                <span className="font-medium cursor-pointer">Activity Hours</span>
                                                                <span className="text-xs text-slate-400">(Show category totals)</span>
                                                            </label>

                                                            <label className="flex items-center gap-2 ">
                                                                <input
                                                                    type="radio"
                                                                    name="hoursOption"
                                                                    value="element"
                                                                    className="h-3 w-3 cursor-pointer"
                                                                    checked={exportSelections.hoursOption === 'element'}
                                                                    onChange={() => {
                                                                        setExportSelections((prev: any) => ({
                                                                            ...prev,
                                                                            hoursOption: 'element'
                                                                        }));
                                                                    }}
                                                                />
                                                                <span className="font-medium cursor-pointer">Element Hours</span>
                                                                <span className="text-xs text-slate-400">(Show individual activities)</span>
                                                            </label>
                                                        </div>
                                                    </div>

                                                    {/* Right Card (Export Options) */}
                                                    <div className="bg-white rounded-md p-3 shadow-sm border border-slate-200">
                                                        <div className="flex items-center gap-2 mb-2">
                                                            <div className="w-1.5 h-1.5 rounded-full bg-violet-500"></div>
                                                            <h3 className="text-xs font-semibold text-slate-700">Export Options</h3>
                                                        </div>
                                                        <div className="flex gap-2">
                                                            <Button
                                                                variant="outline"
                                                                size="sm"
                                                                onClick={handlePrint}
                                                                className="flex-1 text-xs h-7 px-2.5 border-slate-300 text-slate-600 hover:bg-slate-100 hover:border-slate-400"
                                                            >
                                                                <Printer className="h-3 w-3 mr-1" />
                                                                Print
                                                            </Button>
                                                            <Button
                                                                variant="default"
                                                                size="sm"
                                                                onClick={() => exportToExcel()}
                                                                className="flex-1 text-xs h-7 px-2.5 bg-blue-600 hover:bg-blue-700 text-white"
                                                            >
                                                                <FileText className="h-3 w-3 mr-1" />
                                                                Excel
                                                            </Button>
                                                        </div>
                                                    </div>
                                                </div>

                                            </div>
                                            {/* Right Side - Teaching Elements */}
                                            <div className="flex-1">
                                                <div className="bg-white rounded-md p-2 shadow-sm border mb-2 border-slate-200">
                                                    <div className="flex items-center gap-2 mb-1.5">
                                                        <div className="w-1.5 h-1.5 rounded-full bg-emerald-500"></div>
                                                        <h3 className="text-xs font-semibold text-slate-700">Teaching Elements</h3>

                                                        <div className="flex items-center gap-2">
                                                            <Checkbox
                                                                id="teaching-elements-select-all "
                                                                checked={
                                                                    // Check if all available teaching element activities are selected
                                                                    (selectedPedagogyTypes.includes("iDo") ?
                                                                        Array.isArray(exportSelections.pedagogy.iDo) &&
                                                                        exportSelections.pedagogy.iDo.length === activityTypes["iDo"].length : true) &&
                                                                    (selectedPedagogyTypes.includes("weDo") ?
                                                                        Array.isArray(exportSelections.pedagogy.weDo) &&
                                                                        exportSelections.pedagogy.weDo.length === activityTypes["weDo"].length : true) &&
                                                                    (selectedPedagogyTypes.includes("youDo") ?
                                                                        Array.isArray(exportSelections.pedagogy.youDo) &&
                                                                        exportSelections.pedagogy.youDo.length === activityTypes["youDo"].length : true)
                                                                }
                                                                onCheckedChange={(checked) => {
                                                                    const allChecked = !!checked;
                                                                    setExportSelections((prev: { pedagogy: { iDo: any; weDo: any; youDo: any; }; }) => ({
                                                                        ...prev,
                                                                        pedagogy: {
                                                                            ...prev.pedagogy,
                                                                            iDo: selectedPedagogyTypes.includes("iDo")
                                                                                ? (allChecked ? [...activityTypes["iDo"]] : [])
                                                                                : prev.pedagogy.iDo,
                                                                            weDo: selectedPedagogyTypes.includes("weDo")
                                                                                ? (allChecked ? [...activityTypes["weDo"]] : [])
                                                                                : prev.pedagogy.weDo,
                                                                            youDo: selectedPedagogyTypes.includes("youDo")
                                                                                ? (allChecked ? [...activityTypes["youDo"]] : [])
                                                                                : prev.pedagogy.youDo,
                                                                        },
                                                                    }));
                                                                }}
                                                                className="h-3.5 w-3.5 cursor-pointer"
                                                            />
                                                            <label htmlFor="teaching-elements-select-all" className="text-xs text-slate-600 cursor-pointer font-medium">
                                                                Select All
                                                            </label>
                                                        </div>
                                                    </div>

                                                    <div className="flex gap-4">
                                                        {/* I Do Section */}
                                                        {selectedPedagogyTypes.includes("iDo") && (
                                                            <div className="flex-1 relative">
                                                                <details className="group">
                                                                    <summary className="flex items-center justify-between px-3 py-2 text-xs cursor-pointer bg-amber-50 hover:bg-amber-100 rounded-md transition-colors border border-amber-200 list-none">
                                                                        <div className="flex items-center gap-2">
                                                                            <Presentation className="h-3.5 w-3.5 text-amber-600" />
                                                                            <span className="font-medium text-amber-700">I Do</span>
                                                                            {Array.isArray(exportSelections.pedagogy.iDo) && exportSelections.pedagogy.iDo.length > 0 && (
                                                                                <span className="bg-amber-100 text-amber-800 text-[10px] px-1.5 py-0.5 rounded-full">
                                                                                    {exportSelections.pedagogy.iDo.length}/{activityTypes["iDo"].length}
                                                                                </span>
                                                                            )}
                                                                        </div>
                                                                        <ChevronDown className="h-3 w-3 text-amber-500 group-open:rotate-180 transition-transform" />
                                                                    </summary>

                                                                    <div className="absolute z-10 mt-1 w-full p-2 bg-white border border-amber-100 rounded-md shadow-lg max-h-60 overflow-y-auto">
                                                                        <div className="flex items-center gap-2 px-2 py-1 mb-1 border-b border-amber-50">
                                                                            <Checkbox
                                                                                id="export-ido-all"
                                                                                checked={
                                                                                    Array.isArray(exportSelections.pedagogy.iDo) &&
                                                                                    exportSelections.pedagogy.iDo.length === activityTypes["iDo"].length
                                                                                }
                                                                                onCheckedChange={(checked) =>
                                                                                    setExportSelections((prev: { pedagogy: any; }) => ({
                                                                                        ...prev,
                                                                                        pedagogy: {
                                                                                            ...prev.pedagogy,
                                                                                            iDo: checked ? [...activityTypes["iDo"]] : [],
                                                                                        },
                                                                                    }))
                                                                                }
                                                                                className="h-3 w-3"
                                                                            />
                                                                            <label htmlFor="export-ido-all" className="text-xs text-amber-600 font-medium cursor-pointer">
                                                                                Select All
                                                                            </label>
                                                                        </div>
                                                                        {activityTypes["iDo"].map((activity) => (
                                                                            <label
                                                                                key={`iDo-${activity}`}
                                                                                className="flex items-center gap-2 px-2 py-1.5 text-xs rounded hover:bg-amber-50 cursor-pointer transition-colors"
                                                                            >
                                                                                <Checkbox
                                                                                    id={`export-ido-${activity}`}
                                                                                    checked={
                                                                                        Array.isArray(exportSelections.pedagogy.iDo) &&
                                                                                        exportSelections.pedagogy.iDo.includes(activity)
                                                                                    }
                                                                                    onCheckedChange={(checked) => {
                                                                                        setExportSelections((prev: { pedagogy: { iDo: any; }; }) => {
                                                                                            const current = Array.isArray(prev.pedagogy.iDo)
                                                                                                ? prev.pedagogy.iDo
                                                                                                : [];
                                                                                            return {
                                                                                                ...prev,
                                                                                                pedagogy: {
                                                                                                    ...prev.pedagogy,
                                                                                                    iDo: checked
                                                                                                        ? [...current, activity]
                                                                                                        : current.filter((a: string) => a !== activity),
                                                                                                },
                                                                                            };
                                                                                        });
                                                                                    }}
                                                                                    className="h-3 w-3"
                                                                                />
                                                                                <span className="text-slate-600">{activity}</span>
                                                                            </label>
                                                                        ))}
                                                                    </div>
                                                                </details>
                                                            </div>
                                                        )}

                                                        {/* We Do Section */}
                                                        {selectedPedagogyTypes.includes("weDo") && (
                                                            <div className="flex-1 relative">
                                                                <details className="group">
                                                                    <summary className="flex items-center justify-between px-3 py-2 text-xs cursor-pointer bg-rose-50 hover:bg-rose-100 rounded-md transition-colors border border-rose-200 list-none">
                                                                        <div className="flex items-center gap-2">
                                                                            <Users className="h-3.5 w-3.5 text-rose-600" />
                                                                            <span className="font-medium text-rose-700">We Do</span>
                                                                            {Array.isArray(exportSelections.pedagogy.weDo) && exportSelections.pedagogy.weDo.length > 0 && (
                                                                                <span className="bg-rose-100 text-rose-800 text-[10px] px-1.5 py-0.5 rounded-full">
                                                                                    {exportSelections.pedagogy.weDo.length}/{activityTypes["weDo"].length}
                                                                                </span>
                                                                            )}
                                                                        </div>
                                                                        <ChevronDown className="h-3 w-3 text-rose-500 group-open:rotate-180 transition-transform" />
                                                                    </summary>

                                                                    <div className="absolute z-10 mt-1 w-full p-2 bg-white border border-rose-100 rounded-md shadow-lg max-h-60 overflow-y-auto">
                                                                        <div className="flex items-center gap-2 px-2 py-1 mb-1 border-b border-rose-50">
                                                                            <Checkbox
                                                                                id="export-wedo-all"
                                                                                checked={
                                                                                    Array.isArray(exportSelections.pedagogy.weDo) &&
                                                                                    exportSelections.pedagogy.weDo.length === activityTypes["weDo"].length
                                                                                }
                                                                                onCheckedChange={(checked) =>
                                                                                    setExportSelections((prev: { pedagogy: any; }) => ({
                                                                                        ...prev,
                                                                                        pedagogy: {
                                                                                            ...prev.pedagogy,
                                                                                            weDo: checked ? [...activityTypes["weDo"]] : [],
                                                                                        },
                                                                                    }))
                                                                                }
                                                                                className="h-3 w-3"
                                                                            />
                                                                            <label htmlFor="export-wedo-all" className="text-xs text-rose-600 font-medium cursor-pointer">
                                                                                Select All
                                                                            </label>
                                                                        </div>
                                                                        {activityTypes["weDo"].map((activity) => (
                                                                            <label
                                                                                key={`weDo-${activity}`}
                                                                                className="flex items-center gap-2 px-2 py-1.5 text-xs rounded hover:bg-rose-50 cursor-pointer transition-colors"
                                                                            >
                                                                                <Checkbox
                                                                                    id={`export-wedo-${activity}`}
                                                                                    checked={
                                                                                        Array.isArray(exportSelections.pedagogy.weDo) &&
                                                                                        exportSelections.pedagogy.weDo.includes(activity)
                                                                                    }
                                                                                    onCheckedChange={(checked) => {
                                                                                        setExportSelections((prev: { pedagogy: { weDo: any; }; }) => {
                                                                                            const current = Array.isArray(prev.pedagogy.weDo)
                                                                                                ? prev.pedagogy.weDo
                                                                                                : [];
                                                                                            return {
                                                                                                ...prev,
                                                                                                pedagogy: {
                                                                                                    ...prev.pedagogy,
                                                                                                    weDo: checked
                                                                                                        ? [...current, activity]
                                                                                                        : current.filter((a: string) => a !== activity),
                                                                                                },
                                                                                            };
                                                                                        });
                                                                                    }}
                                                                                    className="h-3 w-3"
                                                                                />
                                                                                <span className="text-slate-600">{activity}</span>
                                                                            </label>
                                                                        ))}
                                                                    </div>
                                                                </details>
                                                            </div>
                                                        )}

                                                        {/* You Do Section */}
                                                        {selectedPedagogyTypes.includes("youDo") && (
                                                            <div className="flex-1 relative">
                                                                <details className="group">
                                                                    <summary className="flex items-center justify-between px-3 py-2 text-xs cursor-pointer bg-emerald-50 hover:bg-emerald-100 rounded-md transition-colors border border-emerald-200 list-none">
                                                                        <div className="flex items-center gap-2">
                                                                            <User className="h-3.5 w-3.5 text-emerald-600" />
                                                                            <span className="font-medium text-emerald-700">You Do</span>
                                                                            {Array.isArray(exportSelections.pedagogy.youDo) && exportSelections.pedagogy.youDo.length > 0 && (
                                                                                <span className="bg-emerald-100 text-emerald-800 text-[10px] px-1.5 py-0.5 rounded-full">
                                                                                    {exportSelections.pedagogy.youDo.length}/{activityTypes["youDo"].length}
                                                                                </span>
                                                                            )}
                                                                        </div>
                                                                        <ChevronDown className="h-3 w-3 text-emerald-500 group-open:rotate-180 transition-transform" />
                                                                    </summary>

                                                                    <div className="absolute z-10 mt-1 w-full p-2 bg-white border border-emerald-100 rounded-md shadow-lg max-h-60 overflow-y-auto">
                                                                        <div className="flex items-center gap-2 px-2 py-1 mb-1 border-b border-emerald-50">
                                                                            <Checkbox
                                                                                id="export-youdo-all"
                                                                                checked={
                                                                                    Array.isArray(exportSelections.pedagogy.youDo) &&
                                                                                    exportSelections.pedagogy.youDo.length === activityTypes["youDo"].length
                                                                                }
                                                                                onCheckedChange={(checked) =>
                                                                                    setExportSelections((prev: { pedagogy: any; }) => ({
                                                                                        ...prev,
                                                                                        pedagogy: {
                                                                                            ...prev.pedagogy,
                                                                                            youDo: checked ? [...activityTypes["youDo"]] : [],
                                                                                        },
                                                                                    }))
                                                                                }
                                                                                className="h-3 w-3"
                                                                            />
                                                                            <label htmlFor="export-youdo-all" className="text-xs text-emerald-600 font-medium cursor-pointer">
                                                                                Select All
                                                                            </label>
                                                                        </div>
                                                                        {activityTypes["youDo"].map((activity) => (
                                                                            <label
                                                                                key={`youDo-${activity}`}
                                                                                className="flex items-center gap-2 px-2 py-1.5 text-xs rounded hover:bg-emerald-50 cursor-pointer transition-colors"
                                                                            >
                                                                                <Checkbox
                                                                                    id={`export-youdo-${activity}`}
                                                                                    checked={
                                                                                        Array.isArray(exportSelections.pedagogy.youDo) &&
                                                                                        exportSelections.pedagogy.youDo.includes(activity)
                                                                                    }
                                                                                    onCheckedChange={(checked) => {
                                                                                        setExportSelections((prev: { pedagogy: { youDo: any; }; }) => {
                                                                                            const current = Array.isArray(prev.pedagogy.youDo)
                                                                                                ? prev.pedagogy.youDo
                                                                                                : [];
                                                                                            return {
                                                                                                ...prev,
                                                                                                pedagogy: {
                                                                                                    ...prev.pedagogy,
                                                                                                    youDo: checked
                                                                                                        ? [...current, activity]
                                                                                                        : current.filter((a: string) => a !== activity),
                                                                                                },
                                                                                            };
                                                                                        });
                                                                                    }}
                                                                                    className="h-3 w-3"
                                                                                />
                                                                                <span className="text-slate-600">{activity}</span>
                                                                            </label>
                                                                        ))}
                                                                    </div>
                                                                </details>
                                                            </div>
                                                        )}
                                                    </div>
                                                </div>
                                                {/* Customized Summary Section (for print only) */}
                                                <div className="bg-white rounded-md p-2 shadow-sm border border-slate-200">
                                                    <div className="flex items-center gap-2 mb-1.5">
                                                        <div className="flex items-center gap-2 mb-1.5">
                                                            <div className="w-1.5 h-1.5 rounded-full bg-purple-500"></div>
                                                            <h3 className="text-xs font-semibold text-slate-700">Customized Print Summary</h3>


                                                        </div>

                                                        {/* Enable Summary Checkbox */}
                                                        <div className="flex  gap-2 ">
                                                            <Checkbox
                                                                id="enable-summary"
                                                                checked={exportSelections.showSummary}
                                                                onCheckedChange={(checked) => {
                                                                    setExportSelections((prev: any) => ({
                                                                        ...prev,
                                                                        showSummary: !!checked,
                                                                    }));
                                                                }}
                                                                className="h-3.5 w-3.5 cursor-pointer"
                                                            />
                                                            <label htmlFor="enable-summary" className="text-xs text-slate-600 cursor-pointer">
                                                                Include customized summary in print
                                                            </label>
                                                        </div>

                                                        {exportSelections.showSummary && (
                                                            <div className="flex items-center gap-2">
                                                                <Checkbox
                                                                    id="print-summary-select-all "
                                                                    checked={
                                                                        // Check if all available print pedagogy activities are selected
                                                                        (selectedPedagogyTypes.includes("iDo") ?
                                                                            Array.isArray(exportSelections.printPedagogy?.iDo) &&
                                                                            exportSelections.printPedagogy.iDo.length === activityTypes["iDo"].length : true) &&
                                                                        (selectedPedagogyTypes.includes("weDo") ?
                                                                            Array.isArray(exportSelections.printPedagogy?.weDo) &&
                                                                            exportSelections.printPedagogy.weDo.length === activityTypes["weDo"].length : true) &&
                                                                        (selectedPedagogyTypes.includes("youDo") ?
                                                                            Array.isArray(exportSelections.printPedagogy?.youDo) &&
                                                                            exportSelections.printPedagogy.youDo.length === activityTypes["youDo"].length : true)
                                                                    }
                                                                    onCheckedChange={(checked) => {
                                                                        const allChecked = !!checked;
                                                                        setExportSelections((prev: { printPedagogy: { iDo: any; weDo: any; youDo: any; }; }) => ({
                                                                            ...prev,
                                                                            printPedagogy: {
                                                                                ...prev.printPedagogy,
                                                                                iDo: selectedPedagogyTypes.includes("iDo")
                                                                                    ? (allChecked ? [...activityTypes["iDo"]] : [])
                                                                                    : (prev.printPedagogy?.iDo || []),
                                                                                weDo: selectedPedagogyTypes.includes("weDo")
                                                                                    ? (allChecked ? [...activityTypes["weDo"]] : [])
                                                                                    : (prev.printPedagogy?.weDo || []),
                                                                                youDo: selectedPedagogyTypes.includes("youDo")
                                                                                    ? (allChecked ? [...activityTypes["youDo"]] : [])
                                                                                    : (prev.printPedagogy?.youDo || []),
                                                                            },
                                                                        }));
                                                                    }}
                                                                    className="h-3.5 w-3.5 cursor-pointer"
                                                                />
                                                                <label htmlFor="print-summary-select-all" className="text-xs text-purple-600 cursor-pointer font-medium">
                                                                    Select All
                                                                </label>
                                                            </div>
                                                        )}

                                                        {exportSelections.showSummary && (
                                                            <label
                                                                className="ml-auto flex items-center gap-1 px-2 py-1 text-xs rounded border transition-colors border-purple-200 bg-purple-50 hover:bg-purple-100 hover:border-purple-400 cursor-pointer text-purple-600"
                                                            >
                                                                <Checkbox
                                                                    checked={exportSelections.summaryIncludeTotalHours || false}
                                                                    onCheckedChange={(checked) => {
                                                                        setExportSelections((prev: any) => ({
                                                                            ...prev,
                                                                            summaryIncludeTotalHours: !!checked,
                                                                        }));
                                                                    }}
                                                                    className="h-3 w-3 rounded border transition-colors"
                                                                />
                                                                <span className="font-medium">
                                                                    Include Total Hours
                                                                </span>
                                                            </label>
                                                        )}

                                                    </div>

                                                    {/* Summary Teaching Elements - Similar structure but separate state */}
                                                    <div className={`flex gap-4 ${!exportSelections.showSummary ? 'opacity-50 pointer-events-none' : ''}`}>
                                                        {/* I Do Section */}
                                                        {selectedPedagogyTypes.includes("iDo") && (
                                                            <div className="flex-1 relative " >

                                                                <DropdownSection
                                                                    type="iDo"
                                                                    icon={Presentation}
                                                                    title="I Do (Print)"
                                                                    activityTypes={activityTypes["iDo"]}
                                                                    selectedActivities={exportSelections.printPedagogy?.iDo || []}
                                                                    onSelectionChange={(selected: any) => {
                                                                        setExportSelections((prev: { printPedagogy: any; }) => ({
                                                                            ...prev,
                                                                            printPedagogy: {
                                                                                ...prev.printPedagogy,
                                                                                iDo: selected,
                                                                            },
                                                                        }));
                                                                    }}
                                                                    onSelectAll={(selectAll: any) => {
                                                                        setExportSelections((prev: { printPedagogy: any; }) => ({
                                                                            ...prev,
                                                                            printPedagogy: {
                                                                                ...prev.printPedagogy,
                                                                                iDo: selectAll ? [...activityTypes["iDo"]] : [],
                                                                            },
                                                                        }));
                                                                    }}
                                                                />

                                                            </div>
                                                        )}

                                                        {/* We Do Section */}
                                                        {selectedPedagogyTypes.includes("weDo") && (
                                                            <div className="flex-1 relative ">

                                                                <DropdownSection
                                                                    type="weDo"
                                                                    icon={Users}
                                                                    title="We Do (Print)"
                                                                    activityTypes={activityTypes["weDo"]}
                                                                    selectedActivities={exportSelections.printPedagogy?.weDo || []}
                                                                    onSelectionChange={(selected: any) => {
                                                                        setExportSelections((prev: { printPedagogy: any }) => ({
                                                                            ...prev,
                                                                            printPedagogy: {
                                                                                ...prev.printPedagogy,
                                                                                weDo: selected,
                                                                            },
                                                                        }));
                                                                    }}
                                                                    onSelectAll={(selectAll: boolean) => {
                                                                        setExportSelections((prev: { printPedagogy: any }) => ({
                                                                            ...prev,
                                                                            printPedagogy: {
                                                                                ...prev.printPedagogy,
                                                                                weDo: selectAll ? [...activityTypes["weDo"]] : [],
                                                                            },
                                                                        }));
                                                                    }}
                                                                />
                                                            </div>
                                                        )}

                                                        {/* You Do Section */}
                                                        {selectedPedagogyTypes.includes("youDo") && (
                                                            <div className="flex-1 relative">

                                                                <DropdownSection
                                                                    type="youDo"
                                                                    icon={User}
                                                                    title="You Do (Print)"
                                                                    activityTypes={activityTypes["youDo"]}
                                                                    selectedActivities={exportSelections.printPedagogy?.youDo || []}
                                                                    onSelectionChange={(selected: any) => {
                                                                        setExportSelections((prev: { printPedagogy: any }) => ({
                                                                            ...prev,
                                                                            printPedagogy: {
                                                                                ...prev.printPedagogy,
                                                                                youDo: selected,
                                                                            },
                                                                        }));
                                                                    }}
                                                                    onSelectAll={(selectAll: boolean) => {
                                                                        setExportSelections((prev: { printPedagogy: any }) => ({
                                                                            ...prev,
                                                                            printPedagogy: {
                                                                                ...prev.printPedagogy,
                                                                                youDo: selectAll ? [...activityTypes["youDo"]] : [],
                                                                            },
                                                                        }));
                                                                    }}
                                                                />
                                                            </div>
                                                        )}
                                                    </div>

                                                </div>
                                            </div>
                                        </>
                                    ) : (
                                        /* Full Width Layout when NO Teaching Elements are selected  */
                                        <div className="flex items-start gap-4 w-full">
                                            {/* Course Hierarchy Card */}
                                            <div className="flex-1 bg-white rounded-md p-3 shadow-sm border border-slate-200">
                                                <div className="flex items-center gap-2 mb-2">
                                                    <div className="w-1.5 h-1.5 rounded-full bg-blue-500"></div>
                                                    <h3 className="text-xs font-semibold text-slate-700">Course Hierarchy</h3>
                                                </div>
                                                <div className="flex flex-wrap gap-1.5">
                                                    {/* All checkbox with perfect state management */}
                                                    <label className="flex items-center gap-1 px-2 py-1 text-xs rounded border border-slate-200 hover:bg-blue-50 hover:border-blue-300 cursor-pointer transition-colors">
                                                        <Checkbox
                                                            id="export-all"
                                                            checked={
                                                                // Check if all available options are selected
                                                                (selectedCourse?.courseHierarchy.includes('Module') ? exportSelections.hierarchy.module : true) &&
                                                                (selectedCourse?.courseHierarchy.includes('Sub Module') ? exportSelections.hierarchy.subModule : true) &&
                                                                (selectedCourse?.courseHierarchy.includes('Topic') ? exportSelections.hierarchy.topic : true) &&
                                                                (selectedCourse?.courseHierarchy.includes('Sub Topic') ? exportSelections.hierarchy.subTopic : true) &&
                                                                exportSelections.hierarchy.level
                                                            }
                                                            onCheckedChange={(checked) => {
                                                                const allChecked = !!checked;
                                                                setExportSelections((prev: { hierarchy: { module: any; subModule: any; topic: any; subTopic: any; }; }) => ({
                                                                    ...prev,
                                                                    hierarchy: {
                                                                        module: selectedCourse?.courseHierarchy.includes('Module') ? allChecked : prev.hierarchy.module,
                                                                        subModule: selectedCourse?.courseHierarchy.includes('Sub Module') ? allChecked : prev.hierarchy.subModule,
                                                                        topic: selectedCourse?.courseHierarchy.includes('Topic') ? allChecked : prev.hierarchy.topic,
                                                                        subTopic: selectedCourse?.courseHierarchy.includes('Sub Topic') ? allChecked : prev.hierarchy.subTopic,
                                                                        level: allChecked
                                                                    }
                                                                }));
                                                            }}
                                                            className="h-3 w-3"
                                                        />
                                                        <span className="text-slate-600">All</span>
                                                    </label>

                                                    {/* Individual checkboxes */}
                                                    {selectedCourse?.courseHierarchy.includes('Module') && (
                                                        <label className="flex items-center gap-1 px-2 py-1 text-xs rounded border border-slate-200 hover:bg-blue-50 hover:border-blue-300 cursor-pointer transition-colors">
                                                            <Checkbox
                                                                id="export-module"
                                                                checked={exportSelections.hierarchy.module}
                                                                onCheckedChange={(checked) => {
                                                                    setExportSelections((prev: { hierarchy: any; }) => ({
                                                                        ...prev,
                                                                        hierarchy: { ...prev.hierarchy, module: !!checked }
                                                                    }));
                                                                }}
                                                                className="h-3 w-3"
                                                            />
                                                            <span className="text-slate-600">Module</span>
                                                        </label>
                                                    )}

                                                    {selectedCourse?.courseHierarchy.includes('Sub Module') && (
                                                        <label className="flex items-center gap-1 px-2 py-1 text-xs rounded border border-slate-200 hover:bg-blue-50 hover:border-blue-300 cursor-pointer transition-colors">
                                                            <Checkbox
                                                                id="export-submodule"
                                                                checked={exportSelections.hierarchy.subModule}
                                                                onCheckedChange={(checked) => {
                                                                    setExportSelections((prev: { hierarchy: any; }) => ({
                                                                        ...prev,
                                                                        hierarchy: { ...prev.hierarchy, subModule: !!checked }
                                                                    }));
                                                                }}
                                                                className="h-3 w-3"
                                                            />
                                                            <span className="text-slate-600">Sub Module</span>
                                                        </label>
                                                    )}

                                                    {selectedCourse?.courseHierarchy.includes('Topic') && (
                                                        <label className="flex items-center gap-1 px-2 py-1 text-xs rounded border border-slate-200 hover:bg-blue-50 hover:border-blue-300 cursor-pointer transition-colors">
                                                            <Checkbox
                                                                id="export-topic"
                                                                checked={exportSelections.hierarchy.topic}
                                                                onCheckedChange={(checked) => {
                                                                    setExportSelections((prev: { hierarchy: any; }) => ({
                                                                        ...prev,
                                                                        hierarchy: { ...prev.hierarchy, topic: !!checked }
                                                                    }));
                                                                }}
                                                                className="h-3 w-3"
                                                            />
                                                            <span className="text-slate-600">Topic</span>
                                                        </label>
                                                    )}

                                                    {selectedCourse?.courseHierarchy.includes('Sub Topic') && (
                                                        <label className="flex items-center gap-1 px-2 py-1 text-xs rounded border border-slate-200 hover:bg-blue-50 hover:border-blue-300 cursor-pointer transition-colors">
                                                            <Checkbox
                                                                id="export-subtopic"
                                                                checked={exportSelections.hierarchy.subTopic}
                                                                onCheckedChange={(checked) => {
                                                                    setExportSelections((prev: { hierarchy: any; }) => ({
                                                                        ...prev,
                                                                        hierarchy: { ...prev.hierarchy, subTopic: !!checked }
                                                                    }));
                                                                }}
                                                                className="h-3 w-3"
                                                            />
                                                            <span className="text-slate-600">Sub Topic</span>
                                                        </label>
                                                    )}

                                                    <label className="flex items-center gap-1 px-2 py-1 text-xs rounded border border-slate-200 hover:bg-blue-50 hover:border-blue-300 cursor-pointer transition-colors">
                                                        <Checkbox
                                                            id="export-level"
                                                            checked={exportSelections.hierarchy.level}
                                                            onCheckedChange={(checked) => {
                                                                setExportSelections((prev: { hierarchy: any; }) => ({
                                                                    ...prev,
                                                                    hierarchy: { ...prev.hierarchy, level: !!checked }
                                                                }));
                                                            }}
                                                            className="h-3 w-3"
                                                        />
                                                        <span className="text-slate-600">Level</span>
                                                    </label>
                                                </div>
                                            </div>

                                            {/* Export Options Card */}
                                            <div className="bg-white rounded-md p-3 shadow-sm border border-slate-200 w-[35vw]">
                                                <div className="flex items-center gap-2 mb-2">
                                                    <div className="w-1.5 h-1.5 rounded-full bg-violet-500"></div>
                                                    <h3 className="text-xs font-semibold text-slate-700">Export Options</h3>
                                                </div>
                                                <div className="flex gap-2">
                                                    <Button
                                                        variant="outline"
                                                        size="sm"
                                                        onClick={handlePrint}
                                                        className="flex-1 text-xs h-7 px-2.5 border-slate-300 text-slate-600 hover:bg-slate-100 hover:border-slate-400"
                                                    >
                                                        <Printer className="h-3 w-3 mr-1" />
                                                        Print
                                                    </Button>
                                                    <Button
                                                        variant="default"
                                                        size="sm"
                                                        onClick={() => exportToExcel()}
                                                        className="flex-1 text-xs h-7 px-2.5 bg-blue-600 hover:bg-blue-700 text-white"
                                                    >
                                                        <FileText className="h-3 w-3 mr-1" />
                                                        Excel
                                                    </Button>
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>

                            <div className="overflow-auto p-4 pt-2">
                                <PreviewTable
                                    tableRows={tableRows}
                                    courseHours={courseHours}
                                    mergedCells={mergedCells}
                                    selectedCourse={selectedCourse}
                                    activityTypes={activityTypes}
                                    selectedPedagogyTypes={selectedPedagogyTypes}
                                    moduleSpans={moduleSpans}
                                    subModuleSpans={subModuleSpans}
                                    topicSpans={topicSpans}
                                    exportSelections={exportSelections}
                                    setExportSelections={setExportSelections as React.Dispatch<
                                        React.SetStateAction<ExportSelections>
                                    >}
                                    onExport={exportToExcel}
                                    isPrinting={true}
                                />
                            </div>
                        </motion.div>
                    </DialogContent>
                </Dialog>
            </AnimatePresence>
            {/* Full Preview Dialog - Shows all details by default */}
            <AnimatePresence>
                <Dialog open={showFullPreviewDialog} onOpenChange={setShowFullPreviewDialog}>
                    <DialogContent className="max-w-[98vw] max-h-[98vh] p-0 flex flex-col" onInteractOutside={(e) => e.preventDefault()}>
                        <motion.div
                            initial="hidden"
                            animate="visible"
                            exit="exit"
                            variants={popupVariants}
                            className="max-w-[98vw] max-h-[98vh] p-0 flex flex-col"
                        >
                            <DialogHeader className="p-4 pb-2 shrink-0 flex justify-between items-center">
                                <DialogTitle className="text-sm font-semibold">
                                    Full Table Preview - {selectedCourse?.courseName}
                                </DialogTitle>
                            </DialogHeader>

                            <div className="overflow-auto p-4 pt-2">
                                <PreviewTable
                                    tableRows={tableRows}
                                    courseHours={courseHours}
                                    mergedCells={mergedCells}
                                    selectedCourse={selectedCourse}
                                    activityTypes={activityTypes}
                                    selectedPedagogyTypes={["iDo", "weDo", "youDo"]} // Show all pedagogy types
                                    moduleSpans={moduleSpans}
                                    subModuleSpans={subModuleSpans}
                                    topicSpans={topicSpans}
                                    exportSelections={{
                                        printPedagogy: null,
                                        hierarchy: {
                                            module: true,
                                            subModule: true,
                                            topic: true,
                                            subTopic: true,
                                            level: true,
                                        },
                                        pedagogy: {
                                            iDo: activityTypes["iDo"],
                                            weDo: activityTypes["weDo"],
                                            youDo: activityTypes["youDo"],
                                        },
                                        showSummary: false,
                                    }}
                                    isPrinting={false} onExport={function (): void {
                                        throw new Error("Function not implemented.");
                                    }} setExportSelections={function (value: React.SetStateAction<ExportSelections>): void {
                                        throw new Error("Function not implemented.");
                                    }} />
                            </div>
                        </motion.div>
                    </DialogContent>
                </Dialog>
            </AnimatePresence>
            {/* Print Dialog */}
            <div style={{
                display: 'none',
            }}>
                <PrintComponent
                    ref={printRef}
                    leftLogo="/KIOT 1.png"
                    logo="/KIOT 1.png"
                    logoPosition="both"
                    rightLogo="/KIOT 1.png"
                    heading={`${selectedCourse?.courseName || 'Course'} Course Report`}
                    tableComponent={
                        <PreviewTable
                            tableRows={tableRows}
                            courseHours={courseHours}
                            mergedCells={mergedCells}
                            selectedCourse={selectedCourse}
                            activityTypes={activityTypes}
                            selectedPedagogyTypes={selectedPedagogyTypes}
                            moduleSpans={moduleSpans}
                            subModuleSpans={subModuleSpans}
                            topicSpans={topicSpans}
                            exportSelections={exportSelections}
                            setExportSelections={setExportSelections}
                            onExport={exportToExcel}
                            isPrinting={false}
                        />
                    }
                    signature="Prepared by Your Name"
                    landscape={true}
                    watermarkText=''
                    watermarkImage='/KIOT 1.png'
                    showSummary={exportSelections.showSummary}
                    summaryData={{
                        selectedPedagogyTypes,
                        activityTypes,
                        exportSelections: exportSelections.showSummary
                            ? {
                                ...exportSelections,
                                pedagogy: exportSelections.printPedagogy || { iDo: [], weDo: [], youDo: [] }
                            }
                            : {
                                ...exportSelections,
                                pedagogy: exportSelections.pedagogy || { iDo: [], weDo: [], youDo: [] }
                            },

                        calculateTotalHours: (type: "iDo" | "weDo" | "youDo", activity: string) => {
                            const columnKey = `${type}-${activity}`;

                            // Calculate merged values
                            const mergedValue = mergedCells[columnKey]?.reduce((sum, merge) => sum + merge.value, 0) || 0;

                            // Calculate unmerged values
                            const unmergedValue = Object.entries(courseHours).reduce((sum, [moduleId, moduleData]) => {
                                return sum + Object.entries(moduleData).reduce((moduleSum, [topicId, topicData]) => {
                                    return moduleSum + Object.entries(topicData).reduce((topicSum, [subtopicId, subtopicData]) => {
                                        // Check if this cell is part of any merge
                                        const isMerged = mergedCells[columnKey]?.some(merge => {
                                            // Check hierarchy matches
                                            const matchesModule = !merge.hierarchyIds?.modules.length ||
                                                merge.hierarchyIds.modules.includes(moduleId);
                                            const matchesSubModule = !merge.hierarchyIds?.subModules.length ||
                                                (!topicData.subModuleId || merge.hierarchyIds.subModules.includes(topicData?.subModuleId as any));
                                            const matchesTopic = !merge.hierarchyIds?.topics.length ||
                                                (!topicId || merge.hierarchyIds.topics.includes(topicId));
                                            const matchesSubTopic = !merge.hierarchyIds?.subTopics.length ||
                                                (!subtopicId || merge.hierarchyIds.subTopics.includes(subtopicId));

                                            return matchesModule && matchesSubModule && matchesTopic && matchesSubTopic;
                                        });

                                        // Only add if not part of a merge and has a value
                                        if (!isMerged && subtopicData[type]?.[activity]) {
                                            return topicSum + (subtopicData[type][activity] || 0);
                                        }
                                        return topicSum;
                                    }, 0);
                                }, 0);
                            }, 0);

                            return mergedValue + unmergedValue;
                        }
                    }}
                    courseDetails={selectedCourse ? {
                        courseName: selectedCourse.courseName || "",
                        courseCode: selectedCourse.courseCode || "",
                        clientName: selectedCourse.clientName || "",
                        serviceType: selectedCourse.serviceType || "",
                        serviceModal: selectedCourse.serviceModal || "",
                        category: selectedCourse.category || "",
                        courseLevel: selectedCourse.courseLevel || ""
                    } : undefined}
                />
            </div>
            {/* Unmerge Confirmation Dialog */}
            <AnimatePresence>
                {showUnmergeDialog && (
                    <motion.div
                        className="fixed inset-0 bg-gray-900/20 backdrop-blur-sm flex items-center justify-center z-50 p-4"
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                    >
                        <motion.div
                            className="bg-white rounded-lg shadow-xl max-w-sm w-full p-6"
                            initial={{ scale: 0.9, opacity: 0 }}
                            animate={{ scale: 1, opacity: 1 }}
                            exit={{ scale: 0.9, opacity: 0 }}
                            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
                        >
                            <div className="text-center">
                                <div className="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100">
                                    <AlertTriangle className="h-6 w-6 text-red-600" />
                                </div>
                                <h3 className="mt-5 text-lg font-medium text-gray-900">Confirm Unmerge</h3>
                                <div className="mt-2 text-sm text-gray-500">
                                    <p className="text-sm">
                                        Are you sure you want to delete this value?
                                    </p>
                                    <p className="text-sm">
                                        Are you sure you want to unmerge {pendingUnmerge?.activity} ({pendingUnmerge?.type})?
                                    </p>
                                </div>
                            </div>
                            <div className="mt-6 grid grid-cols-2 gap-3">
                                <Button
                                    variant="outline"
                                    size="sm"
                                    className="cursor-pointer"
                                    onClick={() => {
                                        setShowUnmergeDialog(false);
                                        setPendingUnmerge(null);
                                    }}
                                >
                                    Cancel
                                </Button>
                                <Button
                                    variant="destructive"
                                    size="sm"
                                    className="cursor-pointer"
                                    onClick={confirmUnmerge}
                                >
                                    {(isUnmergeConfirm ? "Unmerging..." : "Unmerge")}
                                </Button>
                            </div>
                        </motion.div>
                    </motion.div>
                )}
            </AnimatePresence>

            <Dialog open={showLevelDialog} onOpenChange={setShowLevelDialog}>
                <DialogContent className="sm:max-w-[425px]" onInteractOutside={(e) => e.preventDefault()}>
                    <DialogHeader>
                        <DialogTitle>
                            {editingLevel?.id === 'merged'
                                ? "Edit Merged Level"
                                : isNewLevel
                                    ? "Add Level"
                                    : "Edit Level"}
                        </DialogTitle>
                    </DialogHeader>
                    <div className="space-y-4">
                        <div className="space-y-2">
                            <Label htmlFor="level" className="text-xs font-medium">
                                Level*
                            </Label>
                            <Select
                                value={editingLevel?.level || ''}
                                onValueChange={(value) => {
                                    if (editingLevel) {
                                        setEditingLevel({
                                            ...editingLevel,
                                            level: value
                                        });
                                    }
                                }}
                            >
                                <SelectTrigger className="text-xs h-8">
                                    <SelectValue placeholder="Select level" />
                                </SelectTrigger>
                                <SelectContent>
                                    <SelectItem value="Easy" className="text-xs">
                                        Easy
                                    </SelectItem>
                                    <SelectItem value="Medium" className="text-xs">
                                        Medium
                                    </SelectItem>
                                    <SelectItem value="Hard" className="text-xs">
                                        Hard
                                    </SelectItem>
                                </SelectContent>
                            </Select>
                        </div>
                        <div className="flex justify-end gap-2 pt-4">
                            {/* Show delete button only if there's an existing value (not for new entries) */}
                            {!isNewLevel && editingLevel?.level && (
                                <Button
                                    variant="destructive"
                                    size="sm"
                                    onClick={() => {
                                        // For merged levels, use the editingLevel data directly
                                        if (editingLevel?.id === 'merged') {
                                            setLevelToDelete({
                                                id: 'merged',
                                                level: editingLevel.level,
                                                hierarchy: editingLevel.hierarchy
                                            });
                                        } else {
                                            // For individual levels, find the exact level data from levelsData
                                            const foundLevel = levelsData.find((l: any) =>
                                                l._id === editingLevel?.id ||
                                                (arraysEqual(l.module || [], editingLevel?.hierarchy.module || []) &&
                                                    arraysEqual(l.subModule || [], editingLevel?.hierarchy.subModule || []) &&
                                                    arraysEqual(l.topic || [], editingLevel?.hierarchy.topic || []) &&
                                                    arraysEqual(l.subTopic || [], editingLevel?.hierarchy.subTopic || []) &&
                                                    l.level === editingLevel?.level)
                                            );

                                            if (foundLevel) {
                                                setLevelToDelete({
                                                    id: foundLevel._id,
                                                    level: foundLevel.level,
                                                    hierarchy: {
                                                        module: foundLevel.module || [],
                                                        subModule: foundLevel.subModule || [],
                                                        topic: foundLevel.topic || [],
                                                        subTopic: foundLevel.subTopic || []
                                                    }
                                                });
                                            } else {
                                                // Fallback - use editingLevel data
                                                setLevelToDelete({
                                                    id: editingLevel?.id || '',
                                                    level: editingLevel?.level || '',
                                                    hierarchy: editingLevel?.hierarchy || {}
                                                });
                                            }
                                        }
                                        setShowLevelDeleteConfirmation(true);
                                    }}
                                    className="text-xs h-8 cursor-pointer"
                                >
                                    Delete
                                </Button>
                            )}
                            <Button
                                variant="outline"
                                size="sm"
                                onClick={() => {
                                    setShowLevelDialog(false)
                                }}
                                className="text-xs h-8 cursor-pointer"
                            >
                                Cancel
                            </Button>
                            <Button
                                variant="default"
                                size="sm"
                                onClick={handleLevelSave}
                                disabled={!editingLevel?.level}
                                className="text-xs h-8 cursor-pointer"
                            >
                                {isLevelSave ? (isNewLevel ? "Adding..." : "Saving...") : (isNewLevel ? "Add" : "Save")}

                            </Button>

                        </div>
                    </div>
                </DialogContent>
            </Dialog>
            <Dialog open={showLevelDeleteConfirmation} onOpenChange={setShowLevelDeleteConfirmation}>
                <DialogContent className="sm:max-w-md min-h-[40vh]" onInteractOutside={(e) => e.preventDefault()}>
                    <motion.div
                        initial="hidden"
                        animate="visible"
                        exit="exit"
                        variants={popupVariants}
                    >
                        <DialogHeader className="space-y-3 pb-4">
                            <DialogTitle className="text-lg font-semibold flex items-center gap-2">
                                <AlertTriangle className="h-5 w-5 text-red-500" />
                                Confirm Level Deletion
                            </DialogTitle>
                        </DialogHeader>
                        <div className="space-y-6">
                            <div className="bg-amber-50 border border-amber-200 rounded-lg p-4">
                                <div className="flex items-start gap-3">
                                    <AlertTriangle className="h-5 w-5 text-amber-600 mt-0.5 flex-shrink-0" />
                                    <div className="space-y-1">
                                        <p className="text-sm font-medium text-amber-800">
                                            Are you sure you want to delete this level?
                                        </p>
                                        <p className="text-xs text-amber-700">
                                            This action cannot be undone and will permanently remove the level assignment.
                                        </p>
                                    </div>
                                </div>
                            </div>


                            {levelToDelete && (
                                <div className="grid gap-2">
                                    {/* Level Value */}
                                    <div className="flex items-center justify-between py-2 px-3 bg-white rounded border">
                                        <span className="text-xs font-medium text-gray-600">Level:</span>
                                        <span className="text-xs font-semibold text-gray-900 bg-blue-100 text-blue-800 px-2 py-1 rounded-full">
                                            {levelToDelete?.level || editingLevel?.level || 'Not Set'}
                                        </span>
                                    </div>


                                </div>
                            )}

                            <div className="flex justify-end gap-2">
                                <Button
                                    variant="ghost"
                                    size="sm"
                                    onClick={() => setShowLevelDeleteConfirmation(false)}
                                    className="cursor-pointer"
                                >
                                    Cancel
                                </Button>
                                <Button
                                    variant="destructive"
                                    size="sm"
                                    onClick={async () => {
                                        if (!levelToDelete || !selectedCourse) return;
                                        setIsLevelDelete(true);
                                        try {
                                            // Filter placeholder IDs from the level to delete
                                            const filterPlaceholders = (ids: string[] = []) => {
                                                return ids.filter(id => id && !id.includes('placeholder'));
                                            };

                                            const filteredHierarchy = {
                                                module: filterPlaceholders(levelToDelete.hierarchy.module),
                                                subModule: filterPlaceholders(levelToDelete.hierarchy.subModule),
                                                topic: filterPlaceholders(levelToDelete.hierarchy.topic),
                                                subTopic: filterPlaceholders(levelToDelete.hierarchy.subTopic)
                                            };

                                            // Find the exact level to delete using filtered hierarchy
                                            const levelData = levelsData.find((l: any) => {
                                                const levelModules = filterPlaceholders(l.module || []);
                                                const levelSubModules = filterPlaceholders(l.subModule || []);
                                                const levelTopics = filterPlaceholders(l.topic || []);
                                                const levelSubTopics = filterPlaceholders(l.subTopic || []);

                                                return (
                                                    arraysEqual(levelModules, filteredHierarchy.module) &&
                                                    arraysEqual(levelSubModules, filteredHierarchy.subModule) &&
                                                    arraysEqual(levelTopics, filteredHierarchy.topic) &&
                                                    arraysEqual(levelSubTopics, filteredHierarchy.subTopic) &&
                                                    l.level === levelToDelete.level
                                                );
                                            });

                                            if (levelData?._id) {
                                                await deleteLevelMutation.mutateAsync(levelData._id);
                                                setShowLevelDeleteConfirmation(false);
                                                setShowLevelDialog(false);
                                                setLevelToDelete(null);
                                            } else {
                                                setErrorMessage("Level not found for deletion");
                                                setShowErrorDialog(true);
                                            }
                                        } catch (error) {
                                            console.error("Failed to delete level:", error);
                                            setErrorMessage(error instanceof Error ? error.message : "Failed to delete level");
                                            setShowErrorDialog(true);
                                        } finally {
                                            setIsLevelDelete(false);
                                        }
                                    }}
                                    className="cursor-pointer"
                                >
                                    {isLevelDelete ? "Deleting..." : "Delete Level"}
                                </Button>
                            </div>
                        </div>
                    </motion.div>
                </DialogContent>
            </Dialog>
            {/* Merge Level Dialog */}
            <Dialog open={showMergeLevelDialog} onOpenChange={(open) => {
                if (!open) {
                    setShowMergeLevelDialog(false);
                    setPendingLevelMerge(null);
                    setMergeLevelValue("");
                }
            }}>
                <DialogContent className="sm:max-w-md" onInteractOutside={(e) => e.preventDefault()}>
                    <DialogHeader>
                        <DialogTitle>Merge Levels</DialogTitle>
                    </DialogHeader>
                    <div className="space-y-4">
                        <div className="space-y-2">
                            <Label htmlFor="level" className="text-sm font-medium">
                                Select Level for Merged Cells
                            </Label>
                            <Select
                                value={mergeLevelValue}
                                onValueChange={setMergeLevelValue}
                            >
                                <SelectTrigger className="w-full">
                                    <SelectValue placeholder="Select a level" />
                                </SelectTrigger>
                                <SelectContent>
                                    <SelectItem value="Easy">Easy</SelectItem>
                                    <SelectItem value="Medium">Medium</SelectItem>
                                    <SelectItem value="Hard">Hard</SelectItem>
                                </SelectContent>
                            </Select>
                        </div>
                        <div className="flex justify-end gap-2 pt-4">
                            <Button
                                variant="outline"
                                onClick={() => {
                                    setShowMergeLevelDialog(false);
                                    setPendingLevelMerge(null);
                                    setMergeLevelValue("");
                                }}
                                className="cursor-pointer"
                            >
                                Cancel
                            </Button>
                            <Button
                                onClick={confirmLevelMerge}
                                disabled={!mergeLevelValue}
                                className="cursor-pointer"
                            >
                                {(isLevelMergeSave ? "Merging..." : "Merge Levels")}
                            </Button>
                        </div>
                    </div>
                </DialogContent>
            </Dialog>
            {/* Level Unmerge Confirmation Dialog */}
            <AnimatePresence>
                {showUnmergeLevelDialog && (
                    <motion.div
                        className="fixed inset-0 bg-gray-900/20 backdrop-blur-sm flex items-center justify-center z-50 p-4"
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                    >
                        <motion.div
                            className="bg-white rounded-lg shadow-xl max-w-sm w-full p-6"
                            initial={{ scale: 0.9, opacity: 0 }}
                            animate={{ scale: 1, opacity: 1 }}
                            exit={{ scale: 0.9, opacity: 0 }}
                            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
                        >
                            <div className="text-center">
                                <div className="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100">
                                    <AlertTriangle className="h-6 w-6 text-red-600" />
                                </div>
                                <h3 className="mt-5 text-lg font-medium text-gray-900">Confirm Unmerge</h3>
                                <div className="mt-2 text-sm text-gray-500">
                                    <p className="text-sm">
                                        Are you sure you want to delete this value?
                                    </p>
                                    <p className="text-sm">
                                        Are you sure you want to unmerge this level?
                                    </p>
                                </div>
                            </div>
                            <div className="mt-6 grid grid-cols-2 gap-3">
                                <Button
                                    variant="outline"
                                    size="sm"
                                    onClick={() => {
                                        setShowUnmergeLevelDialog(false);
                                        setPendingLevelUnmerge(null);
                                    }}
                                    className="cursor-pointer"
                                >
                                    Cancel
                                </Button>
                                <Button
                                    variant="destructive"
                                    size="sm"
                                    onClick={confirmLevelUnmerge}
                                    className="cursor-pointer"
                                >
                                    {(isLevelUnmergeConfirm ? "Unmerging..." : "Unmerge")}
                                </Button>
                            </div>
                        </motion.div>
                    </motion.div>
                )}
            </AnimatePresence>
            {/* Delete Cell Confirmation Dialog */}
            <AnimatePresence>
                {showDeleteCellDialog && (
                    <motion.div
                        className="fixed inset-0 bg-gray-900/20 backdrop-blur-sm flex items-center justify-center z-50 p-4"
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                    >
                        <motion.div
                            className="bg-white rounded-lg shadow-xl max-w-sm w-full p-6"
                            initial={{ scale: 0.9, opacity: 0 }}
                            animate={{ scale: 1, opacity: 1 }}
                            exit={{ scale: 0.9, opacity: 0 }}
                            transition={{ type: 'spring', stiffness: 300, damping: 30 }}
                        >
                            <div className="text-center">
                                <div className="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100">
                                    <AlertTriangle className="h-6 w-6 text-red-600" />
                                </div>
                                <h3 className="mt-5 text-lg font-medium text-gray-900">Delete Confirmation</h3>
                                <div className="mt-2 text-sm text-gray-500">
                                    <p className="text-sm">
                                        Are you sure you want to delete this value?
                                    </p>
                                    <p className="text-xs text-gray-500">
                                        This will remove the hours value for {cellToDelete?.activity} ({cellToDelete?.type}).
                                    </p>
                                </div>
                            </div>
                            <div className="mt-6 grid grid-cols-2 gap-3">
                                <Button
                                    variant="outline"
                                    size="sm"
                                    onClick={() => {
                                        setShowDeleteCellDialog(false);
                                        setCellToDelete(null);
                                    }}
                                    className="cursor-pointer"
                                >
                                    Cancel
                                </Button>
                                <Button
                                    variant="destructive"
                                    size="sm"
                                    onClick={confirmCellDelete}
                                    className="cursor-pointer"
                                >
                                    {isPedagogyDeleteConfirm ? "Deleting..." : "Delete"}
                                </Button>
                            </div>
                        </motion.div>
                    </motion.div>
                )}
            </AnimatePresence>

            {/* Multiple Delete Type Selection Dialog */}
            <AnimatePresence>
                <Dialog open={showMultipleDeleteDialog} onOpenChange={setShowMultipleDeleteDialog}>
                    <DialogContent className="sm:max-w-md max-w-[95vw] rounded-xl shadow-lg border border-gray-200" onInteractOutside={(e) => e.preventDefault()}>
                        <motion.div
                            initial="hidden"
                            animate="visible"
                            exit="exit"
                            variants={popupVariants}
                        >
                            {/* Header */}
                            <DialogHeader className="border-b pb-3">
                                <DialogTitle className="text-lg font-semibold text-gray-800">
                                    Multiple Delete
                                </DialogTitle>
                                <DialogDescription className="text-sm text-gray-500">
                                    Select the type of items you want to delete
                                </DialogDescription>
                            </DialogHeader>

                            <div className="space-y-4 p-4">
                                {/* Type Selection */}
                                <div className="space-y-3">
                                    <h4 className="text-sm font-medium text-gray-700">Select Item Type:</h4>
                                    <div className="grid grid-cols-1 gap-2">
                                        {selectedCourse?.courseHierarchy.map(level => {
                                            const normalizedLevel = level
                                                .toLowerCase()
                                                .replace(" ", "") as "module" | "submodule" | "topic" | "subtopic";
                                            const items = {
                                                module: sortedModules,
                                                submodule: sortedSubModules,
                                                topic: sortedTopics,
                                                subtopic: sortedSubTopics
                                            }[normalizedLevel];

                                            if (!items || items.length === 0) return null;

                                            return (
                                                <button
                                                    key={level}
                                                    onClick={() => activateGlobalDeleteMode(normalizedLevel)}
                                                    className="flex items-center justify-between p-3 border rounded-lg cursor-pointer transition hover:bg-blue-50 hover:border-blue-300 bg-white"
                                                >
                                                    <div className="flex items-center gap-2">
                                                        <span className="text-sm font-medium text-gray-700">
                                                            {level}
                                                        </span>
                                                    </div>
                                                    <div className="flex items-center gap-2">
                                                        <span className="text-xs text-gray-500">{items.length} items</span>
                                                        <ChevronRight className="w-4 h-4 text-gray-400" />
                                                    </div>
                                                </button>
                                            );
                                        })}
                                    </div>
                                </div>

                                {/* Action Buttons */}
                                <div className="flex justify-end pt-2">
                                    <Button
                                        variant="ghost"
                                        onClick={() => setShowMultipleDeleteDialog(false)}
                                        className="text-sm"
                                    >
                                        Cancel
                                    </Button>
                                </div>
                            </div>
                        </motion.div>
                    </DialogContent>
                </Dialog>
            </AnimatePresence>

            {showDuplicatePopup && (
                <motion.div
                    initial={{ opacity: 0 }}
                    animate={{ opacity: 1 }}
                    exit={{ opacity: 0 }}
                    className="fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4"
                >
                    <motion.div
                        initial={{ scale: 0.95, opacity: 0 }}
                        animate={{ scale: 1, opacity: 1 }}
                        transition={{ type: "spring", damping: 25, stiffness: 300 }}
                        className="bg-white rounded-2xl shadow-xl w-full max-w-6xl max-h-[98vh] flex flex-col overflow-hidden border border-gray-200"
                    >

                        {/* Header */}
                        <div className="flex justify-between items-center px-6 py-4 bg-gradient-to-r from-blue-600 to-indigo-700 text-white">
                            <div className="flex items-center gap-2">
                                <Copy className="w-5 h-5" />
                                <h2 className="text-lg font-semibold">Duplicate Course</h2>
                            </div>
                            <button
                                onClick={handleClosePopup}
                                className="p-2 cursor-pointer hover:bg-red-600/80 bg-red-500 rounded-lg transition"
                            >
                                <X className="w-4 h-4" />
                            </button>
                        </div>

                        {/* Content */}
                        <div className="flex-1 overflow-auto thin-scrollbar p-4">
                            <div className="grid grid-cols-1 lg:grid-cols-1 gap-6">
                                {/* Left Column - Course Selection and Options */}
                                <div className="space-y-6">
                                    {/* Course Selection */}
                                    <div className="space-y-3">
                                        {/* Selection Mode Toggle */}
                                        <div className="flex items-center justify-between">
                                            <label className="block text-sm font-medium text-gray-700">
                                                Select course to duplicate:
                                            </label>
                                            <div className="flex items-center gap-2 text-xs">
                                                <span className="text-gray-600">Mode:</span>
                                                <div className="flex bg-gray-100 rounded-lg p-0.5">
                                                    <button
                                                        type="button"
                                                        onClick={() => {
                                                            setDuplicateSelectionMode('hierarchy')
                                                            setSelectedDuplicateCourse(null);
                                                            setSelectedDuplicateOptions({ hierarchy: [] });
                                                        }}
                                                        className={`px-2 py-1 rounded-md text-xs font-medium cursor-pointer transition-all ${duplicateSelectionMode === 'hierarchy'
                                                            ? 'bg-white shadow-sm text-blue-600'
                                                            : 'text-gray-600 hover:text-gray-800'
                                                            }`}
                                                    >
                                                        Hierarchy Based
                                                    </button>
                                                    <button
                                                        type="button"
                                                        onClick={() => {
                                                            setDuplicateSelectionMode('all')
                                                            setSelectedDuplicateCourse(null);
                                                            setSelectedDuplicateOptions({ hierarchy: [] });
                                                        }}
                                                        className={`px-2 py-1 rounded-md text-xs font-medium cursor-pointer transition-all ${duplicateSelectionMode === 'all'
                                                            ? 'bg-white shadow-sm text-blue-600'
                                                            : 'text-gray-600 hover:text-gray-800'
                                                            }`}
                                                    >
                                                        All Courses
                                                    </button>
                                                </div>
                                            </div>
                                        </div>

                                        {/* Filters and Course Selection Row */}
                                        <div className="flex flex-col sm:flex-row gap-3">
                                            {/* Category Filter */}
                                            <div className="flex-1 sm:flex-none sm:w-48">
                                                <label className="block text-xs font-medium text-gray-600 mb-1">
                                                    Filter by Category:
                                                </label>
                                                <Select
                                                    value={selectedCategory}
                                                    onValueChange={setSelectedCategory}
                                                >
                                                    <SelectTrigger className="w-full h-9 text-xs bg-gray-50 border-gray-300">
                                                        <SelectValue placeholder="Select category" />
                                                    </SelectTrigger>
                                                    <SelectContent>
                                                        {getAvailableCategories().map((category) => (
                                                            <SelectItem key={category} value={category} className="text-xs">
                                                                {category === 'all' ? 'All Categories' : category}
                                                            </SelectItem>
                                                        ))}
                                                    </SelectContent>
                                                </Select>
                                            </div>

                                            {/* Course Dropdown */}
                                            <div className="flex-1">
                                                {getAvailableDuplicateCourses().length === 0 ? (
                                                    <motion.div
                                                        initial={{ opacity: 0, y: 10 }}
                                                        animate={{ opacity: 1, y: 0 }}
                                                        className="bg-amber-50 border border-amber-200 rounded-lg p-4 flex items-center gap-3"
                                                    >
                                                        <AlertTriangle className="w-5 h-5 text-amber-600 flex-shrink-0" />
                                                        <div>
                                                            <p className="text-amber-800 font-medium text-sm">
                                                                {duplicateSelectionMode === 'hierarchy'
                                                                    ? "No courses found with matching hierarchy structure."
                                                                    : "No other courses available for duplication."
                                                                }
                                                                {selectedCategory !== 'all' && ` in the "${selectedCategory}" category.`}
                                                            </p>
                                                            <p className="text-amber-700 text-xs mt-1">
                                                                {duplicateSelectionMode === 'hierarchy'
                                                                    ? "Try switching to 'All Courses' mode to see all available courses."
                                                                    : "Only the current course exists in the system."
                                                                }
                                                            </p>
                                                        </div>
                                                    </motion.div>
                                                ) : (
                                                    <>
                                                        <label className="block text-xs font-medium text-gray-600 mb-1">
                                                            Select Course:
                                                        </label>
                                                        <div className="flex gap-2">
                                                            <SearchableCourseSelect
                                                                courses={getAvailableDuplicateCourses()}
                                                                selectedCourse={selectedDuplicateCourse}
                                                                onCourseSelect={setSelectedDuplicateCourse}
                                                                placeholder={
                                                                    duplicateSelectionMode === 'hierarchy'
                                                                        ? "Search for a course with matching hierarchy..."
                                                                        : "Search for any course..."
                                                                }
                                                            />
                                                            <PreviewButton course={selectedDuplicateCourse} />
                                                        </div>
                                                    </>
                                                )}
                                            </div>
                                        </div>
                                    </div>

                                    {/* Duplication Options */}
                                    {selectedDuplicateCourse && (
                                        <motion.div
                                            initial={{ opacity: 0, y: 8 }}
                                            animate={{ opacity: 1, y: 0 }}
                                            className="space-y-3"
                                        >
                                            {duplicateSelectionMode === 'all' && (
                                                <motion.div
                                                    initial={{ opacity: 0, scale: 0.95 }}
                                                    animate={{ opacity: 1, scale: 1 }}
                                                    className="bg-amber-50 border border-amber-200 rounded-lg p-3"
                                                >
                                                    <div className="flex items-start gap-2">
                                                        <AlertTriangle className="w-4 h-4 text-amber-600 mt-0.5 flex-shrink-0" />
                                                        <div className="text-amber-800 text-xs">
                                                            <strong>Note:</strong> Selected course has different hierarchy structure.
                                                            Only common consecutive levels will be available for duplication.
                                                        </div>
                                                    </div>
                                                </motion.div>
                                            )}
                                            <div className="bg-white border rounded-xl shadow-sm p-3">
                                                <div className="flex items-center justify-between gap-3 mb-2">
                                                    <h4 className="font-medium text-gray-800 text-sm flex items-center gap-1 flex-shrink-0">
                                                        <Layers className="w-4 h-4 text-blue-500" />
                                                        Available Hierarchy Levels
                                                    </h4>

                                                    {/* Single line layout for checkboxes */}
                                                    <div className="flex items-center gap-3 flex-wrap">
                                                        {/* Individual hierarchy checkboxes */}
                                                        {getCommonHierarchyLevels(selectedCourse, selectedDuplicateCourse).map((level) => {
                                                            const isEnabled = isHierarchyLevelEnabled(level);
                                                            const isChecked = selectedDuplicateOptions.hierarchy.includes(level);

                                                            // Convert back to display format
                                                            const displayLevel = level === 'SubModule' ? 'Sub Module' :
                                                                level === 'SubTopic' ? 'Sub Topic' : level;

                                                            return (
                                                                <div
                                                                    key={level}
                                                                    className={`flex items-center gap-1.5 px-2 py-1 rounded-md transition ${isEnabled
                                                                        ? "hover:bg-blue-50"
                                                                        : "opacity-50 cursor-not-allowed"
                                                                        }`}
                                                                >
                                                                    <Checkbox
                                                                        id={`hierarchy-${level}`}
                                                                        checked={isChecked}
                                                                        disabled={!isEnabled}
                                                                        onCheckedChange={(checked) =>
                                                                            handleHierarchyCheckboxChange(level, checked)
                                                                        }
                                                                        className="scale-90"
                                                                    />
                                                                    <label
                                                                        htmlFor={`hierarchy-${level}`}
                                                                        className={`text-xs font-medium whitespace-nowrap cursor-pointer ${isEnabled ? "text-gray-700" : "text-gray-400"
                                                                            }`}
                                                                    >
                                                                        {displayLevel}
                                                                        {level === "Module" && "s"}
                                                                        {level === "SubModule" && "s"}
                                                                        {level === "Topic" && "s"}
                                                                        {level === "SubTopic" && "s"}
                                                                    </label>
                                                                </div>
                                                            );
                                                        })}

                                                        {/* Select All at the end with separator */}
                                                        {getCommonHierarchyLevels(selectedCourse, selectedDuplicateCourse).length > 0 && (
                                                            <>
                                                                <div className="h-5 w-px bg-gray-300" />
                                                                <div className="flex items-center gap-1.5 px-2 py-1 rounded-md hover:bg-blue-50 transition">
                                                                    <Checkbox
                                                                        id="select-all-hierarchy"
                                                                        checked={
                                                                            selectedDuplicateOptions.hierarchy.length > 0 &&
                                                                            getCommonHierarchyLevels(selectedCourse, selectedDuplicateCourse)
                                                                                .every(level => selectedDuplicateOptions.hierarchy.includes(level))
                                                                        }
                                                                        onCheckedChange={handleSelectAllHierarchy}
                                                                        className="scale-90"
                                                                    />
                                                                    <label
                                                                        htmlFor="select-all-hierarchy"
                                                                        className="text-xs font-medium text-blue-600 cursor-pointer hover:text-blue-700 whitespace-nowrap"
                                                                    >
                                                                        Select All
                                                                    </label>
                                                                </div>
                                                            </>
                                                        )}
                                                    </div>
                                                </div>

                                                {/* Show message if no common levels */}
                                                {getCommonHierarchyLevels(selectedCourse, selectedDuplicateCourse).length === 0 && (
                                                    <div className="text-center py-3 text-gray-500 text-xs">
                                                        No common hierarchy levels available for duplication.
                                                    </div>
                                                )}

                                                {/* Inline Info */}
                                                <p className="mt-2 text-[11px] text-gray-500 flex items-center gap-1">
                                                    <Info className="w-3 h-3 text-gray-400" />
                                                    {duplicateSelectionMode === 'hierarchy'
                                                        ? "Select levels in order. Later levels unlock automatically."
                                                        : "Only common consecutive hierarchy levels are available."
                                                    }
                                                </p>
                                            </div>

                                            {/* Selection Summary (Compact Pills) */}
                                            {selectedDuplicateOptions.hierarchy.length > 0 && (
                                                <div className="flex flex-wrap gap-2 text-xs bg-blue-50 border border-blue-200 rounded-lg p-2">
                                                    <span className="text-blue-800 font-medium">Selected:</span>
                                                    {selectedDuplicateOptions.hierarchy.map((item) => {
                                                        const displayItem = item === 'SubModule' ? 'Sub Module' :
                                                            item === 'SubTopic' ? 'Sub Topic' : item;
                                                        return (
                                                            <span
                                                                key={item}
                                                                className="px-2 py-0.5 bg-blue-100 text-blue-700 rounded-full"
                                                            >
                                                                {displayItem}
                                                            </span>
                                                        );
                                                    })}
                                                </div>
                                            )}

                                            <ModuleSelectionToggle />
                                        </motion.div>
                                    )}

                                </div>

                                {/* Right Column - Preview */}
                                {(enableModuleSelection || !selectedDuplicateCourse) && (
                                    <div>
                                        <h3 className="text-lg font-semibold text-gray-800 mb-4">Preview</h3>
                                        {selectedDuplicateCourse ? (
                                            <motion.div
                                                initial={{ opacity: 0, y: 10 }}
                                                animate={{ opacity: 1, y: 0 }}
                                                transition={{ delay: 0.1 }}
                                                className="border border-gray-200 overflow-hidden shadow-lg"
                                            >
                                                <div className="max-h-96 overflow-auto thin-scrollbar">
                                                    {isDuplicateModulesLoading || isDuplicateSubModulesLoading ||
                                                        isDuplicateTopicsLoading || isDuplicateSubTopicsLoading ? (
                                                        <div className="flex items-center justify-center h-32">
                                                            <Loader2 className="w-6 h-6 animate-spin mr-2" />
                                                            Loading course data...
                                                        </div>
                                                    ) : (
                                                        <DuplicationPreviewTable
                                                            tableRows={createDuplicateTableRows()}
                                                            selectedCourse={selectedDuplicateCourse}
                                                            moduleSpans={getDuplicateSpans().moduleSpans}
                                                            subModuleSpans={getDuplicateSpans().subModuleSpans}
                                                            topicSpans={getDuplicateSpans().topicSpans}
                                                        />
                                                    )}
                                                </div>
                                            </motion.div>
                                        ) : (
                                            <div className="flex flex-col items-center justify-center text-center p-10 bg-gradient-to-br from-indigo-50 via-white to-blue-50 rounded-xl border border-gray-200 shadow-sm">
                                                <div className="flex items-center justify-center w-16 h-16 rounded-full bg-indigo-100 text-indigo-600 mb-4 shadow-inner">
                                                    <BookOpen className="w-8 h-8" />
                                                </div>
                                                <h3 className="text-gray-800 font-semibold text-lg">
                                                    No Course Selected
                                                </h3>
                                                <p className="text-gray-500 text-sm mt-1 max-w-sm">
                                                    Please <span className="text-indigo-600 font-medium">select a course</span> to preview its structure and hierarchy details here.
                                                </p>
                                            </div>
                                        )}
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* Footer */}
                        <div className="flex justify-between items-center p-5 bg-gray-50 border-t border-gray-200">
                            <div className="text-sm text-gray-600">
                                Duplicating to: <span className="font-medium">{selectedCourse?.courseName}</span>
                            </div>
                            <div className="flex gap-3">
                                <motion.button
                                    whileHover={{ scale: 1.02 }}
                                    whileTap={{ scale: 0.98 }}
                                    onClick={handleClosePopup}
                                    className="px-5 py-2.5 cursor-pointer text-sm font-medium border border-gray-300 rounded-lg hover:bg-gray-100 transition-colors text-gray-700"
                                >
                                    Cancel
                                </motion.button>
                                <motion.button
                                    whileHover={{ scale: 1.02 }}
                                    whileTap={{ scale: 0.98 }}
                                    onClick={() => {
                                        // Show confirmation dialog instead of directly calling handleDuplicateConfirm
                                        if (selectedDuplicateCourse && selectedDuplicateOptions.hierarchy.length > 0) {
                                            setShowDuplicateConfirmation(true);
                                        }
                                    }}
                                    disabled={!selectedDuplicateCourse ||
                                        (selectedDuplicateOptions.hierarchy.length === 0) ||
                                        duplicateCourseHierarchyMutation.isPending}
                                    className="px-5 py-2.5 cursor-pointer text-sm font-medium bg-gradient-to-r from-blue-600 to-indigo-700 text-white rounded-lg hover:from-blue-700 hover:to-indigo-800 disabled:opacity-50 disabled:cursor-not-allowed transition-all shadow-md disabled:shadow-none"
                                >
                                    <div className="flex items-center gap-2">
                                        {duplicateCourseHierarchyMutation.isPending ? (
                                            <Loader2 className="w-4 h-4 animate-spin" />
                                        ) : (
                                            <Copy className="w-4 h-4" />
                                        )}
                                        {duplicateCourseHierarchyMutation.isPending ? 'Duplicating...' : enableModuleSelection && selectedModulesForDuplication.size > 0
                                            ? `Duplicate ${selectedModulesForDuplication.size} Selected Modules`
                                            : 'Duplicate Structure'}
                                    </div>
                                </motion.button>
                            </div>
                        </div>
                    </motion.div>
                </motion.div>
            )}
            {showCoursePreview && <CoursePreviewPopup />}

            {/* Pedagogy Value Dialog */}
            <Dialog open={showPedagogyDialog} onOpenChange={(open) => {
                if (!open) {
                    setShowPedagogyDialog(false);
                    setPedagogyFormData(null);
                }
            }}>
                <DialogContent className="sm:max-w-md" onInteractOutside={(e) => e.preventDefault()}>
                    <DialogHeader>
                        <DialogTitle>
                            {pedagogyFormData?.isEditing ? "Edit Pedagogy Hours" : "Add Pedagogy Hours"}
                        </DialogTitle>
                        <DialogDescription>
                            {pedagogyFormData?.activity} ({pedagogyFormData?.type})
                        </DialogDescription>
                    </DialogHeader>
                    <div className="space-y-4">
                        <div className="space-y-2">
                            <Label htmlFor="hours" className="text-sm font-medium">
                                Hours
                            </Label>
                            <Input
                                type="number"
                                id="hours"
                                value={pedagogyFormData?.value || ""}
                                onChange={(e) => setPedagogyFormData(prev => prev ? { ...prev, value: e.target.value } : null)}
                                placeholder="Enter hours (e.g., 2.5)"
                                step="0.5"
                                min="0"
                                className="w-full"
                                autoFocus
                            />
                            <p className="text-xs text-gray-500">
                                Enter the number of hours for this activity (must be greater than 0)
                            </p>
                        </div>

                        <div className="flex justify-between items-center">
                            <div className="flex justify-end gap-2 ml-auto">
                                <Button
                                    variant="outline"
                                    onClick={() => {
                                        setShowPedagogyDialog(false);
                                        setPedagogyFormData(null);
                                    }}
                                    className="cursor-pointer"
                                >
                                    Cancel
                                </Button>
                                <Button
                                    onClick={handlePedagogySave}
                                    disabled={!pedagogyFormData?.value || parseFloat(pedagogyFormData.value) <= 0}
                                    className="disabled:cursor-not-allowed cursor-pointer"
                                >
                                    {pedagogyFormData?.isEditing ? "Update" : "Add"}
                                </Button>
                            </div>
                        </div>
                    </div>
                </DialogContent>
            </Dialog>

            {/* Duplicate Confirmation Dialog */}
            <AnimatePresence>
                {showDuplicateConfirmation && (
                    <motion.div
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        exit={{ opacity: 0 }}
                        className="fixed inset-0 bg-black/50 backdrop-blur-sm z-[60] flex items-center justify-center p-4"
                    >
                        <motion.div
                            initial={{ scale: 0.95, opacity: 0 }}
                            animate={{ scale: 1, opacity: 1 }}
                            className="bg-white rounded-xl shadow-xl w-full max-w-7xl max-h-[95vh] flex flex-col"
                        >
                            <div className="bg-gradient-to-r from-blue-600 via-indigo-600 to-blue-700 rounded-t-xl shadow-sm">
                                <div className="p-3 sm:p-5 flex items-center gap-4 text-white">
                                    {/* Icon section with animated pulse */}
                                    <div className="relative">
                                        <div className="w-10 h-10 sm:w-11 sm:h-11 rounded-full bg-white/20 flex items-center justify-center backdrop-blur-sm shadow-inner">
                                            <AlertTriangle className="w-5 h-5 sm:w-6 sm:h-6 text-white animate-pulse" />
                                        </div>
                                        <div className="absolute inset-0 rounded-full bg-white/10 blur-md animate-ping opacity-40" />
                                    </div>

                                    {/* Text section */}
                                    <div className="flex-1">
                                        <h3 className="text-base sm:text-md font-semibold tracking-wide">
                                            Confirm Duplication
                                        </h3>
                                        <p className="text-sm sm:text-sm text-blue-100 mt-1">
                                            Review the selected items before duplication
                                        </p>
                                    </div>

                                </div>
                            </div>

                            <div className="p-4 flex-1 overflow-auto thin-scrollbar">


                                <div className="space-y-3">
                                    <div className="flex flex-col lg:flex-row gap-2">
                                        {/* Source Course */}
                                        <div className="flex-1 bg-gray-50 rounded-lg p-3 border border-gray-100 text-xs">
                                            <span className="font-medium text-gray-700 block mb-1">Source Course:</span>
                                            <p className="text-gray-900 truncate">{selectedDuplicateCourse?.courseName}</p>
                                        </div>

                                        {/* Target Course */}
                                        <div className="flex-1 bg-gray-50 rounded-lg p-3 border border-gray-100 text-xs">
                                            <span className="font-medium text-gray-700 block mb-1">Target Course:</span>
                                            <p className="text-gray-900 truncate">{selectedCourse?.courseName}</p>
                                        </div>

                                        {/* Selected for Duplication */}
                                        <div className="flex-1.5 bg-blue-50 border border-blue-200 rounded-lg p-3 text-xs">
                                            <h4 className="font-medium text-blue-800 mb-1">Selected for Duplication:</h4>
                                            <div className="flex flex-wrap gap-1.5">
                                                {selectedDuplicateOptions.hierarchy.map((item) => {
                                                    const displayItem =
                                                        item === 'SubModule'
                                                            ? 'Sub Module'
                                                            : item === 'SubTopic'
                                                                ? 'Sub Topic'
                                                                : item;

                                                    // get count from your calculateConfirmationStats()
                                                    const stats = calculateConfirmationStats();
                                                    const count =
                                                        item === 'Module'
                                                            ? stats.modules
                                                            : item === 'SubModule'
                                                                ? stats.subModules
                                                                : item === 'Topic'
                                                                    ? stats.topics
                                                                    : item === 'SubTopic'
                                                                        ? stats.subTopics
                                                                        : 0;

                                                    return (
                                                        <span
                                                            key={item}
                                                            className="px-2.5 py-0.5 bg-blue-100 text-blue-700 rounded-full text-xs font-medium"
                                                        >
                                                            {displayItem}s ({count})
                                                        </span>
                                                    );
                                                })}
                                            </div>
                                        </div>
                                    </div>


                                    {/* Preview Table */}
                                    <div className="border border-gray-200 rounded-lg overflow-hidden">
                                        <div className="bg-gray-100 px-4 py-2 border-b border-gray-200">
                                            <h4 className="font-medium text-gray-800 text-sm">
                                                Preview of Items to be Duplicated
                                            </h4>
                                        </div>
                                        <div className="max-h-64 overflow-auto thin-scrollbar">
                                            <ConfirmationPreviewTable
                                                selectedDuplicateCourse={selectedDuplicateCourse}
                                                selectedHierarchy={selectedDuplicateOptions.hierarchy}
                                                selectedModules={selectedModulesForDuplication}
                                                enableModuleSelection={enableModuleSelection}
                                            />
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div className="flex justify-between items-center p-4 bg-gray-50 border-t border-gray-200">
                                <div className="text-sm text-gray-600">
                                    Total items: <span className="font-medium text-blue-600">{calculateConfirmationStats().total}</span>
                                </div>
                                <div className="flex gap-3">
                                    <motion.button
                                        whileHover={{ scale: 1.02 }}
                                        whileTap={{ scale: 0.98 }}
                                        onClick={() => setShowDuplicateConfirmation(false)}
                                        className="px-6 py-2 cursor-pointer text-sm font-medium border border-gray-300 rounded-lg hover:bg-gray-100 transition-colors text-gray-700"
                                    >
                                        Cancel
                                    </motion.button>
                                    <motion.button
                                        whileHover={{ scale: 1.02 }}
                                        whileTap={{ scale: 0.98 }}
                                        onClick={() => {
                                            setShowDuplicateConfirmation(false);
                                            handleDuplicateConfirm();
                                        }}
                                        disabled={duplicateCourseHierarchyMutation.isPending}
                                        className="px-6 py-2 cursor-pointer text-sm font-medium bg-gradient-to-r from-blue-600 to-indigo-700 text-white rounded-lg hover:from-blue-700 hover:to-indigo-800 disabled:opacity-50 disabled:cursor-not-allowed transition-all shadow-md"
                                    >
                                        <div className="flex items-center gap-2">
                                            {duplicateCourseHierarchyMutation.isPending ? (
                                                <Loader2 className="w-4 h-4 animate-spin" />
                                            ) : (
                                                <Copy className="w-4 h-4" />
                                            )}
                                            {duplicateCourseHierarchyMutation.isPending ? 'Duplicating...' : 'Confirm Duplicate'}
                                        </div>
                                    </motion.button>
                                </div>
                            </div>
                        </motion.div>
                    </motion.div>
                )}
            </AnimatePresence>

            {/* Delete Confirmation Dialog */}
            <AnimatePresence>
                <Dialog open={showDeleteConfirmation} onOpenChange={setShowDeleteConfirmation}>
                    <DialogContent className="sm:max-w-md max-w-[95vw] rounded-xl shadow-lg border border-gray-200">
                        <motion.div
                            initial="hidden"
                            animate="visible"
                            exit="exit"
                            variants={popupVariants}
                        >
                            {/* Header */}
                            <DialogHeader className="border-b pb-3">
                                <div className="flex items-center gap-3">
                                    <div className="w-10 h-10 rounded-full bg-red-100 flex items-center justify-center">
                                        <AlertTriangle className="w-5 h-5 text-red-600" />
                                    </div>
                                    <div>
                                        <DialogTitle className="text-lg font-semibold text-gray-800">
                                            Confirm Deletion
                                        </DialogTitle>
                                        <DialogDescription className="text-sm text-gray-500">
                                            This action cannot be undone
                                        </DialogDescription>
                                    </div>
                                </div>
                            </DialogHeader>

                            <div className="space-y-4 p-4">
                                {/* Warning Message */}
                                <div className="bg-red-50 border border-red-200 rounded-lg p-3">
                                    <div className="flex items-start gap-2">
                                        <AlertTriangle className="w-4 h-4 text-red-600 mt-0.5 flex-shrink-0" />
                                        <div>
                                            <p className="text-sm font-medium text-red-800">
                                                You are about to delete {deleteMode.selectedItems.size} {deleteMode.type}(s)
                                            </p>
                                            <p className="text-xs text-red-600 mt-1">
                                                This will permanently remove the selected items and all associated data.
                                            </p>
                                        </div>
                                    </div>
                                </div>

                                {/* Selected Items Preview (if few items) */}
                                {deleteMode.selectedItems.size <= 5 && (
                                    <div className="bg-gray-50 rounded-lg p-3">
                                        <p className="text-xs font-medium text-gray-700 mb-2">Selected items:</p>
                                        <div className="space-y-1 max-h-20 overflow-y-auto">
                                            {Array.from(deleteMode.selectedItems).map((itemId, index) => {
                                                let itemName = "";
                                                switch (deleteMode.type) {
                                                    case 'module':
                                                        const module = modules.find(m => m._id === itemId);
                                                        itemName = module?.title || "Unknown Module";
                                                        break;
                                                    case 'submodule':
                                                        const subModule = subModules.find(sm => sm._id === itemId);
                                                        itemName = subModule?.title || "Unknown SubModule";
                                                        break;
                                                    case 'topic':
                                                        const topic = topics.find(t => t._id === itemId);
                                                        itemName = topic?.title || "Unknown Topic";
                                                        break;
                                                    case 'subtopic':
                                                        const subtopic = subTopics.find(st => st._id === itemId);
                                                        itemName = subtopic?.title || "Unknown Subtopic";
                                                        break;
                                                }
                                                return (
                                                    <div key={itemId} className="flex items-center gap-2 text-xs text-gray-600">
                                                        <div className="w-1.5 h-1.5 bg-gray-400 rounded-full"></div>
                                                        <span className="truncate">{itemName}</span>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                )}

                                {/* Action Buttons */}
                                <div className="flex gap-3 pt-2">
                                    <Button
                                        variant="outline"
                                        onClick={() => setShowDeleteConfirmation(false)}
                                        className="flex-1 text-sm border-gray-300 hover:bg-gray-50"
                                        disabled={isConfirmMultiDelete}
                                    >
                                        Cancel
                                    </Button>
                                    <Button
                                        variant="destructive"
                                        onClick={confirmMultipleDelete}
                                        disabled={isConfirmMultiDelete}
                                        className="flex-1 text-sm bg-red-600 hover:bg-red-700 transition-all"
                                    >
                                        {isConfirmMultiDelete ? (
                                            <div className="flex items-center gap-2">
                                                <Loader2 className="w-4 h-4 animate-spin" />
                                                Deleting...
                                            </div>
                                        ) : (
                                            `Yes, Delete ${deleteMode.selectedItems.size} Items`
                                        )}
                                    </Button>
                                </div>
                            </div>
                        </motion.div>
                    </DialogContent>
                </Dialog>
            </AnimatePresence>
            {/* Full Course Preview Dialog */}
            {showMainFullPreviewDialog && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                    <div className="bg-white rounded-xl shadow-2xl max-w-6xl w-full max-h-[90vh] flex flex-col">
                        {/* Header */}
                        <div className="flex items-center justify-between p-6 border-b border-gray-200 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-t-xl">
                            <div>
                                <h2 className="text-xl font-bold text-gray-900">Course Structure Preview</h2>
                                <p className="text-sm text-gray-600 mt-1">
                                    {selectedCourse?.courseName} - Complete hierarchy view
                                </p>
                            </div>
                            <button
                                onClick={() => setShowMainFullPreviewDialog(false)}
                                className="p-2 bg-red-500 hover:bg-red-600 rounded-md cursor-pointer transition-colors"
                                title="Close preview"
                            >
                                <X className="w-5 h-5 text-white" />
                            </button>
                        </div>

                        {/* Preview Content */}
                        <div className="flex-1 overflow-auto p-6">
                            {selectedCourse && (
                                <PreviewTable
                                    tableRows={tableRows}
                                    courseHours={courseHours}
                                    mergedCells={mergedCells}
                                    selectedCourse={selectedCourse}
                                    activityTypes={activityTypes}
                                    selectedPedagogyTypes={["iDo", "weDo", "youDo"]} // Show all pedagogy types
                                    moduleSpans={moduleSpans}
                                    subModuleSpans={subModuleSpans}
                                    topicSpans={topicSpans}
                                    exportSelections={{
                                        printPedagogy: null,
                                        hierarchy: {
                                            module: true,
                                            subModule: true,
                                            topic: true,
                                            subTopic: true,
                                            level: true,
                                        },
                                        pedagogy: {
                                            iDo: activityTypes["iDo"],
                                            weDo: activityTypes["weDo"],
                                            youDo: activityTypes["youDo"],
                                        },
                                        showSummary: false,
                                    }}
                                    isPrinting={false} onExport={function (): void {
                                        throw new Error("Function not implemented.");
                                    }} setExportSelections={function (value: React.SetStateAction<ExportSelections>): void {
                                        throw new Error("Function not implemented.");
                                    }} />
                            )}
                        </div>

                        {/* Footer */}
                        <div className="flex justify-between items-center p-4 border-t border-gray-200 bg-gray-50 rounded-b-xl">
                            <div className="text-sm text-gray-600">
                                Showing all hierarchy levels for {selectedCourse?.courseName}
                            </div>
                            <div className="flex gap-2">
                                <button
                                    onClick={() => setShowMainFullPreviewDialog(false)}
                                    className="px-4 py-2 cursor-pointer text-sm bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors"
                                >
                                    Close
                                </button>

                            </div>
                        </div>
                    </div>
                </div>
            )}
            <Toaster
                position="top-right"
                duration={4000}
                expand={false}
                richColors
                closeButton
            />
        </DashboardLayoutProgramcoordinator >
    )
}




















///////// validation for add form